<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"cs-cshi.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"valine","storage":true,"lazyload":false,"nav":null,"activeClass":"valine"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="leetcode 刷题记录，主要用 C++">
<meta property="og:type" content="article">
<meta property="og:title" content="顺序">
<meta property="og:url" content="https://cs-cshi.github.io/dataStrutures/leetcode/index.html">
<meta property="og:site_name" content="Chang">
<meta property="og:description" content="leetcode 刷题记录，主要用 C++">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/cs-cshi/image-host/leetcode/median_kth1.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/cs-cshi/image-host/leetcode/median_kth2.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/cs-cshi/image-host/leetcode/median_kth3.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/cs-cshi/image-host/leetcode/median_kth4.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/cs-cshi/image-host/leetcode/median_kth5.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/cs-cshi/image-host/leetcode/median_kth6.png">
<meta property="article:published_time" content="2021-07-04T03:30:00.000Z">
<meta property="article:modified_time" content="2021-07-11T13:05:12.309Z">
<meta property="article:author" content="Charles">
<meta property="article:tag" content="算法">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/cs-cshi/image-host/leetcode/median_kth1.png">

<link rel="canonical" href="https://cs-cshi.github.io/dataStrutures/leetcode/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>顺序 | Chang</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Chang</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页 | home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于 | about</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签 | tags<span class="badge">14</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类 | categories<span class="badge">25</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档 | archives<span class="badge">44</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索 | search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cs-cshi.github.io/dataStrutures/leetcode/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Charles">
      <meta itemprop="description" content="慢下来，记录生活点滴，畅游人类知识和艺术的海洋。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chang">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          顺序
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-04 11:30:00" itemprop="dateCreated datePublished" datetime="2021-07-04T11:30:00+08:00">2021-07-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-11 21:05:12" itemprop="dateModified" datetime="2021-07-11T21:05:12+08:00">2021-07-11</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">计算机基础</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/dataStrutures/leetcode/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/dataStrutures/leetcode/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>13k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>12 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>leetcode 刷题记录，主要用 C++</p>
<span id="more"></span>
<h1 id="1-数组"><a href="#1-数组" class="headerlink" title="1. 数组"></a>1. 数组</h1><h2 id="1-1-两数之和"><a href="#1-1-两数之和" class="headerlink" title="1.1 两数之和"></a>1.1 两数之和</h2><p><strong>题目描述</strong></p>
<blockquote>
<p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。</p>
</blockquote>
<blockquote>
<p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p>
</blockquote>
<blockquote>
<p>你可以按任意顺序返回答案。</p>
</blockquote>
<p><strong>示例 1：</strong></p>
<blockquote>
<p>输入：nums = [2,7,11,15], target = 9<br>输出：[0,1]<br>解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。</p>
</blockquote>
<p><strong>示例 2：</strong></p>
<blockquote>
<p>输入：nums = [3,2,4], target = 6<br>输出：[1,2]</p>
</blockquote>
<p><strong>示例 3：</strong></p>
<blockquote>
<p>输入：nums = [3,3], target = 6<br>输出：[0,1]</p>
</blockquote>
<p><strong>题解</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; nums.<span class="built_in">size</span>(); j++ )&#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] + nums[j] == target)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;i, j&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>&#123; &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>暴力破解，直接对数组循环两边，每遍对应 twoSum 的一个数字。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">twoSumHash</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; hashtable;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>( hashtable.<span class="built_in">end</span>() != hashtable.<span class="built_in">find</span>(target - nums[i]))</span><br><span class="line">            <span class="keyword">return</span> &#123;hashtable[target - nums[i]], i&#125;;</span><br><span class="line">        hashtable[nums[i]] = i;        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>利用 hash 表的特性，将寻找 twoSum 中另外一个数的时间复杂度降为 O(1)，遍历一遍。<br>利用 HashMap，键放数组中具体的值，值放索引。<br>C++ 对应的 HashMap 是 unordered_map 容器。如果 find 方法没有找到对应的 key，返回 hashtablel.end()</p>
</blockquote>
<h2 id="1-2-删除有序数组中的重复项"><a href="#1-2-删除有序数组中的重复项" class="headerlink" title="1.2 删除有序数组中的重复项"></a>1.2 删除有序数组中的重复项</h2><p><strong>题目描述</strong></p>
<blockquote>
<p>给你一个有序数组 nums ，请你原地删除重复出现的元素，使每个元素只出现一次，返回删除后数组的新长度。</p>
</blockquote>
<blockquote>
<p>不要使用额外的数组空间，你必须在原地修改输入数组 并在使用 O(1) 额外空间的条件下完成。</p>
</blockquote>
<p><strong>说明</strong><br>为什么返回数值是整数，但输出的答案是数组呢?</p>
<p>请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p>
<p>你可以想象内部操作如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝</span></span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">removeDuplicates</span>(nums);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在函数里修改输入数组对于调用者是可见的。</span></span><br><span class="line"><span class="comment">// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="built_in">print</span>(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>示例 1：</strong></p>
<blockquote>
<p>输入：nums = [1,1,2]<br>输出：2, nums = [1,2]<br>解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。</p>
</blockquote>
<p><strong>示例 2：</strong></p>
<blockquote>
<p>输入：nums = [0,0,1,1,1,2,2,3,3,4]<br>输出：5, nums = [0,1,2,3,4]<br>解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0,  1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。</p>
</blockquote>
<p><strong>提示：</strong></p>
<blockquote>
<p>0 &lt;= nums.length &lt;= 3 * 104<br>-104 &lt;= nums[i] &lt;= 104<br>nums 已按升序排列</p>
</blockquote>
<p><strong>题解</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="built_in">size</span>()==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt; nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[index]!=nums[i])</span><br><span class="line">        &#123;</span><br><span class="line">            ++index;</span><br><span class="line">            nums[index] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> index + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>双指针思想，第一个指针遍历原始数组，第二个指针指向去重后序列<br>按照题目描述，算法中 nums 应该只存有去重后的序列，而实际上官方的解决方案也没有对 nums 进行去重后对重复数据进行删除处理，目前想到的一种方案是使用 vector 的截取中间一段的函数，这要用到迭代器，可能会影响性能。或者再加一个迭代器，与第一个指针同步，用来实现原地删除。</p>
</blockquote>
<h2 id="1-3-移除元素"><a href="#1-3-移除元素" class="headerlink" title="1.3 移除元素"></a>1.3 移除元素</h2><p><strong>题目描述</strong></p>
<blockquote>
<p>给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。</p>
</blockquote>
<blockquote>
<p>不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。</p>
</blockquote>
<blockquote>
<p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p>
</blockquote>
<p><strong>说明</strong></p>
<blockquote>
<p>为什么返回数值是整数，但输出的答案是数组呢?</p>
</blockquote>
<blockquote>
<p>请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p>
</blockquote>
<blockquote>
<p>你可以想象内部操作如下:</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝</span></span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">removeElement</span>(nums, val);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在函数里修改输入数组对于调用者是可见的。</span></span><br><span class="line"><span class="comment">// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="built_in">print</span>(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>示例 1：</strong></p>
<blockquote>
<p>输入：nums = [3,2,2,3], val = 3<br>输出：2, nums = [2,2]<br>解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。</p>
</blockquote>
<p><strong>示例 2：</strong></p>
<blockquote>
<p>输入：nums = [0,1,2,2,3,0,4,2], val = 2<br>输出：5, nums = [0,1,4,0,3]<br>解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。</p>
</blockquote>
<p><strong>提示：</strong></p>
<blockquote>
<p>0 &lt;= nums.length &lt;= 100<br>0 &lt;= nums[i] &lt;= 50<br>0 &lt;= val &lt;= 100</p>
</blockquote>
<p><strong>题解</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> first = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> last = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (first &lt;= last)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[first] == val)</span><br><span class="line">        &#123;</span><br><span class="line">            nums[first] = nums[first] ^ nums[last];</span><br><span class="line">            nums[last] = nums[first] ^ nums[last];</span><br><span class="line">            nums[first] = nums[first] ^ nums[last];</span><br><span class="line">            last--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            first++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ol>
<li>双指针思想</li>
<li>两个数交换，使用按位异或，实现交换。<br>原理：一个数同另外一个属连续异或2次，可还原为它自己。</li>
</ol>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">lhs = lhs ^ rhs ; <span class="comment">// -1-</span></span><br><span class="line">rhs = lhs ^ rhs ; <span class="comment">// -2-</span></span><br><span class="line">lhs = lhs ^ rhs ; <span class="comment">// -3-</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// -1- -2- 合并后即为　rhs = (lhs ^ rhs) ^ rhs</span></span><br><span class="line"><span class="comment">// -2- -3- 合并后即为　lhs = lhs ^ (lhs ^ rhs)</span></span><br></pre></td></tr></table></figure>

<h2 id="1-4-搜索插入位置"><a href="#1-4-搜索插入位置" class="headerlink" title="1.4 搜索插入位置"></a>1.4 搜索插入位置</h2><p><strong>题目描述</strong></p>
<blockquote>
<p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p>
</blockquote>
<blockquote>
<p>你可以假设数组中无重复元素。</p>
</blockquote>
<p><strong>示例 1：</strong></p>
<blockquote>
<p>输入: [1,3,5,6], 5<br>输出: 2</p>
</blockquote>
<p><strong>示例 2:</strong></p>
<blockquote>
<p>输入: [1,3,5,6], 2<br>输出: 1</p>
</blockquote>
<p><strong>题解</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> right = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span>(left &lt;= right)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = left + ( right - left) / <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// return left，= 的判断要放 right。如果 = 放 left 侧判断，当 nums[mid] == target 时，会执行下面 +1 语句，返回结果会多1</span></span><br><span class="line">    <span class="keyword">if</span>( nums[mid] &lt; target )  </span><br><span class="line">    &#123;</span><br><span class="line">        left = mid + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>( nums[mid] &gt;= target )</span><br><span class="line">    &#123;</span><br><span class="line">        right = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> left;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>二分查找思想</p>
</blockquote>
<h2 id="1-5-最大子序和"><a href="#1-5-最大子序和" class="headerlink" title="1.5 最大子序和"></a>1.5 最大子序和</h2><p><strong>题目描述</strong></p>
<blockquote>
<p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
</blockquote>
<p><strong>示例 1：</strong></p>
<blockquote>
<p>输入：nums = [-2,1,-3,4,-1,2,1,-5,4]<br>输出：6<br>解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。</p>
</blockquote>
<p><strong>示例 2：</strong></p>
<blockquote>
<p>输入：nums = [1]<br>输出：1</p>
</blockquote>
<p><strong>进阶：</strong></p>
<blockquote>
<p>如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的 分治法 求解。</p>
</blockquote>
<p><strong>题解</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最大子序和</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// if (nums.size() == 1)</span></span><br><span class="line">    <span class="comment">//     return nums[0];</span></span><br><span class="line">    <span class="keyword">int</span> maxSum = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> currentSum = nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(currentSum &lt; <span class="number">0</span>)</span><br><span class="line">            currentSum = nums[i];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            currentSum += nums[i];</span><br><span class="line">        <span class="keyword">if</span>( currentSum &gt;= maxSum )</span><br><span class="line">            maxSum = currentSum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxSum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最大子序和</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxSubArray2</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxSum = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> currentSum = nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        currentSum = <span class="built_in">max</span>( nums[i], currentSum+nums[i] );</span><br><span class="line">        maxSum = <span class="built_in">max</span>(currentSum,maxSum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>核心点：如果当前序列和 &lt; 0，则丢弃当前序列和，从下一元素重新开始计算；<br>再用另一个元素记录 maxSum。</p>
</blockquote>
<h1 id="2-HOT-100"><a href="#2-HOT-100" class="headerlink" title="2. HOT 100"></a>2. HOT 100</h1><h2 id="2-1-两数之和"><a href="#2-1-两数之和" class="headerlink" title="2.1 两数之和"></a>2.1 两数之和</h2><p><strong>题目描述</strong></p>
<blockquote>
<p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。</p>
</blockquote>
<blockquote>
<p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p>
</blockquote>
<blockquote>
<p>你可以按任意顺序返回答案。</p>
</blockquote>
<p><strong>示例 1：</strong></p>
<blockquote>
<p>输入：nums = [2,7,11,15], target = 9<br>输出：[0,1]<br>解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。</p>
</blockquote>
<p><strong>示例 2：</strong></p>
<blockquote>
<p>输入：nums = [3,2,4], target = 6<br>输出：[1,2]</p>
</blockquote>
<p><strong>示例 3：</strong></p>
<blockquote>
<p>输入：nums = [3,3], target = 6<br>输出：[0,1]</p>
</blockquote>
<p><strong>题解</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; nums.<span class="built_in">size</span>(); j++ )&#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] + nums[j] == target)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;i, j&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>&#123; &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>暴力破解，直接对数组循环两边，每遍对应 twoSum 的一个数字。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">twoSumHash</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; hashtable;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>( hashtable.<span class="built_in">end</span>() != hashtable.<span class="built_in">find</span>(target - nums[i]))</span><br><span class="line">            <span class="keyword">return</span> &#123;hashtable[target - nums[i]], i&#125;;</span><br><span class="line">        hashtable[nums[i]] = i;        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>利用 hash 表的特性，将寻找 twoSum 中另外一个数的时间复杂度降为 O(1)，遍历一遍。<br>利用 HashMap，键放数组中具体的值，值放索引。<br>C++ 对应的 HashMap 是 unordered_map 容器。如果 find 方法没有找到对应的 key，返回 hashtablel.end()</p>
</blockquote>
<h2 id="2-2-两数相加"><a href="#2-2-两数相加" class="headerlink" title="2.2 两数相加"></a>2.2 两数相加</h2><p><strong>题目描述</strong></p>
<blockquote>
<p>给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。<br>请你将两个数相加，并以相同形式返回一个表示和的链表。<br>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>
</blockquote>
<p><strong>示例 1：</strong></p>
<blockquote>
<p>输入：l1 = [2,4,3], l2 = [5,6,4]<br>输出：[7,0,8]<br>解释：342 + 465 = 807.</p>
</blockquote>
<p><strong>示例 2：</strong></p>
<blockquote>
<p>输入：l1 = [0], l2 = [0]<br>输出：[0]</p>
</blockquote>
<p><strong>示例 3：</strong></p>
<blockquote>
<p>输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]<br>输出：[8,9,9,9,0,0,0,1]</p>
</blockquote>
<p><strong>题解</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">    ListNode *head = <span class="literal">nullptr</span>;    <span class="comment">// result 链表的头指针</span></span><br><span class="line">    ListNode *tail = <span class="literal">nullptr</span>;    <span class="comment">// result 链表的尾指针，用于新增 Node</span></span><br><span class="line">    <span class="keyword">int</span> carry = <span class="number">0</span>; <span class="comment">//进位</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当两个链表都没有遍历完时</span></span><br><span class="line">    <span class="keyword">while</span> (l1 != <span class="literal">nullptr</span> &amp;&amp; l2 != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> sum = l1-&gt;val + l2-&gt;val + carry;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            head = tail = <span class="keyword">new</span> <span class="built_in">ListNode</span>(sum % <span class="number">10</span>);  <span class="comment">// 开始构建 result 链表</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            tail-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(sum % <span class="number">10</span>);</span><br><span class="line">            tail = tail-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        carry = sum / <span class="number">10</span>; <span class="comment">// 更新进位</span></span><br><span class="line"></span><br><span class="line">        l1 = l1-&gt;next;</span><br><span class="line">        l2 = l2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// l2 遍历完，而 l1 没有遍历完的情形</span></span><br><span class="line">    <span class="keyword">while</span>(l1 != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 注意仍然需要判断是否进位</span></span><br><span class="line">        <span class="keyword">int</span> sum = l1-&gt;val + carry;</span><br><span class="line">        tail-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(sum%<span class="number">10</span>);</span><br><span class="line">        tail = tail-&gt;next;</span><br><span class="line">        l1 = l1-&gt;next;</span><br><span class="line">        carry = sum/<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// l1 遍历玩，而 l2 没有遍历完的情形</span></span><br><span class="line">    <span class="keyword">while</span>(l2 != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> sum = l2-&gt;val + carry;</span><br><span class="line">        tail-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(sum%<span class="number">10</span>);</span><br><span class="line">        tail = tail-&gt;next;</span><br><span class="line">        l2 = l2-&gt;next;</span><br><span class="line">        carry = sum/<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断最后一位是否发生了进位</span></span><br><span class="line">    <span class="keyword">if</span>(carry!=<span class="number">0</span>)&#123;</span><br><span class="line">        tail-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(carry);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-3-无重复字符的最长子串"><a href="#2-3-无重复字符的最长子串" class="headerlink" title="2.3 无重复字符的最长子串"></a>2.3 无重复字符的最长子串</h2><p><strong>题目描述</strong></p>
<blockquote>
<p>给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串的长度。</p>
</blockquote>
<p><strong>示例 1:</strong></p>
<blockquote>
<p>输入: s = “abcabcbb”<br>输出: 3 </p>
</blockquote>
<p><strong>示例 2:</strong></p>
<blockquote>
<p>输入: s = “bbbbb”<br>输出: 1</p>
</blockquote>
<p><strong>示例 3:</strong></p>
<blockquote>
<p>输入: s = “pwwkew”<br>输出: 3</p>
</blockquote>
<p><strong>示例 4:</strong></p>
<blockquote>
<p>输入: s = “”<br>输出: 0</p>
</blockquote>
<p><strong>题解</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    unordered_set&lt;<span class="keyword">char</span>&gt; hashset;</span><br><span class="line">    hashset.<span class="built_in">insert</span>(s[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">unsigned</span> maxLength = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> left = <span class="number">0</span>; <span class="comment">// 用来标识当前无重复字符串的起始位置</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> right = <span class="number">1</span>; right &lt; s.<span class="built_in">size</span>(); right++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!hashset.<span class="built_in">count</span>(s[right])) <span class="comment">// hashset 不存在当前字符</span></span><br><span class="line">        &#123;</span><br><span class="line">            hashset.<span class="built_in">insert</span>(s[right]);</span><br><span class="line">            maxLength = <span class="built_in">max</span>(maxLength, right - left + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (hashset.<span class="built_in">size</span>() == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                left++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            hashset.<span class="built_in">erase</span>(s[left]);</span><br><span class="line">            left++;</span><br><span class="line">            <span class="comment">// maxLength = max( maxLength, right-left);</span></span><br><span class="line">            <span class="keyword">while</span> (hashset.<span class="built_in">count</span>(s[right]) &gt; <span class="number">0</span>) <span class="comment">// 当前字符还与目前字符串有重复字符</span></span><br><span class="line">            &#123;</span><br><span class="line">                hashset.<span class="built_in">erase</span>(s[left]); <span class="comment">// 去除无重复字符串最左侧字符</span></span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            hashset.<span class="built_in">insert</span>(s[right]);</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="keyword">return</span> maxLength;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    unordered_set&lt;<span class="keyword">char</span>&gt; hashset;</span><br><span class="line">    <span class="keyword">int</span> right = <span class="number">-1</span>;  <span class="comment">// 相当于滑动窗口右边边界。初始时滑动窗口还不存在，为-1。 </span></span><br><span class="line">    <span class="keyword">int</span> maxLength = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> left = <span class="number">0</span>; left &lt; s.<span class="built_in">size</span>(); left++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>( left != <span class="number">0</span>  )</span><br><span class="line">            hashset.<span class="built_in">erase</span>(s[left<span class="number">-1</span>]);    <span class="comment">// 滑动窗口左侧向右移动一个位置</span></span><br><span class="line">        <span class="keyword">while</span> ( right + <span class="number">1</span> &lt; s.<span class="built_in">size</span>() &amp;&amp; !hashset.<span class="built_in">count</span>(s[right+<span class="number">1</span>]) )   <span class="comment">// 只有当滑动窗口下一个元素不在滑动窗口内时，才加入滑动窗口，并且滑动窗口右侧扩1</span></span><br><span class="line">        &#123;</span><br><span class="line">            hashset.<span class="built_in">insert</span>(s[right+<span class="number">1</span>]);</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        maxLength = <span class="built_in">max</span>(maxLength, right-left+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxLength;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-4-寻找两个正序数组的中位数"><a href="#2-4-寻找两个正序数组的中位数" class="headerlink" title="2.4 寻找两个正序数组的中位数"></a>2.4 寻找两个正序数组的中位数</h2><p><strong>题目描述</strong></p>
<blockquote>
<p>给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。</p>
</blockquote>
<p><strong>示例 1：</strong></p>
<blockquote>
<p>输入：nums1 = [1,3], nums2 = [2]<br>输出：2.00000</p>
</blockquote>
<p><strong>示例 2：</strong></p>
<blockquote>
<p>输入：nums1 = [], nums2 = [1]<br>输出：1.00000</p>
</blockquote>
<p><strong>提示：</strong></p>
<blockquote>
<p>nums1.length == m<br>nums2.length == n<br>0 &lt;= m &lt;= 1000<br>0 &lt;= n &lt;= 1000<br>1 &lt;= m + n &lt;= 2000<br>-106 &lt;= nums1[i], nums2[i] &lt;= 106</p>
</blockquote>
<p><strong>进阶：</strong></p>
<blockquote>
<p>你能设计一个时间复杂度为 O(log (m+n)) 的算法解决此问题吗？</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays1</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;nums1, vector&lt;<span class="keyword">int</span>&gt; &amp;nums2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> indexSum = nums1.<span class="built_in">size</span>() + nums2.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> midIndex = indexSum / <span class="number">2</span>;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; nums; <span class="comment">// 合并 num1,num2</span></span><br><span class="line">    <span class="keyword">unsigned</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> k = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其中一个数组为空</span></span><br><span class="line">    <span class="keyword">if</span> (nums1.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">        nums = nums2;</span><br><span class="line">    <span class="keyword">if</span> (nums2.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">        nums = nums1;</span><br><span class="line"></span><br><span class="line">    nums.<span class="built_in">resize</span>(indexSum); <span class="comment">// 两个数组都不为空，调整合并数组大小</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历两个待合并数组，直至其中一个数组遍历完</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; nums1.<span class="built_in">size</span>() &amp;&amp; j &lt; nums2.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums1[i] &gt; nums2[j])</span><br><span class="line">        &#123;</span><br><span class="line">            nums[k] = nums2[j];</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            nums[k] = nums1[i];</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; nums1.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        nums[k] = nums1[i];</span><br><span class="line">        i++;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (j &lt; nums2.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        nums[k] = nums2[j];</span><br><span class="line">        j++;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回合并数组的中位数</span></span><br><span class="line">    <span class="keyword">if</span> (indexSum % <span class="number">2</span> != <span class="number">0</span>) <span class="comment">// 奇</span></span><br><span class="line">        <span class="keyword">return</span> nums[midIndex];</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// 偶</span></span><br><span class="line">        <span class="built_in"><span class="keyword">return</span></span> (nums[midIndex] + nums[midIndex - <span class="number">1</span>]) / <span class="number">2.0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>第一种方法，对两个数组直接进行合并，然后返回中位数</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我们不需要合并的数组，实际上只要知道中位数在就行了。</span></span><br><span class="line"><span class="comment">// 开始的思路是进行一次完整的遍历，当到达中位数这个位置时就返回，但这里对奇偶以及边界判断会很麻烦，代码很乱，并且时间复杂度与第一种方法不变。</span></span><br><span class="line"><span class="comment">// 可以在循环处判断到中位数那个位置，同时记录下上一次遍历和这一次遍历的结果。对于奇，中位数就是当前位置，对于偶，就是与上一次结果的平均。</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays2</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;nums1, vector&lt;<span class="keyword">int</span>&gt; &amp;nums2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> indexSum = nums1.<span class="built_in">size</span>() + nums2.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> midIndex = indexSum / <span class="number">2</span> + <span class="number">1</span>; <span class="comment">// 中位数的位置，非索引</span></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;                    <span class="comment">// 上一轮的值</span></span><br><span class="line">    <span class="keyword">int</span> right = <span class="number">0</span>;                   <span class="comment">// 当前遍历的值</span></span><br><span class="line">    <span class="keyword">int</span> start1 = <span class="number">0</span>;                  <span class="comment">// 第一个数组遍历索引</span></span><br><span class="line">    <span class="keyword">int</span> start2 = <span class="number">0</span>;                  <span class="comment">// 第二个数组遍历索引</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> i = <span class="number">0</span>; i &lt; midIndex; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        left = right;</span><br><span class="line">        <span class="comment">// 需要先判断 nums1 是否为空，否则当 nums1 为空时，nums1[start1] 将会越界</span></span><br><span class="line">        <span class="comment">// 后部分需要先判断 start2 是否已经遍历完或者为空，否则 nums2[start2]会越界</span></span><br><span class="line">        <span class="keyword">if</span> (start1 &lt; nums1.<span class="built_in">size</span>() &amp;&amp; (start2 &gt;= nums2.<span class="built_in">size</span>() || nums1[start1] &lt; nums2[start2]))</span><br><span class="line">        &#123;</span><br><span class="line">            right = nums1[start1];</span><br><span class="line">            start1++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            right = nums2[start2];</span><br><span class="line">            start2++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (indexSum % <span class="number">2</span> != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in"><span class="keyword">return</span></span> (left + right) / <span class="number">2.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用的是二分法查找两个数组中第 k 小的数</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays3</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;nums1, vector&lt;<span class="keyword">int</span>&gt; &amp;nums2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums1.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> m = nums2.<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">// 将奇偶统一。如果总数是奇数，那个 left == right</span></span><br><span class="line">    <span class="keyword">int</span> left = (n + m + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> right = (n + m + <span class="number">2</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 返回第 left 小 和第 right 小的数的平均值</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">getKth</span>(nums1, <span class="number">0</span>, n - <span class="number">1</span>, nums2, <span class="number">0</span>, m - <span class="number">1</span>, left) + <span class="built_in">getKth</span>(nums1, <span class="number">0</span>, n - <span class="number">1</span>, nums2, <span class="number">0</span>, m - <span class="number">1</span>, right)) / <span class="number">2.0</span>;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// start、end 是索引，k指第几小 Kth</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getKth</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; nums1, <span class="keyword">int</span> start1, <span class="keyword">int</span> end1, vector&lt;<span class="keyword">int</span>&gt; nums2, <span class="keyword">int</span> start2, <span class="keyword">int</span> end2, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len1 = end1 - start1 + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> len2 = end2 - start2 + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归出口：其中一个数组为空，或者 k = 1，即求最小的数</span></span><br><span class="line">    <span class="comment">// 确保当存在数组为空时，一定是 nums1</span></span><br><span class="line">    <span class="keyword">if</span> ( len2 &lt; len1 )  <span class="comment">// 两个数组交换位置</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getKth</span>(nums2, start2, end2, nums1, start1, end1, k);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(len1 == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> nums2[start2 + k - <span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(k == <span class="number">1</span>)  <span class="comment">// 即返回最小的一个数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(nums1[start1], nums2[start2]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取两个数组第 k/2 的索引。还需要判断 k/2 是否超过数组长度 len 的情况</span></span><br><span class="line">    <span class="keyword">int</span> i = start1 + <span class="built_in">min</span>(k/<span class="number">2</span>, len1) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> j = start2 + <span class="built_in">min</span>(k/<span class="number">2</span>, len2) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从找第 k 小变成了 第 (k - 弃掉数个数)小了</span></span><br><span class="line">    <span class="comment">// 弃掉数可能是 k/2，也有可能是 len 长度</span></span><br><span class="line">    <span class="keyword">if</span> ( nums1[i] &gt; nums2[j] )  </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getKth</span>( nums1, start1, start2, nums2, j + <span class="number">1</span>, end2, k-( j - start2 + <span class="number">1</span>) );</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getKth</span>( nums1, i + <span class="number">1</span>, end1, nums2, start2, end2, k - ( i - start1 + <span class="number">1</span> ) );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>思路源于 leetcode 作者：windliang，链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-w-2/">https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-w-2/</a></p>
</blockquote>
<p>解法二中，我们一次遍历就相当于去掉不可能是中位数的一个值，也就是一个一个排除。由于数列是有序的，其实我们完全可以一半儿一半儿的排除。假设我们要找第 k 小数，我们可以每次循环排除掉 k/2 个数。看下边一个例子。</p>
<p>假设我们要找第 7 小的数字。<br><img src="https://cdn.jsdelivr.net/gh/cs-cshi/image-host/leetcode/median_kth1.png"></p>
<p>我们比较两个数组的第 k/2 个数字，如果 k 是奇数，向下取整。也就是比较第 33 个数字，上边数组中的 44 和下边数组中的 33，如果哪个小，就表明该数组的前 k/2 个数字都不是第 k 小数字，所以可以排除。也就是 11，22，33 这三个数字不可能是第 77 小的数字，我们可以把它排除掉。将 13491349 和 4567891045678910 两个数组作为新的数组进行比较。</p>
<p>更一般的情况 A[1] ，A[2] ，A[3]，A[k/2] … ，B[1]，B[2]，B[3]，B[k/2] … ，如果 A[k/2]&lt;B[k/2] ，那么A[1]，A[2]，A[3]，A[k/2]都不可能是第 k 小的数字。</p>
<p>A 数组中比 A[k/2] 小的数有 k/2-1 个，B 数组中，B[k/2] 比 A[k/2] 小，假设 B[k/2] 前边的数字都比 A[k/2] 小，也只有 k/2-1 个，所以<strong>比 A[k/2] 小的数字最多有 k/1-1+k/2-1=k-2个</strong>，所以 <strong>A[k/2] 最多是第 k-1 小的数</strong>。而比 A[k/2] 小的数更不可能是第 k 小的数了，所以可以把它们排除。</p>
<p>橙色的部分表示已经去掉的数字。<br><img src="https://cdn.jsdelivr.net/gh/cs-cshi/image-host/leetcode/median_kth2.png"></p>
<p>由于我们已经排除掉了 3 个数字，就是这 3 个数字一定在最前边，所以在两个新数组中，我们只需要找第 7 - 3 = 4 小的数字就可以了，也就是 k = 4。此时两个数组，比较第 2 个数字，3 &lt; 5，所以我们可以把小的那个数组中的 1 ，3 排除掉了。<br><img src="https://cdn.jsdelivr.net/gh/cs-cshi/image-host/leetcode/median_kth3.png"></p>
<p>我们又排除掉 2 个数字，所以现在找第 4 - 2 = 2 小的数字就可以了。此时比较两个数组中的第 k / 2 = 1 个数，4 == 4，怎么办呢？由于两个数相等，所以我们无论去掉哪个数组中的都行，因为去掉 1 个总会保留 1 个的，所以没有影响。为了统一，我们就假设 4 &gt; 4 吧，所以此时将下边的 4 去掉。<br><img src="https://cdn.jsdelivr.net/gh/cs-cshi/image-host/leetcode/median_kth4.png"></p>
<p>由于又去掉 1 个数字，此时我们要找第 1 小的数字，所以只需判断两个数组中第一个数字哪个小就可以了，也就是 4。</p>
<p>所以第 7 小的数字是 4。</p>
<p>我们每次都是取 k/2 的数进行比较，有时候可能会遇到数组长度小于 k/2的时候。<br><img src="https://cdn.jsdelivr.net/gh/cs-cshi/image-host/leetcode/median_kth5.png"></p>
<p>此时 k / 2 等于 3，而上边的数组长度是 2，我们此时将箭头指向它的末尾就可以了。这样的话，由于 2 &lt; 3，所以就会导致上边的数组 1，2 都被排除。造成下边的情况。<br><img src="https://cdn.jsdelivr.net/gh/cs-cshi/image-host/leetcode/median_kth6.png"></p>
<p>由于 2 个元素被排除，所以此时 k = 5，又由于上边的数组已经空了，我们只需要返回下边的数组的第 5 个数字就可以了。</p>
<p>从上边可以看到，无论是找第奇数个还是第偶数个数字，对我们的算法并没有影响，而且在算法进行中，k 的值都有可能从奇数变为偶数，<strong>最终都会变为 1 或者由于一个数组空了，直接返回结果。</strong></p>
<p>所以我们采用递归的思路，为了防止数组长度小于 k/2，所以每次比较 min(k/2，len(数组) 对应的数字，把小的那个对应的数组的数字排除，将两个新数组进入递归，并且 k 要减去排除的数字的个数。<strong>递归出口就是当 k=1 或者其中一个数字长度是 0 了。</strong></p>

    </div>

    
    
    
      

        <div class="reward-container">
  <div></div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechatpay.png" alt="Charles 微信支付">
        <p>微信支付</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/alipay.jpg" alt="Charles 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>

        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>Charles
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://cs-cshi.github.io/dataStrutures/leetcode/" title="顺序">https://cs-cshi.github.io/dataStrutures/leetcode/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E7%AE%97%E6%B3%95/" rel="tag"># 算法</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/Virtualbox%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5%E6%96%B9%E5%BC%8F%E8%AF%A6%E8%A7%A3/" rel="prev" title="Virtualbox虚拟机网络连接方式详解">
      <i class="fa fa-chevron-left"></i> Virtualbox虚拟机网络连接方式详解
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录 | toc
        </li>
        <li class="sidebar-nav-overview">
          站点概览 | overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-%E6%95%B0%E7%BB%84"><span class="nav-text">1. 数组</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="nav-text">1.1 两数之和</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2-%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9"><span class="nav-text">1.2 删除有序数组中的重复项</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-3-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0"><span class="nav-text">1.3 移除元素</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-4-%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE"><span class="nav-text">1.4 搜索插入位置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-5-%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C"><span class="nav-text">1.5 最大子序和</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-HOT-100"><span class="nav-text">2. HOT 100</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="nav-text">2.1 两数之和</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0"><span class="nav-text">2.2 两数相加</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2"><span class="nav-text">2.3 无重复字符的最长子串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-4-%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0"><span class="nav-text">2.4 寻找两个正序数组的中位数</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Charles"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Charles</p>
  <div class="site-description" itemprop="description">慢下来，记录生活点滴，畅游人类知识和艺术的海洋。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">44</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">25</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/cs-cshi" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;cs-cshi" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/572081809@qq.com" title="E-Mail → 572081809@qq.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



  <div class="links-of-recent-posts motion-element">
    <div class="links-of-recent-posts-title">
      <i class="fa fa-history fa-fw"></i>
      最近文章
    </div>
    <ul class="links-of-recent-posts-list">
        <li class="links-of-recent-posts-item">
          <a href="/dataStrutures/leetcode/" title="dataStrutures&#x2F;leetcode&#x2F;">顺序</a>
        </li>
        <li class="links-of-recent-posts-item">
          <a href="/Virtualbox%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5%E6%96%B9%E5%BC%8F%E8%AF%A6%E8%A7%A3/" title="Virtualbox虚拟机网络连接方式详解&#x2F;">Virtualbox虚拟机网络连接方式详解</a>
        </li>
        <li class="links-of-recent-posts-item">
          <a href="/cybersecurity/XCTF%E9%A2%98%E7%9B%AE/" title="cybersecurity&#x2F;XCTF题目&#x2F;">XCTF 攻防世界刷题</a>
        </li>
        <li class="links-of-recent-posts-item">
          <a href="/cybersecurity/Metasploit%20Framework/" title="cybersecurity&#x2F;Metasploit Framework&#x2F;">Metasploit Framework</a>
        </li>
        <li class="links-of-recent-posts-item">
          <a href="/pyshark%20%E8%A7%A3%E6%9E%90pcap%E8%8E%B7%E5%BE%97%20http%20header/" title="pyshark 解析pcap获得 http header&#x2F;">pyshark 解析 pcap 获取 http header</a>
        </li>
    </ul>
  </div>

      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Charles</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">247k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">3:45</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  
  <script src="//cdn.jsdelivr.net/npm/quicklink@1/dist/quicklink.umd.js"></script>
  <script>
      window.addEventListener('load', () => {
      quicklink({
        timeout : 3000,
        priority: true,
        ignores : [uri => uri.includes('#'),uri => uri === 'https://cs-cshi.github.io/dataStrutures/leetcode/',]
      });
      });
  </script>


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'hbdf2zNhxCCzlSuodiOKirnE-gzGzoHsz',
      appKey     : 'gJuRc9Mu4JIB0czCtRefSodC',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
